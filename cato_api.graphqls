"""
The @beta directive is used within the type system definition language to indicate beta portions of a
GraphQL service's schema, such as beta fields, enum values, arguments or input fields.
"""
directive @beta on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE | OBJECT

"""
The @ga directive is used within the type system definition language to indicate GA portions of a
GraphQL service's schema, such as GA fields, enum values, arguments or input fields.
"""
directive @ga on FIELD_DEFINITION

type Query {
  admin(accountId: ID!, adminID: ID!): GetAdminPayload @ga
  "BETA"
  appStats(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [Measure]
    dimensions: [Dimension]
    filters: [AppStatsFilter!]
    sort: [AppStatsSort!]
  ): AppStats @ga
  "BETA"
  appStatsTimeSeries(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [Measure]
    dimensions: [Dimension]
    filters: [AppStatsFilter!]
  ): AppStatsTimeSeries @ga
  admins(accountID: ID!, limit: Int = 50, from: Int = 0, search: String = "", sort: [SortInput], adminIDs: [ID!]): AdminsResult @ga
  """Lookup entities with a specific type, potentially filtered and paged"""
  entityLookup(
    """The account ID (or 0 for non-authenticated requests)"""
    accountID: ID!
    """Type of entity to lookup for"""
    type: EntityType!
    """Sets the maximum number of items to retrieve"""
    limit: Int = 50
    """Sets the offset number of items (for paging)"""
    from: Int = 0
    """
    Return items under a parent entity (can be site, vpn user, etc),
    used to filter for networks that belong to a specific site for example
    """
    parent: EntityInput
    """
    Adds additional search parameters for the lookup. Available options:
    country lookup: "removeExcluded" to return only allowed countries
    countryState lookup: country code ("US", "CN", etc) to get country's states
    """
    search: String = ""
    """
    Adds additional search criteria to fetch by the selected list of entity IDs. This option is not
    universally available, and may not be applicable specific Entity types. If used on non applicable entity
    type, an error will be generated.
    """
    entityIDs: [ID!]
    """
    Adds additional sort criteria(s) for the lookup.
    This option is not universally available, and may not be applicable specific Entity types.
    """
    sort: [SortInput]
    """Custom filters for entityLookup"""
    filters: [LookupFilterInput]
    """Additional helper fields"""
    helperFields: [String!]
  ): EntityLookupResult! @ga
  accountRoles(accountID: ID!, accountType: AccountType): AccountRolesResult! @ga
  accountBySubdomain(
    accountID: ID!
    """a list of required subdomains"""
    subdomains: [String!]!
  ): [AccountDataPayload!] @ga
  """
  The subdomain query helps you retrieve the URL of an account. The usage of this query supports 3 different scenarios:
  1. Regular account - Return only 1 subdomain relating to the regular account
  2. Reseller account - Return all subdomains including the reseller account subdomain
  3. Reseller account - Return only the reseller account subdomain
  """
  subDomains(
    """Unique Identifier of Account"""
    accountID: ID!
    """
    When the boolean argument managedAccount is set to true (default), then the query returns all subdomains related to the account
    """
    managedAccount: Boolean
  ): [SubDomain!]! @ga
  """Audit Feed for account changes"""
  auditFeed(
    """List of Unique Account Identifiers."""
    accountIDs: [ID!]
    ids: [ID!] @deprecated(reason: "by accountIDs")
    timeFrame: TimeFrame!
    filters: [AuditFieldFilterInput!]
    "Marker to use to get results from"
    marker: String
  ): AuditFeed @ga
  "BETA"
  events(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [EventsMeasure]
    dimensions: [EventsDimension]
    filters: [EventsFilter!]
    sort: [EventsSort!]
  ): Events @ga
  "BETA"
  eventsTimeSeries(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [EventsMeasure]
    dimensions: [EventsDimension]
    filters: [EventsFilter!]
  ): EventsTimeSeries @ga
  """Retrieve the account hardware inventory"""
  hardwareManagement(accountId: ID!): HardwareManagementQueries
  """Event Feed for events paged by a topic partitions offsets marker"""
  eventsFeed(
    """List of Unique Account Identifiers."""
    accountIDs: [ID!]
    filters: [EventFeedFieldFilterInput!]
    "Marker to use to get results from"
    marker: String
  ): EventsFeedData @ga
  """Retrieve the account(s) license inventory and license consumption"""
  licensing(accountId: ID!): LicensingQueries
  """
  The accountMetrics query helps you analyze the state and quality of the connections
  of sites and SDP users to the Cato Cloud. This data is for the traffic inside the DTLS
  tunnel between the site and the Cato Cloud. accountMetrics shows historical metrics,
  statics, and analytics for the account.
  """
  accountMetrics(
    """Unique Identifier of Account."""
    accountID: ID
    id: ID @deprecated(reason: "by accountID")
    """
    The time frame for the data that the query returns. The argument is in the format type.time value. This argument is mandatory.
    """
    timeFrame: TimeFrame!
    """
    When the boolean argument groupInterfaces is set to __true__, then the data for all the
    interfaces are aggregated to a single interface.
    """
    groupInterfaces: Boolean
    """
    When the boolean argument groupDevices is set to __true__, then the analytics for all the
    Sockets (usually two in high availability) are aggregated as one result.
    
    For the best results for aggregated Sockets, we recommend that there is consistent
    names and functionality (for example Destination) for the links on both Sockets.
    """
    groupDevices: Boolean
  ): AccountMetrics @ga
  """
  Current snapshot-based metrics that show near real‑time data for the account.
  Provides analytics that are similar to the Topology page for the account.
  """
  accountSnapshot(
    """Unique Identifier of Account."""
    accountID: ID
    id: ID @deprecated(reason: "by accountID")
  ): AccountSnapshot @ga
  policy(accountId: ID!): PolicyQueries
  xdr(accountID: ID!): XDR!
}

type Mutation {
  admin(accountId: ID!): AdminMutations!
  policy(accountId: ID!): PolicyMutations
  site(accountId: ID!): SiteMutations!
}

type AdminMutations {
  addAdmin(input: AddAdminInput!): AddAdminPayload @ga
  removeAdmin(adminID: ID!): RemoveAdminPayload @ga
  updateAdmin(adminID: ID!, input: UpdateAdminInput!): UpdateAdminPayload @ga
}

type GetAdminPayload {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  creationDate: String!
  passwordNeverExpires: Boolean!
  mfaEnabled: Boolean!
  managedRoles: [AdminRole!]
  resellerRoles: [AdminRole!]
}

input AddAdminInput {
  firstName: String!
  lastName: String!
  email: String!
  passwordNeverExpires: Boolean!
  mfaEnabled: Boolean!
  managedRoles: [UpdateAdminRoleInput!]
  resellerRoles: [UpdateAdminRoleInput!]
}

input UpdateAdminInput {
  firstName: String
  lastName: String
  passwordNeverExpires: Boolean
  mfaEnabled: Boolean
  managedRoles: [UpdateAdminRoleInput!]
  resellerRoles: [UpdateAdminRoleInput!]
}

type AddAdminPayload {
  adminID: ID!
}

type RemoveAdminPayload {
  adminID: ID!
}

type UpdateAdminPayload {
  adminID: ID!
}

enum AppStatsFieldName {
  "The application identifier"
  app
  "The application name"
  application
  "new cloud application identifier"
  new_app
  ""
  discovered_app
  "the total sum of upstream and downstream data in bytes"
  traffic
  "data uploaded to cloud applications"
  upstream
  "data downloaded from cloud applications"
  downstream
  "the application risk score assigned by Cato"
  risk_score
  ""
  risk_level
  "Is the application defined as sanctioned?"
  sanctioned
  "the country in which the registered application headquarteres is located"
  hq_location
  "indicates whether the application is considered cloud app/SaaS app"
  is_cloud_app
  "Cato system category of the application"
  category
  "Application description"
  description
  ""
  ip
  "Name of subnet as defined in Cato Management Application"
  subnet
  ""
  domain
  "IP for destination host or Cato Client"
  dest_ip
  "User identifier"
  user_id
  "User name"
  user_name
  "Source site or remote user identifier"
  src_site_id
  "Source site or remote user name"
  src_site_name
  "Country in which the source host is located"
  site_country
  "State in which the source host is located"
  site_state
  ""
  vpn_user_id @deprecated(reason: "use user_id instead")
  ""
  flows_created
  "Destination site or remote user identifier"
  dest_site
  "Destination is site or remote user"
  dest_is_site_or_vpn
  "Destination Site or remote user identifier"
  dest_site_id
  "Destination Site or remote user name"
  dest_site_name
  "Traffic direction"
  traffic_direction
  "Name for device related to the traffic"
  device_name
  "Active Directory name"
  ad_name
  "IP for source host or Cato Client"
  src_ip
  "Name for Socket interface"
  socket_interface
  "Source is site or remote user"
  src_is_site_or_vpn
}

type AppStats {
  id: ID
  from: DateTime
  to: DateTime
  total: Int
  totals: Map
  records(limit: Int, from: Int): [AppStatsRecord!]
}

type AppStatsRecord {
  fields: [AppStatsField!]
  fieldsUnitTypes: [UnitType!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  trends: Map
  prevTimeFrame: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
}

type AppStatsTimeSeries {
  id: ID
  from: DateTime
  to: DateTime
  granularity: Int
  timeseries(buckets: Int!): [Timeseries!]
}

type AppStatsField {
  name: AppStatsFieldName!
  value: Value!
}

input Measure {
  fieldName: AppStatsFieldName!
  aggType: AggregationType!
  trend: Boolean
}

input Dimension {
  fieldName: AppStatsFieldName!
}

input AppStatsFilter {
  fieldName: AppStatsFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input AppStatsSort {
  fieldName: AppStatsFieldName!
  order: DirectionEnum!
}

interface ObjectRef {
  "Object's unique identifier"
  id: ID!
  "Object's unique name"
  name: String!
}

enum ObjectRefBy {
  ID
  NAME
}

"Wall time. E.g.: 12:34:56 or 12:34"
scalar Time

"2006-01-02T15:04:05Z07:00 (RFC3339)"
scalar DateTime

"An IPv4 IP address"
scalar IPAddress

"""
Top level domain is actually second level domain (e.g. example.com)
It is recommended to use as a broad way of distinguishing domains, because they **frequently use multiple hosts**.
"""
scalar Domain

"""Fully Qualified Domain Name: An exact host name (e.g. www.example.com)"""
scalar Fqdn

enum OperatingSystem {
  WINDOWS
  MACOS
  IOS
  ANDROID
  LINUX
  EMBEDDED
}

"Network port number. Must be in range [0-65535] E.g.: 433, 8080, 80, etc.."
scalar Port

"16 bit autonomous system number [0-65535]"
scalar Asn16

"32 bit autonomous system number [0-4294967295]"
scalar Asn32

"A Uniform Resource Locator, colloquially known as an address on the Web. E.g.: http://www.example.com/page/"
scalar Url

enum DayOfWeek {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

"FF:FF:FF:FF OR FF-FF-FF-FF NOT TO ENFORCED UNTIL DATABASE ARE CLEANED "
scalar MacAddress

"Subnet in CIDR notation E.g.: 10.0.0.0/24"
scalar NetworkSubnet

"Inclusive range of IPs"
type IpAddressRange {
  from: IPAddress!
  to: IPAddress!
}

"Inclusive range of IPs"
input IpAddressRangeInput {
  from: IPAddress!
  to: IPAddress!
}

"Inclusive network port range"
type PortRange {
  from: Port!
  to: Port!
}

"Inclusive network port range"
input PortRangeInput {
  from: Port!
  to: Port!
}

enum IpProtocol {
  ANY
  TCP
  "TCP or UDP"
  TCP_UDP
  UDP
  ICMP
}

"Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol"
type CustomService {
  port: [Port!]
  portRange: PortRange
  protocol: IpProtocol!
}

"Add a Custom Service defined by a combination of L4 ports and an IP Protocol"
input CustomServiceInput {
  port: [Port!]
  portRange: PortRangeInput
  protocol: IpProtocol!
}

type UserRef implements ObjectRef {
  id: ID!
  name: String!
}

input UserRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type UsersGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input UsersGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type DeviceProfileRef implements ObjectRef {
  id: ID!
  name: String!
}

input DeviceProfileRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CustomCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input CustomCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type GroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input GroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

"""
Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
type FloatingSubnetRef implements ObjectRef {
  "Unique Floating Subnet ID"
  id: ID!
  "Name for the Floating Subnet"
  name: String!
}

"""
Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
input FloatingSubnetRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

type HostRef implements ObjectRef {
  id: ID!
  name: String!
}

input HostRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type NetworkInterfaceRef implements ObjectRef {
  id: ID!
  name: String!
}

input NetworkInterfaceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SiteRef implements ObjectRef {
  id: ID!
  name: String!
}

input SiteRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type AccountRef implements ObjectRef {
  id: ID!
  name: String!
}

type SiteNetworkSubnetRef implements ObjectRef {
  id: ID!
  name: String!
}

input SiteNetworkSubnetRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

input ApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ApplicationCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input ApplicationCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SanctionedAppsCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input SanctionedAppsCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CustomApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

input CustomApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ServiceRef implements ObjectRef {
  id: ID!
  name: String!
}

input ServiceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CountryRef implements ObjectRef {
  id: ID!
  name: String!
}

input CountryRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

type SubscriptionGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionGroupRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

type SubscriptionWebhookRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionWebhookRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

type SubscriptionMailingListRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionMailingListRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

type SystemGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input SystemGroupRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

type GlobalIpRangeRef implements ObjectRef {
  id: ID!
  name: String!
}

input GlobalIpRangeRefInput {
  input: String!
  by: ObjectRefBy! = ID
}

"Add a container by ID or name"
input ContainerRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

"A group with members of a single type of entity (for example: IP, FQDN)"
type ContainerRef implements ObjectRef {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

input SortOrderInput {
  direction: SortOrder! = ASC
  priority: Int! = 1
}

enum SortOrder {
  ASC
  DESC
}

type PageInfo {
  total: Int!
}

input FreeTextFilterInput {
  search: String!
}

enum EntityType {
  """A reference to a configured Site within Account"""
  site
  """A reference to the configured VPN User within Account"""
  vpnUser
  """Geographical and political entity recognized internationally"""
  country
  """
  Represents a state or territory within a country. It is a sub-division of the country
  """
  countryState
  """
  Time zone, which is a geographical region where clocks are set to the same time
  """
  timezone
  """A reference to the configured Host within Site"""
  host
  """Any entity (matches everything)"""
  any
  """A reference to the configured Network Interface within Site"""
  networkInterface
  location
  """An account administrator (user in Cato Console)"""
  admin
  "A reference to Local Routing Rule within Site"
  localRouting
  "A reference to LAN Firewall Rule within Site"
  lanFirewall
  """An external IP address in a specific PoP reserved for the account"""
  allocatedIP
  "union of the globalRange and a Subnet"
  siteRange
  "l4 services for LAN firewall rules"
  simpleService
  "Site licenses available for use"
  availableSiteUsage
  "Pooled licenses available for use"
  availablePooledUsage
  "A reference to DHCP Relay Group within account"
  dhcpRelayGroup
  "Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number"
  portProtocol
  """A settlement with over 1K population"""
  city
  groupSubscription
  mailingListSubscription
  webhookSubscription
  """A reference to a configured Account under reseller"""
  account
}

input PagingInput {
  limit: Int! = 100
  from: Int! = 0
}

input SortInput {
  field: String
  order: DirectionInput
}

enum DirectionInput {
  asc
  desc
}

type Entity {
  id: ID!
  name: String
  type: EntityType!
}

input EntityInput {
  id: ID!
  name: String
  type: EntityType!
}

type EntityInfo {
  entity: Entity!
  description: String!
  helperFields: Map!
}

type SubDomain {
  accountId: ID!
  accountName: String!
  accountType: String!
  subDomain: String!
}

input UpdateAccountRoleInput {
  id: ID!
  name: String
}

input UpdateAdminRoleInput {
  role: UpdateAccountRoleInput!
  allowedEntities: [EntityInput!]
  allowedAccounts: [ID!]
}

enum SiteType {
  BRANCH
  HEADQUARTERS
  CLOUD_DC
  DATACENTER
}

type AdminsResult {
  items: [Admin!]!
  total: Int!
}

type EntityLookupResult {
  items: [EntityInfo!]!
  total: Int
}

"""A CC2 administrator"""
type Admin {
  id: ID!
  version: String!
  role: UserRole
  firstName: String
  lastName: String
  email: String
  creationDate: DateTime
  modifyDate: DateTime
  status: OperationalStatus
  passwordNeverExpires: Boolean
  mfaEnabled: Boolean
  nativeAccountID: ID
  allowedItems: [Entity!]
  presentUsageAndEvents: Boolean
  managedRoles: [AdminRole!]
  resellerRoles: [AdminRole!]
}

enum UserRole {
  OWNER
  VIEWER
  PUBLIC_VIEWER
  PUBLIC_EDITOR
  EDITOR
  SUPER_USER
  SITES_VIEWER
}

enum AccountType {
  SYSTEM
  REGULAR
  RESELLER
  ALL
}

enum IpSecCipher {
  NONE
  AUTOMATIC
  AES_CBC_128
  AES_CBC_256
  AES_GCM_128
  AES_GCM_256
  DES3_CBC
}

enum IpSecHash {
  NONE
  AUTOMATIC
  MD5
  SHA1
  SHA256
  SHA384
  SHA512
}

enum IpSecDHGroup {
  NONE
  AUTOMATIC
  DH_2_MODP1024
  DH_5_MODP1536
  DH_14_MODP2048
  DH_15_MODP3072
  DH_16_MODP4096
  DH_19_ECP256
  DH_20_ECP384
  DH_21_ECP521
}

enum ConnectionMode {
  RESPONDER_ONLY
  BIDIRECTIONAL
}

enum IdentificationType {
  IPV4
  FQDN
  EMAIL
  KEY_ID
}

enum DestinationType {
  IPv4
  FQDN
}

enum ProtoType {
  SOCKET_X1500
  VSOCKET_VGX
  IPSEC_HOST
  IPSEC_CLIENT
  IPSEC_V2
  SOCKET_X1600
  SOCKET_X1700
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_ESX1500
  CROSS_CONNECT
  SOCKET_X1600_LTE
  VSOCKET_VGX_ESX
  VSOCKET_VGX_AWS
  VSOCKET_VGX_AZURE
}

enum SocketRegistrationStatus {
  NEW
  PENDING
  ASSIGNED_SITE
  REGISTERED
  REJECTED
  UNASSIGNING
  ASSIGNED_SITE_PENDING_REGISTER
}

enum SocketUpgradeStatus {
  PENDING
  PENDING_REBOOT
  STARTING
  STARTED
  SUCCESS
  FAIL
  SKIP
  CANCEL
  FATAL
  RETRY
}

enum SocketPlatform {
  X1500
  X1500_BR2
  X1500B_BR2
  X1600
  X1700
  X1700B
  AWS1500
  AZ1500
  ESX1500
  X1600_LTE
}

enum SubnetType {
  Routed
  Direct
  VLAN
  Native
  SecondaryNative
}

enum DhcpType {
  DHCP_RELAY
  DHCP_RANGE
  ACCOUNT_DEFAULT
  DHCP_DISABLED
}

input LookupFilterInput {
  filter: LookupFilterType
  value: String
}

enum LookupFilterType {
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
  "SOCKET",
  "IPSEC",
  "vSOCKET",
  "PHYSICAL_SOCKET"
  """
  filterByConnectionTypeFamily
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
  "SOCKET_X1500",
  "SOCKET_X1600",
  "SOCKET_X1700",
  "VSOCKET_VGX_ESX",
  "VSOCKET_VGX_AWS"
  "VSOCKET_VGX_AZURE"
  "SOCKET_X1600_LTE",
  """
  filterByConnectionType
  """
  Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
  "true",
  "false",
  """
  filterByAltWan
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
  "true",
  "false",
  """
  filterByBackhaulingGW
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
  "true",
  "false",
  """
  filterByOffCloudTransportEnabled
  """Custom filter for country, used by city and state entityLookup"""
  country
  """Custom filter for state used by city entityLookup"""
  state
}

type AccountRolesResult {
  items: [RBACRole!]!
  total: Int!
}

type AccountDataPayload {
  id: ID!
  name: String!
  subdomain: String!
}

enum IPSecV2InterfaceId {
  PRIMARY1
  PRIMARY2
  PRIMARY3
  SECONDARY1
  SECONDARY2
  SECONDARY3
}

enum SocketInterfaceDestType {
  CATO
  LAN
  VRRP_AND_LAN
  INTERFACE_DISABLED
  ALTERNATIVE
  LAYER_2_WAN
  VRRP
  LAN_LAG_MASTER_AND_VRRP
  LAN_LAG_MASTER
  LAN_LAG_MEMBER
  LAN_AND_HA
}

enum VrrpType {
  VIA_SWITCH
  DIRECT_LINK
}

"SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids"
enum SocketInterfaceIDEnum {
  LAN1
  LAN2
  WAN1
  WAN2
  USB1
  USB2
  INT_1
  INT_2
  INT_3
  INT_4
  INT_5
  INT_6
  INT_7
  INT_8
  INT_9
  INT_10
  INT_11
  INT_12
  WLAN
  LTE
}

enum SocketInterfaceRole {
  wan_1
  wan_2
  wan_3
  wan_4
}

type SiteMutations {
  addIpsecIkeV2Site(input: AddIpsecIkeV2SiteInput!): AddIpsecIkeV2SitePayload
  updateIpsecIkeV2SiteGeneralDetails(siteId: ID!, input: UpdateIpsecIkeV2SiteGeneralDetailsInput!): UpdateIpsecIkeV2SiteGeneralDetailsPayload
  addIpsecIkeV2SiteTunnels(siteId: ID!, input: AddIpsecIkeV2SiteTunnelsInput!): AddIpsecIkeV2SiteTunnelsPayload
  updateIpsecIkeV2SiteTunnels(siteId: ID!, input: UpdateIpsecIkeV2SiteTunnelsInput!): UpdateIpsecIkeV2SiteTunnelsPayload
  addSocketSite(input: AddSocketSiteInput!): AddSocketSitePayload @ga
  updateSiteGeneralDetails(siteId: ID!, input: UpdateSiteGeneralDetailsInput!): UpdateSiteGeneralDetailsPayload @ga
  removeSite(siteId: ID!): RemoveSitePayload @ga
  updateSocketInterface(siteId: ID!, socketInterfaceId: SocketInterfaceIDEnum!, input: UpdateSocketInterfaceInput!): UpdateSocketInterfacePayload @ga
  addNetworkRange(lanSocketInterfaceId: ID!, input: AddNetworkRangeInput!): AddNetworkRangePayload @ga
  updateNetworkRange(networkRangeId: ID!, input: UpdateNetworkRangeInput!): UpdateNetworkRangePayload @ga
  removeNetworkRange(networkRangeId: ID!): RemoveNetworkRangePayload @ga
  updateHa(siteId: ID!, input: UpdateHaInput!): UpdateHaPayload @ga
  addStaticHost(siteId: ID!, input: AddStaticHostInput!): AddStaticHostPayload @ga
  updateStaticHost(hostId: ID!, input: UpdateStaticHostInput!): UpdateStaticHostPayload @ga
  removeStaticHost(hostId: ID!): RemoveStaticHostPayload @ga
}

type AuditFeedAccountRecords {
  id: ID
  records(fieldNames: [AuditFieldName!]): [AuditRecord!]
}

type AuditFeed {
  from: DateTime
  to: DateTime
  marker: String
  fetchedCount: Int!
  hasMore: Boolean
  accounts: [AuditFeedAccountRecords]
}

"""
Search operators on ElasticSearch. Between operators are applicable only to numeric fields
Note that not operators are slower
"""
enum ElasticOperator {
  is
  is_not
  in
  not_in
  exists
  not_exists
  between
  not_between
}

"""
FieldName for the different types of FieldName inputs
Use the EventFieldName for events, and AuditFieldName for audit
"""
input FieldNameInput {
  EventFieldName: EventFieldName
  AuditFieldName: AuditFieldName
}

input AuditFieldFilterInput {
  fieldName: FieldNameInput!
  "Use AuditFieldName for audits"
  operator: ElasticOperator!
  values: [String!]
}

"""Represents a single event in the audit database"""
type AuditRecord {
  admin: Entity
  apiKey: Entity
  object: Entity
  account: EntityInfo
  time: DateTime
  "All fields in the audit record (including the admin and object)"
  fields: [AuditField!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
}

type StringValue {
  string: String
}

type DateValue {
  date: DateTime
}

union Value = StringValue | DateValue | Entity

type AuditField {
  name: String!
  value: Value!
}

enum AuditFieldName {
  "The admin whose action generated the record"
  admin
  "The api key whose action generated the record"
  apiKey
  "The name of the object that was affected, e.g. 'My Site'"
  model_name
  "The ID of the admin whose action generated the record"
  admin_id
  "Less granular than model_name, a general marker of the modified area: administration, configuration, security"
  module
  audit_creation_type
  "Time the record was committed to storage"
  insertion_date
  "the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`"
  change_type
  "Time the record was created"
  creation_date
  "The type of object that was affected. e.g. Site, Socket, SocketInterface"
  model_type
  "The name of the account on which the record was created"
  account
  "The id of the account on which the record was created"
  account_id
}

type Events {
  id: ID
  from: DateTime
  to: DateTime
  total: Int
  totals: Map
  records(limit: Int, from: Int): [EventsRecord!]
}

type EventsRecord {
  fields: [EventField!]
  fieldsUnitTypes: [UnitType!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  trends: Map
  prevTimeFrame: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
}

type EventsTimeSeries {
  id: ID
  from: DateTime
  to: DateTime
  granularity: Int
  timeseries(buckets: Int!): [Timeseries!]
}

input EventsMeasure {
  fieldName: EventFieldName!
  aggType: AggregationType!
  trend: Boolean
}

input EventsDimension {
  fieldName: EventFieldName!
}

input EventsFilter {
  fieldName: EventFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input EventsSort {
  fieldName: EventFieldName!
  order: DirectionEnum!
}

type EventField {
  name: EventFieldName!
  value: Value!
}

enum EventFieldName {
  "Name of site or user initiating the connection"
  src_site
  "Unique internal Cato ID for the site or remote user"
  src_site_id
  "Static host"
  static_host
  "User ID"
  user_id
  "For WAN traffic, name of destination site or SDP user"
  dest_site @deprecated(reason: "use dest_site_id/dest_site_name instead")
  "Unique internal Cato ID for the destination site or remote user"
  dest_site_id
  """
  Source or destination site or remote user ID.
  This field can only be used in filter.
  """
  src_or_dest_site_id
  "Name of security rule related to the event"
  rule @deprecated(reason: "use rule_name instead")
  """
  The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
  """
  ISP_name
  "Name for Socket interface"
  socket_interface
  "Name for the custom category defined in the Cato Management Application"
  custom_category @deprecated(reason: "use custom_category_id/custom_category_name instead")
  "Host name of Domain Controller that created LDAP event"
  directory_host_name
  "For Internet traffic, destination host port"
  dest_port
  "BGP ASN for remote peer"
  bgp_peer_asn
  "For Block/Prompt page, reference ID to report incorrect category"
  user_reference_id
  "Internal port number"
  src_port
  "Data that measures the packet loss for a specific link"
  link_health_pkt_loss
  "Name of PoP location"
  pop_name
  "IP address of host related to event"
  host_ip
  "Cato's description of the event"
  event_message
  "Source site or remote user"
  src_site_name
  "Domain name based on the SSL SNI, HTTP host name, or DNS name"
  domain_name
  "For Internet traffic, destination host IP address"
  dest_ip
  "File hash"
  file_hash
  "IP address provided by ISP to site or Client"
  src_isp_ip
  "Examples: MFA or password"
  authentication_type
  "Rule name"
  rule_name
  "Result of LDAP Domain Controller sync event"
  directory_sync_result
  "MAC address of host related to event"
  host_mac
  "Type of malware event"
  threat_type
  "Result of malware event (clean indicates a safe file)"
  threat_verdict
  "Name for device related to the event"
  device_name
  "Link type – Cato, Alt. WAN or LAG"
  link_type
  "Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)"
  login_type
  "For hosts configured with a static IP in the Cato Management Application, the host name"
  configured_host_name
  "Cato Internal-use only"
  internalId
  "Type of LDAP Domain Controller sync event"
  directory_sync_type
  "User’s email address"
  vpn_user_email
  "Type of process generating this traffic"
  client_class
  "For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)"
  incident_aggregation
  "Type of Socket reset (Hardware/Software)"
  socket_reset
  "User that generated the event"
  user_name
  "Socket or SDP Client version"
  client_version
  "File size"
  file_size
  "Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)"
  registration_code
  "BGP disconnect error code"
  bgp_error_code
  "Description from Cato Management Application for BGP peer"
  bgp_peer_description
  "For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked"
  threat_name
  "For QoS, the time that this QoS event started. The event is generated when the QoS event finishes"
  qos_reported_time
  "Network protocol for this event"
  ip_protocol
  "BGP ASN for Cato peer"
  bgp_cato_asn
  "IP for host or Cato Client"
  src_ip
  "Link to external malware reference"
  threat_reference
  "Firewall, QoS or LAG action"
  action
  "For LDAP sync events, name of the AD domain"
  windows_domain_name
  "(IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low – ie. adware Medium – ie. network scans High – ie. spyware or worms"
  risk_level
  "For Socket upgrade, previous version number"
  socket_old_version
  "Data that measures the latency for a specific link"
  link_health_latency
  "Protocol for the tunnel"
  tunnel_protocol
  "For Socket upgrades, new version number"
  socket_new_version
  "Socket version number"
  socket_version
  "Data that measures the jitter for a specific link"
  link_health_jitter
  "Socket upgrade start time (Linux epoch format)"
  upgrade_start_time
  "BGP IP for Cato peer"
  bgp_cato_ip
  "Cato system category"
  categories
  "Unique Cato ID for the security rule related to the event"
  rule_id
  "For Socket HA events, indicates if the Socket is primary or secondary"
  socket_role
  "Number of targets (servers) associated with this event"
  targets_cardinality
  "Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)"
  upgrade_initiated_by
  "For WAN traffic, destination is site or SDP user"
  dest_is_site_or_vpn
  "BGP IP for remote peer"
  bgp_peer_ip
  "Source type: site or remote user"
  src_is_site_or_vpn
  "Active Directory name"
  ad_name
  "Method used to get identity with User Awareness (such as Identity Agent)"
  user_awareness_method
  "Data that measures the congestion for a specific link"
  link_health_is_congested
  "Name of subnet as defined in Cato Management Application"
  subnet_name
  "OS version for the device (such as 14.3.0)"
  os_version
  "Sub-type for Routing, Security, Connectivity, System or Sockets Management event"
  event_sub_type
  "Host OS or tunnel device"
  os_type
  "Direction of network traffic for this event, values are inbound or outbound"
  traffic_direction
  "BGP disconnect error message"
  bgp_suberror_code
  "CIDR for BGP route"
  bgp_route_cidr
  "Unique Cato ID that identifies this security incident"
  incident_id
  "For Internet firewall, app for this event"
  application
  "Application of the flow"
  application_name
  "Application ID of the flow"
  application_id
  "Socket upgrade end time (Linux epoch format):"
  upgrade_end_time
  "Socket interface ID"
  socket_interface_id
  "Unique Cato ID for the custom category"
  custom_categories @deprecated(reason: "use custom_category_id/custom_category_name instead")
  "Custom category ID"
  custom_category_id
  "Custom category name"
  custom_category_name
  "Country in which the source host is located (detected via public IP address)"
  src_country
  "Country Code of country in which the source host is located (detected via public IP address)"
  src_country_code
  "Count for events that are repeated multiple times during one minute"
  event_count
  "File name"
  file_name
  "IP address of Domain Controller that created LDAP event"
  directory_ip
  "Time stamp of event (Linux epoch format)"
  time
  "URL associated with the event"
  url
  "For Internet traffic, country where the destination host is located"
  dest_country
  "For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)"
  dest_country_code
  "Amount of flows for a given incident"
  flows_cardinality
  "For Internet traffic, destination host IP address"
  dest_site_name
  "Routing, Security, Connectivity, System or Sockets Management event"
  event_type
  "Account ID"
  account_id
  "For IPS and SAM, ID of the IPS signature"
  signature_id
  "Expiration date for Client certificate"
  client_cert_expires
  "Name of Client certificate"
  client_cert_name
  "Is the app for this event defined as a sanctioned app? (True/False)"
  is_sanctioned_app
  "Name of application activity"
  app_activity
  "Activity type"
  app_activity_type
  "Device posture profiles"
  device_posture_profile
  "Device posture profiles"
  device_posture_profiles @deprecated(reason: "use device_posture_profile instead")
  "Full path URL application activity"
  full_path_url
  "Application risk score"
  application_risk
  "Mitre attack techniques"
  mitre_attack_techniques
  "Mitre attack subtechniques"
  mitre_attack_subtechniques
  "Mitre attack tactics"
  mitre_attack_tactics
  "Indicator"
  indicator
  "For SaaS Security API, SaaS app for the connector"
  connector_type
  "For SaaS Security API, name of the connector"
  connector_name
  "For SaaS Security API, status of the connector"
  connector_status
  "For SaaS Security API, parent Microsoft 365 connector"
  parent_connector_name
  "File type"
  file_type
  "DLP fail mode"
  dlp_fail_mode
  "DLP profiles related to the event"
  dlp_profiles
  "Matched DLP data types related to the event"
  matched_data_types
  "Severity defined for the rule"
  severity
  "For SaaS Security API, email address of the file owner"
  owner
  "For SaaS Security API, email addresses of the users that received the file"
  collaborators
  "Email Subject"
  email_subject
  "Sharing Options for the file (such as SharePoint)"
  sharing_scope
  "Cato’s DNS Protection type that matched the DNS request"
  dns_protection_category
  final_object_status
  object_name
  object_type
  object_id
  alert_id
  vendor
  vendor_user_id
  status
  classification
  quarantine_folder_path
  title
  recommended_actions
  pid @deprecated(reason: "use src_pid instead")
  parent_pid @deprecated(reason: "use src_process_parent_pid instead")
  process_path @deprecated(reason: "use src_process_path instead")
  failure_reason
  out_of_band_access
  logged_in_user
  "HTTP request method (ie. Get, Post)"
  http_request_method
  "XFF HTTP header indicates the original IP address for the connections"
  xff
  "Domain queried in the DNS request"
  dns_query
  "Name defined for the public API Key in the Cato Management Application"
  key_name
  api_type
  api_name
  "Related Apps"
  app_stack
  "TLS Inspection rule name"
  tls_rule_name
  "TLS Certificate Error"
  tls_certificate_error
  "TLS Version"
  tls_version
  "TLS Error Type"
  tls_error_type
  "TLS Error Description"
  tls_error_description
  "Cato App"
  cato_app
  "Prompt Page Selected Action"
  prompt_action
  "Unique Cato ID for devices"
  device_id
  "Unique Cato Visible ID for devices"
  visible_device_id
  "Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN"
  auth_method
  "Always-On Bypass Method"
  bypass_method
  "Always-On Bypass Duration In Seconds"
  bypass_duration_sec
  "Always-On Bypass Reason"
  bypass_reason
  "Sign In Types"
  sign_in_event_types
  "Tenant Id"
  tenant_id
  "Tenant Name"
  tenant_name
  "User Agent"
  user_agent
  "Vendor Event Id"
  vendor_event_id
  "Vendor Device Id"
  vendor_device_id
  "Vendor Device Name"
  vendor_device_name
  "Is Compliant"
  is_compliant
  "Is Managed"
  is_managed
  "Trust Type"
  trust_type
  "Confidence Level"
  confidence_level
  "Data Classifiers"
  dlp_scan_types
  "Network Access"
  network_access
  "Analyst Verdict"
  analyst_verdict
  "Criticality"
  criticality
  "Indication"
  indication
  "Producer"
  producer
  "Story Id"
  story_id
  "Raw Data"
  raw_data
  "Trigger"
  trigger
  "Matched network rule"
  network_rule
  "The algorithm that is used (CUBIC /NewReno / BBR)"
  congestion_algorithm
  "Shows if traffic was TCP accelerated or not"
  tcp_acceleration
  "Shows if traffic was TLS inspected or not"
  tls_inspection
  "Used Public IP"
  public_ip
  "Egress Site Name for backhauling traffic"
  egress_site_name
  "Egress PoP Name"
  egress_pop_name
  "QoS Priority value"
  qos_priority
  "Split Tunnel Configuration"
  split_tunnel_configuration
  "Pac File Enabled/Disabled"
  pac_file
  "Always-on Configuration"
  always_on_configuration
  "Lan access Allowed / Blocked"
  vpn_lan_access
  "Connect on boot Enabled/Disabled"
  connect_on_boot
  "Trusted networks Enabled/Disabled"
  trusted_networks
  "Office mode Enabled/Disabled"
  office_mode
  "Device Certificate Validated/Not Validated"
  device_certificate
  "Tunnel Protocol TCP/UDP"
  tunnel_ip_protocol
  "For SaaS Security API, description of Apps Security Notification"
  notification_description
  "For SaaS Security API, API Error of Apps Security Notification"
  notification_api_error
  "The URL that links directly to the object involved in the activity"
  reference_url
  "SaaS user activities into categories."
  app_activity_category
  "Indicates whether an activity requires administrative permissions."
  is_admin_activity
  "Classifies users based on their permissions."
  is_admin
  "Shows the display name of the target user involved in an activity"
  collaborator_name
  "The unique identifier by the SaaS vendor for the target group in an activity."
  dest_group_id
  "Identifies the target group involved in an activity"
  dest_group_name
  "Identifies system access software or device"
  access_method
  "Shows the id of the target user involved in an activity"
  vendor_collaborator_id
}

type HardwareManagementQueries {
  """Retrieve the account socket inventory"""
  socketInventory(input: SocketInventoryInput): SocketInventoryPayload!
}

input SocketInventoryInput {
  filter: SocketInventoryFilterInput
  paging: PagingInput
  sort: SocketInventoryOrderInput
}

input SocketInventoryFilterInput {
  """
  Will run contains operation for the provided text on the following fields serialNumber,socketMac,socketVersion,installedSite,
  shippingCompany,trackingNumber,deliverySiteName,description with OR between them
  """
  freeText: FreeTextFilterInput
}

input SocketInventoryOrderInput {
  """Default sort field"""
  status: SortOrderInput
  description: SortOrderInput
  deliverySiteName: SortOrderInput
  installedSite: SortOrderInput
  socketType: SortOrderInput
  serialNumber: SortOrderInput
  shippingDate: SortOrderInput
  shippingCompany: SortOrderInput
}

type SocketInventoryPayload {
  items: [SocketInventoryItem!]!
  pageInfo: PageInfo!
}

type SocketInventoryItem {
  """ID"""
  id: ID!
  """Socket status (see SocketInventoryItemStatus)"""
  status: SocketInventoryItemStatus
  """Serial number (unique)"""
  serialNumber: String
  """Mac address"""
  socketMac: MacAddress
  """Socket version"""
  socketVersion: String
  """Socket's site"""
  site: SiteRef
  """Socket account"""
  account: AccountRef!
  """Shipping date"""
  shippingDate: DateTime
  """Socket Type"""
  socketType: SocketPlatform
  """tracking url from the shipping company"""
  trackingUrl: Url
  """tracking number from the shipping company"""
  trackingNumber: String
  """Shipping company"""
  shippingCompany: String
  """Name of the delivery site"""
  deliverySiteName: String
  """Description"""
  description: String
  """Is primary socket"""
  isPrimary: Boolean!
  """Registration status"""
  registrationStatus: SocketRegistrationStatus
  """Available upgrade versions"""
  availableUpgradeVersions: [String!]!
  """Upgrade status"""
  upgradeStatus: SocketUpgradeStatus
  """Are automatic upgrade paused"""
  upgradesPaused: Boolean!
}

enum SocketInventoryItemStatus {
  ORDERED
  SHIPPED
  DELIVERED
  INSTALLED
  CONNECTED
}

input AddIpsecIkeV2SiteInput {
  """The name of the site"""
  name: String!
  """Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER."""
  siteType: SiteType! = BRANCH
  description: String
  """The native range of the site"""
  nativeNetworkRange: IPSubnet!
  """The location of the site"""
  siteLocation: AddSiteLocationInput!
}

input UpdateIpsecIkeV2SiteGeneralDetailsInput {
  """
  Determines the protocol for establishing the Security Association (SA) Tunnel. Valid values are:
  Responder-Only Mode: Cato Cloud only responds to incoming requests by the initiator (e.g. a Firewall device) to establish a security association.
  Bidirectional Mode: Both Cato Cloud and the peer device on customer site can initiate the IPSec SA establishment.
  """
  connectionMode: ConnectionMode
  """
  The authentication identification type used for SA authentication. When using “BIDIRECTIONAL”, it is set to “IPv4” by default. Other methods are available in Responder mode only.
  """
  identificationType: IdentificationType
  """The init message parameters"""
  initMessage: IpsecIkeV2MessageInput
  """The auth message parameters."""
  authMessage: IpsecIkeV2MessageInput
  """The local IP ranges for the SAs"""
  networkRanges: [IPSubnet]
}

input IpsecIkeV2MessageInput {
  """
  The SA tunnel encryption method. Note: For situations where GCM isn’t supported for the INIT phase, we recommend that you use the CBC algorithm for the INIT phase, and GCM for AUTH
  """
  cipher: IpSecCipher
  """
  The Diffie-Hellman Group. The first number is the DH-group number, and the second number is the corresponding prime modulus size in bits
  """
  dhGroup: IpSecDHGroup
  """
  The algorithm used to verify the integrity and authenticity of IPsec packets
  """
  integrity: IpSecHash
  """
  The Pseudo-random function (PRF) used to derive the cryptographic keys used in the SA establishment process
  """
  prf: IpSecHash
}

input LastMileBwInput {
  """
  The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
  """
  downstream: Int
  """
  The maximum upstream bandwidth, in Mbps. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
  """
  upstream: Int
}

input AddIpsecIkeV2TunnelInput {
  """The public IP address where the IPsec tunnel is initiated"""
  publicSiteIp: IPAddress
  """
  Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateCatoIp: IPAddress
  """
  Site private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateSiteIp: IPAddress
  """
  The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
  """
  lastMileBw: LastMileBwInput
  """Pre-shared key. This field is write-only."""
  psk: String!
}

input UpdateIpsecIkeV2TunnelInput {
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId!
  """The public IP address where the IPsec tunnel is initiated"""
  publicSiteIp: IPAddress
  """
  Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateCatoIp: IPAddress
  """
  Site private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateSiteIp: IPAddress
  """
  The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
  """
  lastMileBw: LastMileBwInput
  """Pre-shared key. This field is write-only."""
  psk: String
}

input UpdateIpsecIkeV2TunnelsInput {
  """The destination type of the IPsec tunnel"""
  destinationType: DestinationType
  """
  The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
  """
  publicCatoIpId: ID
  """The PoP location ID"""
  popLocationId: ID
  tunnels: [UpdateIpsecIkeV2TunnelInput!]!
}

input AddIpsecIkeV2TunnelsInput {
  """The destination type of the IPsec tunnel"""
  destinationType: DestinationType
  """
  The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
  """
  publicCatoIpId: ID
  """The PoP location ID"""
  popLocationId: ID
  tunnels: [AddIpsecIkeV2TunnelInput!]!
}

input UpdateIpsecIkeV2SiteTunnelsInput {
  """The configuration of the site’s primary tunnel"""
  primary: UpdateIpsecIkeV2TunnelsInput
  """The configuration of the site’s secondary tunnel"""
  secondary: UpdateIpsecIkeV2TunnelsInput
}

input AddIpsecIkeV2SiteTunnelsInput {
  """The configuration of the site’s primary tunnel"""
  primary: AddIpsecIkeV2TunnelsInput
  """The configuration of the site’s secondary tunnel"""
  secondary: AddIpsecIkeV2TunnelsInput
}

type AddIpsecIkeV2SitePayload {
  """The ID of the site"""
  siteId: ID!
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload {
  """The ID of the site"""
  siteId: ID!
  """The local ID for the site"""
  localId: String
}

type UpdateIpsecIkeV2SiteTunnelPayload {
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId
  """The local ID for the tunnel"""
  localId: String
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload {
  """Cato’s FQDN for the multi-tunnel"""
  fqdn: Fqdn
  tunnels: [UpdateIpsecIkeV2SiteTunnelPayload!]!
}

type AddIpsecIkeV2SiteTunnelPayload {
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId
  """The local ID for the tunnel"""
  localId: String
}

type AddIpsecIkeV2SiteMultiTunnelPayload {
  """Cato’s FQDN for the multi-tunnel"""
  fqdn: Fqdn
  tunnels: [AddIpsecIkeV2SiteTunnelPayload!]!
}

type UpdateIpsecIkeV2SiteTunnelsPayload {
  """The ID of the site"""
  siteId: ID!
  """The primary multi-tunnel"""
  primary: UpdateIpsecIkeV2SiteMultiTunnelPayload
  """The secondary multi-tunnel"""
  secondary: UpdateIpsecIkeV2SiteMultiTunnelPayload
}

type AddIpsecIkeV2SiteTunnelsPayload {
  """The ID of the site"""
  siteId: ID!
  """Cato’s FQDN for the primary tunnel"""
  primary: AddIpsecIkeV2SiteMultiTunnelPayload
  """Cato’s FQDN for the secondary tunnel"""
  secondary: AddIpsecIkeV2SiteMultiTunnelPayload
}

type EventRecord {
  time: DateTime
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
}

type EventsFeedAccountRecords {
  id: ID
  errorString: String
  records(fieldNames: [EventFieldName!]): [EventRecord!]
}

type EventsFeedData {
  marker: String
  fetchedCount: Int!
  accounts: [EventsFeedAccountRecords]
}

input EventFeedFieldFilterInput {
  fieldName: EventFeedFilterFieldName!
  "Use event_type and event_sub_type for events"
  operator: EventFeedFilterOperator!
  values: [String!]
}

"""Search operators on Event Feed"""
enum EventFeedFilterOperator {
  is
  is_not
  in
  not_in
}

enum EventFeedFilterFieldName {
  "Sub-type for Routing, Security, Connectivity, System or Sockets Management event"
  event_sub_type
  "Routing, Security, Connectivity, System or Sockets Management event"
  event_type
}

type LicensingQueries {
  """BETA"""
  licensingInfo: LicensingInfo
}

"""Public license API"""
type LicensingInfo {
  """License inventory"""
  licenses: [License!]!
  """License usage and allocation across the managed accounts"""
  globalLicenseAllocations: GlobalLicenseAllocations!
}

"""License usage and allocation across all accounts"""
type GlobalLicenseAllocations {
  """Public IP addresses usage across the accounts"""
  publicIps: PublicIpsLicenseAllocations
  """ZTNA license allocation across the accounts"""
  ztnaUsers: ZtnaUsersLicenseAllocations
}

"""IP addresses license usage and allocation across all accounts"""
type PublicIpsLicenseAllocations {
  total: Int!
  allocated: Int!
  available: Int!
}

"""Global ZTNA license usage and allocation across all accounts"""
type ZtnaUsersLicenseAllocations {
  """Total ZTNA licenses for users"""
  total: Int!
  """Total users allocated a ZTNA license"""
  allocated: Int!
  """Available users not yet allocated a license"""
  available: Int!
}

"""enum for license plan type (site license, service license, etc...)"""
enum LicensePlan {
  COMMERCIAL
  TRIAL
}

"""
enum for account plan status – the current license status within the license lifecycle
"""
enum LicenseStatus {
  """A license that is currently active"""
  ACTIVE
  """
  An existing license with a future start date that is not currently active
  """
  SCHEDULED
  """
  A license that is active before its start date, for partners and customers to verify the relevant configurations
  """
  STAGING
  """A license in a grace period"""
  LOCKED
  """An expired license is no longer active"""
  DISABLED
}

"""
An interface containing properties that are common to all license types
"""
interface License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

interface QuantifiableLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License initiation date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """license quantity"""
  total: Int!
}

enum LicenseSku {
  """Site bandwidth SASE SKU"""
  CATO_SITE
  """Site bandwidth SSE SKU"""
  CATO_SSE_SITE
  """Site pooled bandwidth SASE SKU"""
  CATO_PB
  """Site pooled bandwidth SSE SKU"""
  CATO_PB_SSE
  """ZTNA remote users SKUs"""
  MOBILE_USERS @deprecated(reason: "replaced with CATO_ZTNA_USERS")
  """ZTNA remote users SKUs"""
  CATO_ZTNA_USERS
  """Cato EPP service SKU"""
  CATO_EPP
  """Cato IPS (legacy) service SKU"""
  CATO_IPS
  """Cato Anti Malware (legacy) service SKU"""
  CATO_ANTI_MALWARE
  """Cato Anti Malware Next Generation (legacy) service SKU"""
  CATO_ANTI_MALWARE_NG
  """Cato CASB service SKU"""
  CATO_CASB
  """Cato DLP service SKU"""
  CATO_DLP
  """Cato ILMM service SKU"""
  CATO_ILMM
  """Cato MDR (XDR Pro) service SKU"""
  CATO_MDR
  """Cato NOCaaS service SKU"""
  CATO_NOCAAS_HF
  """Cato Remote Browser Isolation (RBI) service SKU"""
  CATO_RBI
  """Cato SAAS Group SKU"""
  CATO_SAAS
  """
  Cato SAAS Security API with one application integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_ONE_APP
  """
  Cato SAAS Security API with two applications integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_TWO_APPS
  """
  Cato SAAS Security API with more than two Applications integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_ALL_APPS
  CATO_SAAS_SECURITY_API
  """Cato XDR service SKUs"""
  CATO_XDR_PRO
  """Cato DEM Pro service SKU"""
  CATO_DEM_PRO
  """Cato Threat Prevention (legacy) service SKU"""
  CATO_THREAT_PREVENTION
  """Public IPs SKU"""
  CATO_IP_ADD
  """Cato datalake Group SKU"""
  CATO_DATALAKE
  """3 months data retention SKU"""
  CATO_DATALAKE_3M
  """6 months data retention SKU"""
  CATO_DATALAKE_6M
  """12 months data retention SKU"""
  CATO_DATALAKE_12M
}

type DataLakeLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """
  The version of the Data Processing Agreement (DPA) that your company signed with Cato.
  """
  dpaVersion: DpaVersion!
  """
  Data retention period, in months, during which the account data may remain on the Cato Cloud. After this period the data will be permanently deleted.
  """
  retentionPeriod: Int!
  """
  Total number of the Data Storage Units under this license. Each Data Storage Unit increases the allowed ingestion rate (events per hour and total events storage)
  """
  total: Int!
}

"""The DPA agreement, based on your contract with Cato"""
enum DpaVersion {
  DPA_2019_01
  DPA_2021_01
  DPA_2023_01
}

"""Public IP address license"""
type PublicIpsLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """The number of public IPs available in the licenses"""
  total: Int!
}

"""Site bandwidth license"""
type SiteLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """The license group."""
  siteLicenseGroup: SiteLicenseGroup!
  """
  For the relevant license groups, indicates whether this is a global or regional license. For other regions, the value is set to ‘NA’ (not applicable).
  """
  regionality: Regionality
  """The selected service type, e.g SASE or SSE."""
  siteLicenseType: SiteLicenseType!
  """Maximum available bandwidth for the site, in Mbps"""
  total: Int!
  """Identifying data for the site the license is assigned to"""
  site: SiteRef
}

type PooledBandwidthLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """Regional license group"""
  siteLicenseGroup: SiteLicenseGroup!
  """The selected service type, e.g SASE or SSE."""
  siteLicenseType: SiteLicenseType!
  """
  Maximum available bandwidth, in Mbps, for all the sites under this license. This constitutes the bandwidth pool that is allocated to different sites.
  """
  total: Int!
  """
  allocated bandwidth, in Mbps, for all the sites assigned to this license.
  """
  allocatedBandwidth: Int!
  """
  Sites that this license is assigned to (and the license usage within each site)
  """
  sites: [PooledBandwidthLicenseSite!]!
  """
  Accounts that this license is assigned to (and the license usage within each account)
  """
  accounts: [PartnerPooledBandwidthLicenseAccount!]!
}

type PooledBandwidthLicenseSite {
  """Identifying data for the site"""
  site: SiteRef!
  """Allocated bandwidth for this site"""
  allocatedBandwidth: Int!
}

type PartnerPooledBandwidthLicenseAccount {
  """Identifying data for the account"""
  account: AccountRef!
  """Allocated bandwidth for this account"""
  allocatedBandwidth: Int!
}

enum SiteLicenseGroup {
  GROUP_1
  GROUP_2
  """Country with stand-alone licenses (not part of a group)"""
  MOROCCO
  """Country with stand-alone licenses (not part of a group)"""
  CHINA
  """Country with stand-alone licenses (not part of a group)"""
  VIETNAM
  """legacy license group"""
  ANZ
  """legacy license group"""
  APJ
  """legacy license group"""
  AFRICA
  """legacy license group"""
  DUBAI
  """legacy license group"""
  EUROPE
  """legacy license group"""
  MIDDLE_EAST
  """legacy license group"""
  NAM
  """legacy license group"""
  LATAM
}

enum SiteLicenseType {
  SSE
  SASE
}

"""ZTNA remote users license"""
type ZtnaUsersLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """Specify a license group that you are limiting the number of ZTNA users"""
  ztnaUsersLicenseGroup: ZtnaUsersLicenseGroup!
  """The maximum amount of ZTNA users for the region."""
  total: Int!
}

"""Geographical regions that can be associated with a remote user license"""
enum ZtnaUsersLicenseGroup {
  GENERAL
  """Country with stand-alone licenses (not part of a group)"""
  MOROCCO
  """Country with stand-alone licenses (not part of a group)"""
  VIETNAM
  """Country with stand-alone licenses (not part of a group)"""
  CHINA
  """Legacy group"""
  DUBAI
  """Legacy group"""
  LATAM
}

"""
REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
"""
enum Regionality {
  """Site traffic within the region"""
  REGIONAL
  """Global traffic going outside of the region"""
  GLOBAL
}

"""End Point Protection (EPP) license details"""
type EndpointProtectionLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """The maximum number of users that can use this service"""
  total: Int!
}

"""Intelligent Last Mile Monitoring (ILMM) License details"""
type IlmmLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """The total amount of ILMM licenses."""
  total: Int!
}

"""
Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
"""
type IpsLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Anti-Malware service license details (Legacy license, replaced by TP)"""
type MalwareProtectionLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""
NG Anti-Malware service license details (Legacy license, replaced by TP)
"""
type NextGenMalwareProtectionLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Threat Prevention (TP) license details"""
type ThreatPreventionLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""NOC as a Service (NOCaaS) service license details"""
type NOCaaSLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Cloud Access Security Broker (CASB) service license details"""
type CasbLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Data Loss Prevention (DLP) Service license details"""
type DlpLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Managed XDR service license details"""
type ManagedXdrLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""Remote Browser Isolation (RBI) service license details"""
type RbiLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

"""SaaS Security API service license details"""
type SaasSecurityApiLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """license quantity"""
  total: Int!
}

"""XDR Pro (extended detection and response) service license details"""
type XdrProLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """The number of knowledge users that the XDR Pro service refers to"""
  total: Int!
}

"""DEM Pro service license details"""
type DemProLicense implements License & QuantifiableLicense {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License quantity"""
  total: Int!
}

type AccountMetrics {
  """Unique Identifier of Account."""
  id: ID
  """Starting time"""
  from: DateTime
  """Ending time"""
  to: DateTime
  """The size of a single time bucket in seconds"""
  granularity: Int
  """Site connectivity metrics for the requested sites."""
  sites(
    """
    A list of unique IDs for each site. If specified, only sites in this list are returned. Otherwise, all sites are returned.
    """
    siteIDs: [ID!]
    ids: [String!] @deprecated(reason: "by siteIDs")
  ): [SiteMetrics!]
  """
  Connectivity metrics for the requested users connecting remotely with the Client.
  Doesn’t include user traffic behind a site.
  """
  users(
    """
    A list of unique IDs for each user. If specified, only users in this list are returned. Otherwise, no user metrics are returned.
    """
    userIDs: [ID!]
  ): [SiteMetrics!]
  timeseries(
    labels: [TimeseriesMetricType!]
    "number of buckets, defaults to 10, max 1000"
    buckets: Int
  ): [Timeseries!]
}

type AccountSnapshot {
  """Unique Identifier of Account"""
  id: ID
  "Sites includes information about online as well as offline sites"
  sites(
    """
    List of Unique Site Identifiers. If specified, only sites in list will be returned
    """
    siteIDs: [ID!]
    ids: [Int!] @deprecated(reason: "by siteIDs")
  ): [SiteSnapshot!]
  "VPN users information includes only connected users by default (Unlike sites), unless specific ID is requested"
  users(
    "request specific IDs, regardless of if connected or not"
    userIDs: [ID!]
    ids: [Int!] @deprecated(reason: "by userIDs")
  ): [UserSnapshot!]
  timestamp: DateTime
}

"""A general structure to contain IP detailed information"""
type IPInfo {
  """IP address of the link"""
  ip: String
  """Geolocation ISO country code"""
  countryCode: String
  """Geolocation country name"""
  countryName: String
  """Geolocation city"""
  city: String
  """Geolocation state"""
  state: String
  """ISP Internet provider"""
  provider: String
  """Geolocation latitude for the ISP"""
  latitude: Float
  """Geolocation longitude for the ISP"""
  longitude: Float
}

"""Basic information about socket"""
type SocketInfo {
  """Unique ID for Socket"""
  id: String
  """Serial number for the Socket"""
  serial: String
  """
  For HA configurations, when this boolean value is true, this the primary Socket
  """
  isPrimary: Boolean
  """Shows Socket type"""
  platform: SocketPlatform
  """Software version number that is currently installed on the Socket"""
  version: String
  """Timestamp when the Socket upgraded to the current hardware version"""
  versionUpdateTime: DateTime
}

"""Basic IPSec configuration information"""
type IPSecInfo {
  """
  For HA configurations, when this boolean value is true, this the primary IPsec firewall or routing device
  """
  isPrimary: Boolean
  """The source IP address for the IPsec tunnel in the Cato Cloud"""
  catoIP: String
  """The destination IP address for the IPsec tunnel (in the site)"""
  remoteIP: String
  """Shows 1 for IKEv1 and 2 for IKEv2"""
  ikeVersion: Int
}

"""Basic Socket Interface configuration information"""
type InterfaceInfo {
  """ID for the Socket port in the Socket WebUI Monitor tab"""
  id: ID!
  """Name for the port in the Cato Management Application"""
  name: String
  """
  Maximum allowed bandwidth on this port, for traffic from the site to the Cato Cloud
  """
  upstreamBandwidth: Int
  """
  Maximum allowed bandwidth for traffic on this port, from the Cato Cloud to the site
  """
  downstreamBandwidth: Int
  """The destination type configured to the Socket interface"""
  destType: String
}

"""Basic Site configuration information"""
type SiteInfo {
  """Name for the site"""
  name: String
  """
  Site type in the Cato Management Application, such as branch office or datacenter
  """
  type: SiteType
  """User defined description of the site"""
  description: String
  """Code for the Country that is the physical location of the site"""
  countryCode: String
  """Geographical PoP region that the site is licensed to use"""
  region: String
  """Country that is the physical location of the site"""
  countryName: String
  """
  When this boolean value is true, the site is enabled for high availability
  """
  isHA: Boolean
  """
  The Connection Type field defines how the site connects to the Cato Cloud, such as X1500 Socket or AWS vSocket (array with nested fields)
  """
  connType: ProtoType
  """Timestamp for when the site was created"""
  creationTime: DateTime
  """Basic configuration information about the Socket interface"""
  interfaces: [InterfaceInfo!]
  """
  Data related to Socket and vSocket sites, such as serial number and Socket version (array with nested fields)
  """
  sockets: [SocketInfo!]
  """data related to IPsec sites, such as IKE version"""
  ipsec: [IPSecInfo!]
}

"""Basic Site Ha readiness information"""
type HaStatus {
  readiness: HaReadiness
  wanConnectivity: HaSubStatus
  keepalive: HaSubStatus
  socketVersion: HaSubStatus
}

"Basic User configuration information"
type UserInfo {
  """Name of the VPN user"""
  name: String
  """Status of the Client as the type STRING"""
  status: OperationalStatus
  """Email address of the VPN user"""
  email: String
  """Timestamp when the VPN user was created in the account"""
  creationTime: DateTime
  """Phone number for the VPN user"""
  phoneNumber: String
  "User creation mechanism, current supported REGULAR or LDAP"
  origin: String
  "Additional authentication mechanism, currently MFA or NONE"
  authMethod: String
}

type RecentConnection {
  "The duration of the connection"
  duration: Int
  """Name for the port in the Cato Management Application"""
  interfaceName: String
  """Serial number for the Device"""
  deviceName: String
  "The last time this connection was detected (so lastConnected - duration is the start of the connection"
  lastConnected: DateTime
  "The name of the PoP that the traffic flow was connected to"
  popName: String
  """IP address the ISP allocates to the WAN link"""
  remoteIP: String
  """
  IP address, ISP, and geographical information related to the PoP that the traffic flow was connected to
  """
  remoteIPInfo: IPInfo
}

type InterfaceLinkState {
  """The ID for the specific Socket port, for example LAN1 or LAN2"""
  id: ID
  """When this boolean value is true, then the link for the port is up"""
  up: Boolean
  """
  When this boolean value is true, then a cable is connected to the Socket port
  """
  mediaIn: Boolean
  """Shows the maximum bandwidth configured for the link"""
  linkSpeed: String
  """Shows the duplex mode for the link"""
  duplex: String
}

type DeviceSnapshot {
  """Unique internal Cato ID for the Socket"""
  id: ID
  """Name of the device"""
  name: String
  """Unique identifier for the device"""
  identifier: String
  """
  A boolean value that indicates if the site is connected to the Cato Cloud
  """
  connected: Boolean
  """
  Shows if this is the primary or secondary Socket in high availability mode
  """
  haRole: String
  """Snapshot data for outbound facing interfaces"""
  interfaces: [InterfaceSnapshot!]
  """The last time the device was seen"""
  lastConnected: DateTime
  """
  The uptime of the last tunnel from this device (or current), in seconds
  """
  lastDuration: Int
  """For connected devices (this somewhat overlaps to last duration)"""
  connectedSince: DateTime
  """The ID of the PoP that the Socket is connected to"""
  lastPopID: Int
  """The PoP name that the Socket is connected to"""
  lastPopName: String
  """Data related to the most recent completed traffic flows"""
  recentConnections: [RecentConnection!]
  """Shows the Socket model or vSocket type"""
  type: String
  """Shows data related to the Socket, such as version and serial number"""
  socketInfo: SocketInfo
  """
  Information of the link state of various interfaces in the devices. Unlike the `interfacess` field, it contains
     all links of the device, not just the outbound facing ones
  """
  interfacesLinkState: [InterfaceLinkState!]
  """Operating system of the Device."""
  osType: String
  """Version of the Socket operating system"""
  osVersion: String
  """Device version"""
  version: String
  """Device major version"""
  versionNumber: Int
  """Shows the release group for the site"""
  releaseGroup: String
  """Shows the amount of time remaining before the MFA token expires"""
  mfaExpirationTime: Int
  """The time the mfa cookie (for sdp users) was created"""
  mfaCreationTime: Int
  """Device's internal IP in the account's routing table"""
  internalIP: String
}

type InterfaceMetrics {
  """Traffic data for the link"""
  metrics(
    "Normalize collected metrics as per-second values"
    toRate: Boolean = false
  ): Metrics
  """Link name in the Cato Management Application"""
  name: String
  """
  For site metrics, timeseries info field will include: siteID, interfaceName, for last mile metrics it will also
  include the destination last mile check
  """
  timeseries(buckets: Int, labels: [TimeseriesMetricType!]): [Timeseries!]
  """Time stamp annotation that shows a time increment for a GUI"""
  annotations(types: [String!]): [TimeAnnotation!]
  """object that is a specific time duration"""
  periods: [TimePeriod!]
  """Data related to the link IP address, such as country code"""
  remoteIPInfo: IPInfo
  """IP address the ISP allocates to the WAN link"""
  remoteIP: String
  """
  Data related to Socket and vSocket sites, such as serial number and Socket version. Applicable only for site
  """
  socketInfo: SocketInfo
  """
  Data related to IPsec sites, such as IKE version . Applicable only for site
  """
  ipsecInfo: IPSecInfo
  """
  Basic configuration information about the Socket interface . Applicable only for site
  """
  interfaceInfo: InterfaceInfo
}

type InterfaceSnapshot {
  """Shows if the WAN link is connected to the PoP"""
  connected: Boolean
  """Interface ID for the WAN link"""
  id: ID
  """WAN link name in the Cato Management Application"""
  name: String
  """Physical WAN port on the Socket"""
  physicalPort: Int
  """Interface Natural order for WAN link"""
  naturalOrder: Int
  """The name of the PoP that the WAN link is connected to"""
  popName: String
  """
  The ID of the PoP that the WAN link was connected to before the current one
  """
  previousPopID: Int
  """
  The name of the PoP that the WAN link was connected to before the current one
  """
  previousPopName: String
  """
  Reason that the tunnel required a new connection (for example, PoP or Socket restarted)
  """
  tunnelConnectionReason: String
  """Number of seconds that the tunnel is connected to a PoP"""
  tunnelUptime: Int
  """IP address of the WAN ISP"""
  tunnelRemoteIP: String
  """IP address, ISP, and geographical information related to the WAN ISP"""
  tunnelRemoteIPInfo: IPInfo
  type: String @deprecated(reason: "No longer supported")
  """
  data about the WAN link that is configured in the Socket Configuration window for the site
  """
  info: InterfaceInfo
  """Information about cellular (LTE) interface"""
  cellularInterfaceInfo: CellularInterface
}

type Metrics {
  """total amount of time for the site data"""
  duration: Int
  """duration in seconds for a single metrics bucket"""
  granularity: Int
  """total downstream traffic (from the Cato Cloud to the site)"""
  bytesDownstream: Float
  """total upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstream: Float
  """total traffic for the site"""
  bytesTotal: Float
  """number of packets lost for downstream traffic"""
  lostDownstream: Float
  """percent of packet loss for downstream traffic"""
  lostDownstreamPcnt: Float
  """number of packets lost for upstream traffic"""
  lostUpstream: Float
  """percent of packet loss for upstream traffic"""
  lostUpstreamPcnt: Float
  """total downstream packets"""
  packetsDownstream: Float
  """total upstream packets"""
  packetsUpstream: Float
  """
  jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterUpstream: Float
  """
  jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterDownstream: Float
  """total packets discarded for downstream traffic"""
  packetsDiscardedDownstream: Float
  """total packets discarded for upstream traffic"""
  packetsDiscardedUpstream: Float
  """round-trip time from the site to the Cato Cloud"""
  rtt: Int
  """
  The number of hosts in the tunnel. Relevant only for per site Metrics, ignored in per-interface metrics.
  """
  hostCount: Float
  """
  The configurable limit of the number of hosts in the tunnel. Relevant only for per site Metrics, ignored in
  per-interface metrics.
  """
  hostLimit: Float
  """
  The number of flows (connections) in the tunnel. Relevant only for per site Metrics, ignored in per-interface
  metrics.
  """
  flowCount: Float
}

type CellularInterface {
  """2G, 3G, or 4G"""
  networkType: CellularNetworkType
  """
  Shows the currently active SIM slot; the other slot is in standby. Slot 1 is active by default.
  """
  simSlotId: Int
  """
  Represents the current status of the modem. Valid values are Error, OK, or Unknown.
  """
  modemStatus: CellularModemStatus
  """
  Indicates if the cellular modem is currently connected to the internet.
  """
  isModemConnected: Boolean!
  """Unique identifier (20-digit number) for the modem."""
  iccid: String
  """Unique identifier (15-digit number) for a specific SIM."""
  imei: String
  """Displays the operator or carrier name, such as Verizon."""
  operatorName: String
  """Indicates if the modem is currently suspended."""
  isModemSuspended: Boolean!
  """
  Represents the Access Point Name (e.g., uwap.orange.co.il). Configurable from Socket WebUI or SIM switch.
  """
  apn: String
  """
  Determines how the APN is selected. Valid values are Auto or Manual (configurable in WebUI).
  """
  apnSelectionMethod: ApnMethod
  """
  Represents the signal strength of the cellular connection, in units of calculation.
  """
  signalStrength: String
  """Indicates whether roaming is enabled."""
  isRoamingAllowed: Boolean!
  """The phone number associated with the SIM."""
  simNumber: String
  """
  Displays the reason for the modem disconnecting. Valid values are 0 (No reason provided) or 1 (The session timed out).
  """
  disconnectionReason: CellularDisconnectionReason
  """Indicates whether a SIM is detected in the first slot."""
  isSimSlot1Detected: Boolean!
  """Indicates whether a SIM is detected in the second slot."""
  isSimSlot2Detected: Boolean!
}

enum CellularNetworkType {
  TYPE_UNKNOWN
  TYPE_2G
  TYPE_3G
  TYPE_4G
}

enum CellularModemStatus {
  STATUS_UNKNOWN
  STATUS_OK
  STATUS_ERROR
}

enum CellularDisconnectionReason {
  REASON_NONE
  REASON_TIMEOUT
}

enum ApnMethod {
  METHOD_UNKNOWN
  METHOD_AUTO
  METHOD_MANUAL
}

type SiteMetrics {
  """Site ID"""
  id: ID
  """Analytics that are returned for the links for a site"""
  interfaces: [InterfaceMetrics!]
  """Traffic metrics and data for sites"""
  metrics(
    "Normalize collected metrics as per-second values"
    toRate: Boolean = false
  ): Metrics
  """Site names"""
  name: String
  """
  Shows general information about the site (array with nested fields). Applicable only for site
  """
  info: SiteInfo
  """
  Timeseries with the number of hosts in the site. Applicable only for site
  """
  hostCount: Timeseries
  """
  Timeseries with the number of flows (connections) in the site. Applicable only for site
  """
  flowCount: Timeseries
  """
  Timeseries with the configurable limit of the number of hosts in the site. Applicable only for site
  """
  hostLimit: Timeseries
  samples: Int @deprecated(reason: "internal use")
}

enum HaReadiness {
  ready
  not_ready
}

enum HaSubStatus {
  ok
  fail
}

enum ConnectivityStatus {
  """Connected to the Cato Cloud"""
  connected
  """Disconnected from the Cato Cloud"""
  disconnected
}

enum OperationalStatus {
  """Passing traffic"""
  active
  """Disabled in the Cato Management Application"""
  disabled
  """License has expired for this site and you can't configure it"""
  locked
  """After you create the site before it is connected to the Cato Cloud"""
  new
  "For VPN users only"
  pending_user_configuration
  "For VPN users only"
  pending_mfa_configuration
  "For VPN users only"
  pending_code_generation
}

type UserSnapshot {
  """VPN user ID"""
  id: ID
  """Connectivity to the Cato Cloud"""
  connectivityStatus: ConnectivityStatus
  """Status for a site or VPN user"""
  operationalStatus: OperationalStatus
  "User name from configuration, same as info.name"
  name: String
  "The host name of the device"
  deviceName: String
  "How long has the user been connected (in seconds)"
  uptime: Int
  "Last time the user was connected (relevant if not currently connected)"
  lastConnected: DateTime
  "VPN client version string"
  version: String
  "VPN client version number"
  versionNumber: Int
  """ID of the PoP that the Client is connected to"""
  popID: Int
  """Name of the PoP that the VPN user is connected to"""
  popName: String
  """IP address of the Client"""
  remoteIP: String
  """IP address, ISP, and geographical information related to the Client"""
  remoteIPInfo: IPInfo
  """IP address of the PoP that the Client is connected to"""
  internalIP: String
  """Operating system of the device the Client is running on"""
  osType: String
  """Version of the operating system for the device"""
  osVersion: String
  """Data related to the Client"""
  devices: [DeviceSnapshot!]
  """
  In this state the client does not create its own connection, but reuses
  the Office's socket connection
  """
  connectedInOffice: Boolean
  """General information about the VPN user"""
  info: UserInfo
  """Data related to the most recent completed VPN connections"""
  recentConnections: [RecentConnection!]
}

type SiteSnapshot {
  """site ID"""
  id: ID
  protoId: Int
  """Connectivity to the Cato Cloud"""
  connectivityStatus: ConnectivityStatus
  """Site HA readiness information"""
  haStatus: HaStatus
  """Status for a site or VPN user"""
  operationalStatus: OperationalStatus
  """
  Relevant when the site is disconnected - the last time the device was connected
  """
  lastConnected: DateTime
  """For connected sites, since when are they connected"""
  connectedSince: DateTime
  """Name of the PoP that the site is connected to"""
  popName: String
  """Data related to the Sockets for a site"""
  devices: [DeviceSnapshot!]
  """General real-time information about the site"""
  info: SiteInfo
  """Number of hosts connected to a site"""
  hostCount: Int
  """Alternative WAN connectivity status"""
  altWanStatus: String
}

type Timeseries {
  """
  Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
  milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
  """
  data(
    "whether to normalize the data into per second (i.e. divide by granularity)"
    perSecond: Boolean = true
    "If false, the data field will be set to '0' for buckets with no reported data. Otherwise it will be set to -1"
    withMissingData: Boolean = false
  ): [[Float!]]
  "Indicates the type of the timeseries"
  label: String!
  "List of dimension values for this timeseries"
  dimensions: [DimensionData!]
  "Timeseries key: measure and dimension values"
  key: TimeseriesKey
  """Summary of the metrics over the given time frame"""
  sum: Float
  """
  Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
  of data to make sense.
  """
  units: UnitType
  """
  Specific information about the timeseries, used to build its name, title etc
  """
  info: [String!]
}

"""An object for marking specific events in time."""
type TimeAnnotation {
  """Timestamp of the event"""
  time: Float!
  """Description of the event"""
  label: String!
  """Brief description of the event"""
  shortLabel: String!
  """
  Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
  charts to attach to it.
  """
  type: AnnotationType!
}

"""An object for marking durations!"""
type TimePeriod {
  """
  An tuple of two numbers representing  start time, end time in ms since epoch, start bucket index, end bucket index
  """
  duration: [Float!]!
  """Label that describes the metrics"""
  title: String!
  """
  Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
  charts to attach to it.
  """
  type: PeriodType!
}

enum TimeseriesMetricType {
  """Total avg upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstream
  """Total avg downstream traffic (from the Cato Cloud to the site)"""
  bytesDownstream
  """Total max upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstreamMax
  """Total max downstream traffic (from the site to the Cato Cloud)"""
  bytesDownstreamMax
  """Total upstream packets"""
  packetsUpstream
  """Total downstream packets"""
  packetsDownstream
  """Number of packets lost for upstream traffic"""
  lostUpstream
  """Number of packets lost for downstream traffic"""
  lostDownstream
  """Percent of packet loss for upstream traffic"""
  lostUpstreamPcnt
  """Percent of packet loss for downstream traffic"""
  lostDownstreamPcnt
  """Total packets discarded for downstream traffic"""
  packetsDiscardedDownstream
  """Total packets discarded for upstream traffic"""
  packetsDiscardedUpstream
  """Percent packets discarded for upstream traffic"""
  packetsDiscardedUpstreamPcnt
  """Percent packets discarded for downstream traffic"""
  packetsDiscardedDownstreamPcnt
  """
  Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterUpstream
  """
  Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterDownstream
  """Total number of bytes of upstream and downstream traffic"""
  bytesTotal
  """Round-trip time from the Socket to the Cato Cloud"""
  rtt
  """Health analytics for the site"""
  health @deprecated(reason: "No longer supported")
  "The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)"
  tunnelAge
  """
  Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMilePacketLoss
  """
  Latency from socket directly to a well known global service, not through Cato. This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMileLatency
}

enum PeriodType {
  "packet loss connectivity issue"
  packetLoss
  "missing data"
  missingData
  "interface in standby mode"
  passiveLink
  "traffic was seen"
  active
  "some packets were queued"
  overlowed
  "some packets were discarded after queue timeout"
  congested
  "multiple last mile destinations measured packet loss"
  lastmilePacketLoss
  "multiple last mile destinations measured large latency (greater than 500ms)"
  lastmileLatency
  "unspecified period type"
  generic
  "period connected to specific pop instance"
  pop
}

enum AnnotationType {
  """The site connects to a different PoP"""
  popChange
  """Change for HA status role"""
  roleChange
  """The ISP IP address (remote IP) changed"""
  remoteIPChange
  """Other events that are included in annotations"""
  generic
}

type DimensionData {
  "Type of the dimension"
  label: String!
  "String value of the dimension"
  value: String
}

type TimeseriesKey {
  "Measure field"
  measureFieldName: String!
  "List of dimension key-value pair for this timeseries key"
  dimensions: [DimensionKey!]
}

type DimensionKey {
  "Dimension field"
  fieldName: String!
  "String value of the dimension"
  value: String
}

enum ConnectionOriginEnum {
  ANY
  REMOTE
  SITE
}

"Define settings for the Internet Firewall policy"
interface IPolicy {
  "TRUE = Policy is enabled, FALSE = Policy is disabled"
  enabled: Boolean!
  "Return list of rules in the policy"
  rules: [IPolicyRulePayload!]!
  "Return sections in the policy"
  sections: [PolicySectionPayload!]!
  "Audit data for the policy"
  audit: PolicyAudit
  "Return data for the Policy revision"
  revision: PolicyRevision
}

"Results of policy change"
interface IPolicyMutationPayload {
  "Data for the policy"
  policy: IPolicy
  "Enum for the status of the policy change"
  status: PolicyMutationStatus!
  "List of errors related to the policy change"
  errors: [PolicyMutationError!]!
}

interface IPolicyRule {
  "Rule ID"
  id: ID!
  "Name of the rule"
  name: String!
  "Description for the rule"
  description: String
  "Position / priority of rule"
  index: Int!
  "TRUE = Rule is enabled, FALSE = Rule is disabled"
  enabled: Boolean!
  "Policy section where the rule is located"
  section: PolicySectionInfo
}

"Results of rule change"
interface IPolicyRuleMutationPayload {
  "Returns settings for the rule"
  rule: IPolicyRulePayload
  "Enum for the status of the policy change"
  status: PolicyMutationStatus!
  "List of errors related to the policy change"
  errors: [PolicyMutationError!]!
}

"Results of changes to the rule"
interface IPolicyRulePayload {
  audit: PolicyElementAudit!
  "Rule that was changed"
  rule: IPolicyRule!
  "Summary of rule change, (ie. ADDED, UPDATED)"
  properties: [PolicyElementPropertiesEnum!]!
}

"The action applied by the Internet Firewall if the rule is matched"
enum InternetFirewallActionEnum {
  "Deny the network traffic from passing through the firewall."
  BLOCK
  "Allow the network traffic to pass through the firewall."
  ALLOW
  "Requests user confirmation to allow or block network traffic."
  PROMPT
  "Apply Remote Browser Isolation (RBI) to the network traffic"
  RBI
}

input InternetFirewallAddRuleDataInput {
  enabled: Boolean!
  name: String!
  description: String! = ""
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSourceInput! = {ip: [], host: [], site: [], subnet: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum! = ANY
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]! = []
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]! = []
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]! = []
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestinationInput! = {application: [], customApp: [], appCategory: [], customCategory: [], sanctionedAppsCategory: [], country: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: [], remoteAsn: [], container: []}
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceTypeInput! = {standard: [], custom: []}
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum! = BLOCK
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingInput! = {event: {enabled: false}, alert: {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}}
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleInput! = {activeOn: ALWAYS}
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleExceptionInput!]! = []
}

"Rule parameters and relevant position"
input InternetFirewallAddRuleInput {
  "Parameters for the rule you are adding"
  rule: InternetFirewallAddRuleDataInput!
  "Position of the rule in the policy"
  at: PolicyRulePositionInput
}

"Destination match criteria set"
type InternetFirewallDestination {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRef!]!
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRef!]!
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRef!]!
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRef!]!
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  "Countries"
  country: [CountryRef!]!
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]!
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]!
  "IPv4 addresses"
  ip: [IPAddress!]!
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]!
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRange!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]!
  container: [ContainerRef!]!
}

"Destination match criteria set"
input InternetFirewallDestinationInput {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]! = []
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]! = []
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]! = []
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]! = []
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  "Countries"
  country: [CountryRefInput!]! = []
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]! = []
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]! = []
  "IPv4 addresses"
  ip: [IPAddress!]! = []
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]! = []
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]! = []
  container: [ContainerRefInput!]! = []
}

"Destination match criteria set"
input InternetFirewallDestinationUpdateInput {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  "Countries"
  country: [CountryRefInput!]
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]
  "IPv4 addresses"
  ip: [IPAddress!]
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]
  container: [ContainerRefInput!]
}

type InternetFirewallPolicy implements IPolicy {
  enabled: Boolean!
  rules: [InternetFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
  audit: PolicyAudit
  revision: PolicyRevision
}

input InternetFirewallPolicyInput {
  """
  A revision is a specific instance of the policy.
   Unpublished revisions are working copies of the policy available to a specific
   admin or a set of admins
   Published revisions are revisions that were applied to the account network.
   The last published revision is the active policy.
  """
  revision: PolicyRevisionInput
}

input InternetFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

"Internet Firewall policy information provided in the API response"
type InternetFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  policy: InternetFirewallPolicy
  status: PolicyMutationStatus!
  errors: [PolicyMutationError!]!
}

"The Internet firewall Policy information returned to the caller in the API response."
type InternetFirewallPolicyMutations {
  "Add a new rule to the Internet Firewall policy."
  addRule(input: InternetFirewallAddRuleInput!): InternetFirewallRuleMutationPayload!
  "Update an existing rule of the Internet Firewall policy."
  updateRule(input: InternetFirewallUpdateRuleInput!): InternetFirewallRuleMutationPayload!
  "Remove an existing rule from the Internet Firewall policy."
  removeRule(input: InternetFirewallRemoveRuleInput!): InternetFirewallRuleMutationPayload!
  "Change the relative location of an existing rule within the Internet Firewall policy."
  moveRule(input: PolicyMoveRuleInput!): InternetFirewallRuleMutationPayload!
  """
  Add a new section to the policy.
  First section behaves as follows:
  When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
  The first section containing the default system rules can be modified but not deleted.
  The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
  """
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload!
  "Update policy section attributes"
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload!
  "Delete an existing section. The first section in policy cannot be deleted."
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload!
  """
  Move a section to a new position within the policy.
   The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
  """
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload!
  "Create the policy revision. Create a new empty policy revision."
  createPolicyRevision(input: PolicyCreateRevisionInput!): InternetFirewallPolicyMutationPayload!
  "Publish the policy revision. A published revision becomes the active policy, and its content is merged with all unpublished revisions for other admins."
  publishPolicyRevision(input: PolicyPublishRevisionInput): InternetFirewallPolicyMutationPayload!
  "Discard the policy revision. All changes in this discarded revision are discarded, and the revision is deleted."
  discardPolicyRevision(input: PolicyDiscardRevisionInput): InternetFirewallPolicyMutationPayload!
  """
  Change the state of the policy, e.g. enable or disable the policy.
  Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
  """
  updatePolicy(input: InternetFirewallPolicyUpdateInput!): InternetFirewallPolicyMutationPayload!
}

type InternetFirewallPolicyQueries {
  policy(input: InternetFirewallPolicyInput): InternetFirewallPolicy!
  revisions: PolicyRevisionsPayload
}

input InternetFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input InternetFirewallRemoveRuleInput {
  id: ID!
}

type InternetFirewallRule implements IPolicyRule {
  "Rule ID"
  id: ID!
  "Name of the rule"
  name: String!
  "Description for the rule"
  description: String!
  "Position / priority of rule"
  index: Int!
  "Policy section where the rule is located"
  section: PolicySectionInfo!
  """
  TRUE = Rule is enabled 
   FALSE = Rule is disabled
  """
  enabled: Boolean!
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSource!
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum!
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRef!]!
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRef!]!
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]!
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestination!
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceType!
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum!
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTracking!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicySchedule!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleException!]!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
type InternetFirewallRuleException {
  "A unique name of the rule exception."
  name: String!
  "Source traffic matching criteria for the exception."
  source: InternetFirewallSource!
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]!
  "Source country matching criteria for the exception."
  country: [CountryRef!]!
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRef!]!
  "Destination matching criteria for the exception."
  destination: InternetFirewallDestination!
  "Destination service matching criteria for the exception."
  service: InternetFirewallServiceType!
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
input InternetFirewallRuleExceptionInput {
  "A unique name of the rule exception."
  name: String!
  "Source traffic matching criteria for the exception."
  source: InternetFirewallSourceInput! = {ip: [], host: [], site: [], subnet: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]! = []
  "Source country matching criteria for the exception."
  country: [CountryRefInput!]! = []
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRefInput!]! = []
  "Destination matching criteria for the exception."
  destination: InternetFirewallDestinationInput! = {application: [], customApp: [], appCategory: [], customCategory: [], sanctionedAppsCategory: [], country: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: [], remoteAsn: [], container: []}
  "Destination service matching criteria for the exception."
  service: InternetFirewallServiceTypeInput! = {standard: [], custom: []}
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum! = ANY
}

type InternetFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  rule: InternetFirewallRulePayload
  status: PolicyMutationStatus!
  errors: [PolicyMutationError!]!
}

"Internet Firewall policy information for a specific revision"
type InternetFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  rule: InternetFirewallRule!
  properties: [PolicyElementPropertiesEnum!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
type InternetFirewallServiceType {
  standard: [ServiceRef!]!
  custom: [CustomService!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
input InternetFirewallServiceTypeInput {
  standard: [ServiceRefInput!]! = []
  custom: [CustomServiceInput!]! = []
}

"Add the Service Type to which this Internet Firewall rule applies"
input InternetFirewallServiceTypeUpdateInput {
  standard: [ServiceRefInput!]
  custom: [CustomServiceInput!]
}

"Returns the settings for Source of an Internet Firewall rule"
type InternetFirewallSource {
  "IPv4 address"
  ip: [IPAddress!]!
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
}

"Input of the settings for Source of an Internet Firewall rule"
input InternetFirewallSourceInput {
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
}

"Input of the settings for Source of an Internet Firewall rule"
input InternetFirewallSourceUpdateInput {
  "IPv4 address"
  ip: [IPAddress!]
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
}

input InternetFirewallUpdateRuleDataInput {
  enabled: Boolean
  name: String
  description: String
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSourceUpdateInput
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestinationUpdateInput
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceTypeUpdateInput
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingUpdateInput
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleUpdateInput
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleExceptionInput!]
}

input InternetFirewallUpdateRuleInput {
  id: ID!
  rule: InternetFirewallUpdateRuleDataInput!
}

"Enum for the type of time range a rule is active"
enum PolicyActiveOnEnum {
  ALWAYS
  WORKING_HOURS
  CUSTOM_TIMEFRAME
  CUSTOM_RECURRING
}

"Input for adding section info to a policy"
input PolicyAddSectionInfoInput {
  name: String!
}

"Input for adding a section to a policy"
input PolicyAddSectionInput {
  section: PolicyAddSectionInfoInput!
  at: PolicySectionPositionInput!
}

type PolicyAudit {
  publishedTime: DateTime!
  publishedBy: String!
}

input PolicyCreateRevisionInput {
  name: String!
  description: String! = ""
}

"Returns data for a custom recurring time range that a rule is active"
type PolicyCustomRecurring {
  from: Time!
  to: Time!
  days: [DayOfWeek!]!
}

"Input of data for a custom recurring time range that a rule is active"
input PolicyCustomRecurringInput {
  from: Time!
  to: Time!
  days: [DayOfWeek!]! = []
}

"Input of data for a custom recurring time range that a rule is active"
input PolicyCustomRecurringUpdateInput {
  from: Time
  to: Time
  days: [DayOfWeek!]
}

"Returns data for a custom one-time time range that a rule is active"
type PolicyCustomTimeframe {
  from: DateTime!
  to: DateTime!
}

"Input of data for a custom one-time time range that a rule is active"
input PolicyCustomTimeframeInput {
  from: DateTime!
  to: DateTime!
}

"Input of data for a custom one-time time range that a rule is active"
input PolicyCustomTimeframeUpdateInput {
  from: DateTime
  to: DateTime
}

"Discards unpublished revision for the policy and reverts to the settings for the published policy."
input PolicyDiscardRevisionInput {
  id: ID
}

type PolicyElementAudit {
  "The last date and time the rule was updated"
  updatedTime: DateTime!
  "The admin, or the API-key, that performed the last update"
  updatedBy: String!
}

"Attributes describing the rule state or type"
enum PolicyElementPropertiesEnum {
  "New (added) rule"
  ADDED
  "Updated (modified) existing rule"
  UPDATED
  "Removed (deleted) rule"
  REMOVED
  "A rule moved to a different position"
  MOVED
  "A rule locked for changes by other admins"
  LOCKED
  """
  An object can not be moved, or referenced when moving other objects.
  However its properties and content can be modified.
  """
  ANCHORED
  "A pre-defined (system) rule that cannot be modified or removed"
  SYSTEM
}

"Move the rule to a different position in the policy"
input PolicyMoveRuleInput {
  id: ID!
  to: PolicyRulePositionInput
}

"Input for moving a section within a policy"
input PolicyMoveSectionInput {
  id: ID!
  to: PolicySectionPositionInput
}

"""
The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.

## Policy Errors

### `ConcurrentPolicyPublish`
- **Error Message:** "Another policy is currently publishing"

### `PolicyRevisionMismatch`
- **Error Message:** "Revision is not owned by the admin"

### `PolicyRevisionNotFound`
- **Error Message:** "Revision was not found"

### `PolicyInvalidEntity`
- **Error Message:** "Invalid entity"

### `DuplicateRuleName`
- **Error Message:** "Rule with the same name already exists"

### `DuplicateSectionName`
- **Error Message:** "Section with the same name already exists"

### `PolicyFailure`
- **Error Message:** "Can’t publish policy due to an internal error. Please try again in a few minutes"


## Rule Errors

### `ruleIsLocked`
- **Error Message:** "Rule is locked by another revision"

### `ruleWasRemoved`
- **Error Message:** "Rule was already removed"

### `ruleNotExist`
- **Error Message:** "Rule does not exist"

### `ruleSectionNotExist`
- **Error Message:** "Section does not exist"

### `ruleSectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `rulePositionInvalid`
- **Error Message:** "Rule position is invalid"

### `ruleNameIsEmpty`
- **Error Message:** "Rule name can't be empty"

### `ruleNameAlreadyExists`
- **Error Message:** "Rule with the same name already exists"

### `ruleSystemModification`
- **Error Message:** "Can't modify a system rule"

### `ruleSystemMove`
- **Error Message:** "Can't add a rule above the system rules"

### `ruleHasInvalidEntity`
- **Error Message:** "Rule has an invalid entity"

### `failedValidatingRule`
- **Error Message:** "Something went wrong, couldn't validate rule"


## Section Errors

### `sectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `sectionSystemMove`
- **Error Message:** "Section with system rules cannot be moved or removed"

### `sectionNotExist`
- **Error Message:** "Section does not exist"

### `sectionPositionInvalid`
- **Error Message:** "Section position is invalid"
"""
type PolicyMutationError {
  errorMessage: String
  errorCode: String
}

input PolicyMutationRevisionInput {
  id: ID
}

"Enum for the status of a policy mutation"
enum PolicyMutationStatus {
  SUCCESS
  FAILURE
}

"Policies that can be configured with mutation APIs."
type PolicyMutations {
  internetFirewall(input: InternetFirewallPolicyMutationInput): InternetFirewallPolicyMutations
  wanFirewall(input: WanFirewallPolicyMutationInput): WanFirewallPolicyMutations
}

"""
Published revision is the active policy
applied on the traffic.
In addition, when a policy is published, revision changes become visible
to other admins, and rules locked by the revision become unlocked
"""
input PolicyPublishRevisionInput {
  name: String
  description: String
}

"policies which configuration can be read with query APIs."
type PolicyQueries {
  internetFirewall: InternetFirewallPolicyQueries
  wanFirewall: WanFirewallPolicyQueries
}

"Input for removing a section from a policy"
input PolicyRemoveSectionInput {
  id: ID!
}

"Returns data about the policy revision, such as when the change was made, how many rules were changed, etc."
type PolicyRevision {
  id: ID!
  name: String!
  description: String!
  changes: Int!
  createdTime: DateTime!
  updatedTime: DateTime!
}

"Input for specifying a policy revision"
input PolicyRevisionInput {
  type: PolicyRevisionType = PRIVATE
  id: ID
}

"Enum for the type of a policy revision"
enum PolicyRevisionType {
  PRIVATE
  PUBLIC
}

"Returns data for publishing the policy"
type PolicyRevisionsPayload {
  revision: [PolicyRevision!]!
}

"Enum for the position of a rule within a policy"
enum PolicyRulePositionEnum {
  "The rule position is after the pre-existing specified rule"
  AFTER_RULE
  "The rule position is before the pre-existing specified rule"
  BEFORE_RULE
  "The rule position is first in the specified section"
  FIRST_IN_SECTION
  "The rule position is last in the specified section"
  LAST_IN_SECTION
  "The rule position is immediately after the system rules (first non-system rule)"
  FIRST_IN_POLICY
  "The rule position is last in the policy"
  LAST_IN_POLICY
}

"Parameters required to define the rule position"
input PolicyRulePositionInput {
  "Position relative to a policy, a section or another rule"
  position: PolicyRulePositionEnum
  "The identifier of the object (e.g. a rule, a section) relative to which the position of the added rule is defined"
  ref: ID
}

"Returns data for the alert settings for the rule"
type PolicyRuleTrackingAlert {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean!
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum!
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRef!]!
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRef!]!
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRef!]!
}

"Input of data for the alert settings for the rule"
input PolicyRuleTrackingAlertInput {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean! = false
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum! = HOURLY
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRefInput!]! = []
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRefInput!]! = []
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRefInput!]! = []
}

"Input of data for the alert settings for the rule"
input PolicyRuleTrackingAlertUpdateInput {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRefInput!]
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRefInput!]
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRefInput!]
}

"Returns data if an alert is sent for a rule"
type PolicyRuleTrackingEvent {
  enabled: Boolean!
}

"Input of data if an alert is sent for a rule"
input PolicyRuleTrackingEventInput {
  enabled: Boolean! = false
}

"Input of data if an alert is sent for a rule"
input PolicyRuleTrackingEventUpdateInput {
  enabled: Boolean
}

"Enum for the frequency of an alert event for a rule"
enum PolicyRuleTrackingFrequencyEnum {
  HOURLY
  DAILY
  WEEKLY
  IMMEDIATE
}

type PolicySchedule {
  activeOn: PolicyActiveOnEnum!
  customTimeframe: PolicyCustomTimeframe
  customRecurring: PolicyCustomRecurring
}

input PolicyScheduleInput {
  activeOn: PolicyActiveOnEnum! = ALWAYS
  customTimeframe: PolicyCustomTimeframeInput
  customRecurring: PolicyCustomRecurringInput
}

input PolicyScheduleUpdateInput {
  activeOn: PolicyActiveOnEnum
  customTimeframe: PolicyCustomTimeframeUpdateInput
  customRecurring: PolicyCustomRecurringUpdateInput
}

"Define settings for a policy section"
type PolicySectionInfo {
  id: ID!
  name: String!
}

type PolicySectionMutationPayload {
  section: PolicySectionPayload
  status: PolicyMutationStatus!
  errors: [PolicyMutationError!]!
}

type PolicySectionPayload {
  audit: PolicyElementAudit!
  section: PolicySectionInfo!
  properties: [PolicyElementPropertiesEnum!]!
}

enum PolicySectionPositionEnum {
  AFTER_SECTION
  BEFORE_SECTION
  LAST_IN_POLICY
}

input PolicySectionPositionInput {
  position: PolicySectionPositionEnum!
  ref: ID
}

"Enum for the state of a policy"
enum PolicyToggleState {
  ENABLED
  DISABLED
}

type PolicyTracking {
  event: PolicyRuleTrackingEvent!
  alert: PolicyRuleTrackingAlert!
}

input PolicyTrackingInput {
  event: PolicyRuleTrackingEventInput! = {enabled: false}
  alert: PolicyRuleTrackingAlertInput! = {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}
}

input PolicyTrackingUpdateInput {
  event: PolicyRuleTrackingEventUpdateInput
  alert: PolicyRuleTrackingAlertUpdateInput
}

input PolicyUpdateSectionInfoInput {
  name: String
}

input PolicyUpdateSectionInput {
  id: ID!
  section: PolicyUpdateSectionInfoInput!
}

enum WanFirewallActionEnum {
  "Deny the network traffic from passing through the firewall."
  BLOCK
  "Allow the network traffic to pass through the firewall."
  ALLOW
  "Requests user confirmation to allow or block network traffic."
  PROMPT
}

input WanFirewallAddRuleDataInput {
  enabled: Boolean!
  name: String!
  description: String! = ""
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSourceInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum! = ANY
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]! = []
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]! = []
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]! = []
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestinationInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplicationInput! = {application: [], appCategory: [], customApp: [], customCategory: [], sanctionedAppsCategory: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: []}
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceTypeInput! = {standard: [], custom: []}
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum! = BLOCK
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingInput! = {event: {enabled: false}, alert: {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}}
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleInput! = {activeOn: ALWAYS}
  direction: WanFirewallDirectionEnum! = TO
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleExceptionInput!]! = []
}

"Rule parameters and relevant position"
input WanFirewallAddRuleInput {
  "Parameters for the rule you are adding"
  rule: WanFirewallAddRuleDataInput!
  "Position of the rule in the policy"
  at: PolicyRulePositionInput
}

"Application match criteria set"
type WanFirewallApplication {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRef!]!
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRef!]!
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRef!]!
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRef!]!
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]!
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]!
  "IPv4 addresses"
  ip: [IPAddress!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRange!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
}

"Application match criteria set"
input WanFirewallApplicationInput {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]! = []
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]! = []
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]! = []
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]! = []
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]! = []
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]! = []
  "IPv4 addresses"
  ip: [IPAddress!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
}

"Application match criteria set"
input WanFirewallApplicationUpdateInput {
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]
  "IPv4 addresses"
  ip: [IPAddress!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
}

"Returns the settings for Destination of a Wan Firewall rule"
type WanFirewallDestination {
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "IPv4 address"
  ip: [IPAddress!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
}

"Input of the settings for Destination of a Wan Firewall rule"
input WanFirewallDestinationInput {
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
}

"Input of the settings for Destination of a Wan Firewall rule"
input WanFirewallDestinationUpdateInput {
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "IPv4 address"
  ip: [IPAddress!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
}

enum WanFirewallDirectionEnum {
  TO
  BOTH
}

type WanFirewallPolicy implements IPolicy {
  enabled: Boolean!
  rules: [WanFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
  audit: PolicyAudit
  revision: PolicyRevision
}

input WanFirewallPolicyInput {
  """
  A revision is a specific instance of the policy.
   Unpublished revisions are working copies of the policy available to a specific
   admin or a set of admins
   Published revisions are revisions that were applied to the account network.
   The last published revision is the active policy.
  """
  revision: PolicyRevisionInput
}

input WanFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

"Wan Firewall policy information provided in the API response"
type WanFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  policy: WanFirewallPolicy
  status: PolicyMutationStatus!
  errors: [PolicyMutationError!]!
}

"The Wan Firewall Policy information returned to the caller in the API response."
type WanFirewallPolicyMutations {
  "Add a new rule to the Wan Firewall policy."
  addRule(input: WanFirewallAddRuleInput!): WanFirewallRuleMutationPayload!
  "Update an existing rule of the Wan Firewall policy."
  updateRule(input: WanFirewallUpdateRuleInput!): WanFirewallRuleMutationPayload!
  "Remove an existing rule from the Wan Firewall policy."
  removeRule(input: WanFirewallRemoveRuleInput!): WanFirewallRuleMutationPayload!
  "Change the relative location of an existing rule within the Wan Firewall policy."
  moveRule(input: PolicyMoveRuleInput!): WanFirewallRuleMutationPayload!
  """
  Add a new section to the policy.
  First section behaves as follows:
  When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
  The first section containing the default system rules can be modified but not deleted.
  The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
  """
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload!
  "Update policy section attributes"
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload!
  "Delete an existing section. The first section in policy cannot be deleted."
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload!
  """
  Move a section to a new position within the policy.
   The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
  """
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload!
  createPolicyRevision(input: PolicyCreateRevisionInput!): WanFirewallPolicyMutationPayload!
  publishPolicyRevision(input: PolicyPublishRevisionInput): WanFirewallPolicyMutationPayload!
  discardPolicyRevision(input: PolicyDiscardRevisionInput): WanFirewallPolicyMutationPayload!
  """
  Change the state of the policy, e.g. enable or disable the policy.
  Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
  """
  updatePolicy(input: WanFirewallPolicyUpdateInput!): WanFirewallPolicyMutationPayload!
}

type WanFirewallPolicyQueries {
  policy(input: WanFirewallPolicyInput): WanFirewallPolicy!
  revisions: PolicyRevisionsPayload
}

input WanFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input WanFirewallRemoveRuleInput {
  id: ID!
}

type WanFirewallRule implements IPolicyRule {
  "Rule ID"
  id: ID!
  "Name of the rule"
  name: String!
  "Description for the rule"
  description: String!
  "Position / priority of rule"
  index: Int!
  "Policy section where the rule is located"
  section: PolicySectionInfo!
  """
  TRUE = Rule is enabled 
   FALSE = Rule is disabled
  """
  enabled: Boolean!
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSource!
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum!
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRef!]!
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRef!]!
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]!
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestination!
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplication!
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceType!
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum!
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTracking!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicySchedule!
  direction: WanFirewallDirectionEnum!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleException!]!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
type WanFirewallRuleException {
  "A unique name of the rule exception."
  name: String!
  "Source matching criteria for the exception."
  source: WanFirewallSource!
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]!
  "Destination matching criteria for the exception."
  destination: WanFirewallDestination!
  "Source country matching criteria for the exception."
  country: [CountryRef!]!
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRef!]!
  "Application matching criteria for the exception."
  application: WanFirewallApplication!
  "Destination service matching criteria for the exception."
  service: WanFirewallServiceType!
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum!
  "Direction origin matching criteria for the exception"
  direction: WanFirewallDirectionEnum!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
input WanFirewallRuleExceptionInput {
  "A unique name of the rule exception."
  name: String!
  "Source matching criteria for the exception."
  source: WanFirewallSourceInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]! = []
  "Destination matching criteria for the exception."
  destination: WanFirewallDestinationInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Source country matching criteria for the exception."
  country: [CountryRefInput!]! = []
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRefInput!]! = []
  "Application matching criteria for the exception."
  application: WanFirewallApplicationInput! = {application: [], appCategory: [], customApp: [], customCategory: [], sanctionedAppsCategory: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: []}
  "Destination service matching criteria for the exception."
  service: WanFirewallServiceTypeInput! = {standard: [], custom: []}
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum! = ANY
  "Direction origin matching criteria for the exception"
  direction: WanFirewallDirectionEnum! = TO
}

type WanFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  rule: WanFirewallRulePayload
  status: PolicyMutationStatus!
  errors: [PolicyMutationError!]!
}

"Wan Firewall policy information for a specific revision"
type WanFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  rule: WanFirewallRule!
  properties: [PolicyElementPropertiesEnum!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
type WanFirewallServiceType {
  standard: [ServiceRef!]!
  custom: [CustomService!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
input WanFirewallServiceTypeInput {
  standard: [ServiceRefInput!]! = []
  custom: [CustomServiceInput!]! = []
}

"Add the Service Type to which this Internet Firewall rule applies"
input WanFirewallServiceTypeUpdateInput {
  standard: [ServiceRefInput!]
  custom: [CustomServiceInput!]
}

"Returns the settings for Source of an Wan Firewall rule"
type WanFirewallSource {
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "IPv4 address"
  ip: [IPAddress!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
}

"Input of the settings for Source of an Wan Firewall rule"
input WanFirewallSourceInput {
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
}

"Input of the settings for Source of an Wan Firewall rule"
input WanFirewallSourceUpdateInput {
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "IPv4 address"
  ip: [IPAddress!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
}

input WanFirewallUpdateRuleDataInput {
  enabled: Boolean
  name: String
  description: String
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSourceUpdateInput
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestinationUpdateInput
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplicationUpdateInput
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceTypeUpdateInput
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingUpdateInput
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleUpdateInput
  direction: WanFirewallDirectionEnum
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleExceptionInput!]
}

input WanFirewallUpdateRuleInput {
  id: ID!
  rule: WanFirewallUpdateRuleDataInput!
}

scalar IPSubnet

"""A from-to range (used for DHCP range, for example)"""
scalar IPRange

"""A key value pairs object { "key1": "value1", "key2": "value2" }"""
scalar Map

"""
Enter the time frame for the data that the query returns.
The argument is in the format <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">\<type\>.\<time value\></span> This argument is mandatory.

These are the supported options to define the time frame:

last.\<time duration\> - The <time duration> value for the <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last</span> type is according to ISO-8601 and returns data
						for the previous specific times. For example:
<ul>
	<li>timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT5M</span> shows the previous 5 minutes</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT2H</span> shows the previous 2 hours</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1D</span> shows the previous 1 day</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P3M</span> shows the previous 3 months</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1Y</span> shows the previous 1 year</li>
</ul>

utc.\<short-time-frame-spec\>  - The time frame combines a start and end date in the format  YY-MM-DD/hh:mm:ss </br>
according to the specified time zone. </br> You must enter all the date and time values for the argument. For example:

<ul>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-{11/04:50:00--21/04:50:00}</span> shows 10 days of analytics data from February 11, 2020 4:50:00 am to February 21, 2020 4:50:00 am</li>
    <li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-11/{04:50:15--16:50:15}</span> shows 12 hours of analytics data on February 11, 2020, from 4:50:15 am to 16:50:15 pm</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-{02-11/04:50:00--04-11/04:50:00}</span> shows 2 months of analytics data from February 11, 2020 4:50:00 am to April 11 4:50:00 am</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.{2019-10-01/04:50:00--2020/02-01/04:50:00}</span> shows 4 months of analytics data from October 1, 2019 4:50:00 am to February 11 4:50:00 am</li>
</ul>

This format lets you configure a time frame the includes more than one calendar year
"""
scalar TimeFrame

enum UnitType {
  bytes
  packets
  bits
  ms
  percent
  """health analytics for the site"""
  score
  """The number of occurrences for this unit"""
  count
  """
  For metrics that are measured in seconds, such as tunnelAge, the number of seconds
  """
  seconds
  """Bits per second"""
  bps
  """Bytes per second"""
  bytesPerSec
  none
}

enum AggregationType {
  sum
  count
  count_distinct
  distinct
  avg
  max
  min
  any
  changes
  uniq_set
}

enum DirectionEnum {
  asc
  desc
}

enum FilterOperator {
  is
  is_not
  in
  not_in
  exists
  not_exists
  between
  not_between
  gt
  gte
  lt
  lte
}

type RBACRole {
  id: ID!
  name: String!
  description: String
  isPredefined: Boolean!
}

type AdminRole {
  role: RBACRole!
  allowedEntities: [Entity!]
  allowedAccounts: [ID!]
}

input AddSocketSiteInput {
  name: String!
  connectionType: SiteConnectionTypeEnum! = SOCKET_X1500
  siteType: SiteType! = BRANCH
  description: String
  nativeNetworkRange: IPSubnet!
  translatedSubnet: IPSubnet
  siteLocation: AddSiteLocationInput!
}

input AddSiteLocationInput {
  """country code"""
  countryCode: String!
  """optional state code"""
  stateCode: String
  """time zone"""
  timezone: String!
  """optional address"""
  address: String
  """city name, must belong to the country or country and state"""
  city: String
}

input UpdateSiteGeneralDetailsInput {
  name: String
  siteType: SiteType
  description: String
  siteLocation: UpdateSiteLocationInput
}

input UpdateSiteLocationInput {
  countryCode: String
  stateCode: String
  timezone: String
  address: String
}

input UpdateSocketInterfaceInput {
  destType: SocketInterfaceDestType!
  name: String
  """
  Only relevant for LAN, VRRP_AND_LAN, LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
  """
  lan: SocketInterfaceLanInput
  """Only relevant for CATO, ALTERNATIVE, LAYER_2_WAN"""
  bandwidth: SocketInterfaceBandwidthInput
  """Only relevant for CATO"""
  wan: SocketInterfaceWanInput
  """Only relevant for CATO"""
  offCloud: SocketInterfaceOffCloudInput
  """Only relevant for ALTERNATIVE, LAYER_2_WAN"""
  altWan: SocketInterfaceAltWanInput
  """Only relevant for LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP"""
  lag: SocketInterfaceLagInput
  """Only relevant for VRRP"""
  vrrp: SocketInterfaceVrrpInput
}

type UpdateSocketInterfacePayload {
  siteId: ID!
  socketInterfaceId: SocketInterfaceIDEnum!
}

input SocketInterfaceBandwidthInput {
  upstreamBandwidth: Int!
  downstreamBandwidth: Int!
}

input SocketInterfaceWanInput {
  role: SocketInterfaceRole!
  precedence: SocketInterfacePrecedenceEnum!
}

input SocketInterfaceLanInput {
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
  localIp: IPAddress!
}

input SocketInterfaceOffCloudInput {
  enabled: Boolean!
  publicIp: IPAddress
  publicStaticPort: Int
}

input SocketInterfaceAltWanInput {
  privateInterfaceIp: IPAddress!
  privateNetwork: IPSubnet!
  privateGatewayIp: IPAddress!
  privateVlanTag: Int
  publicInterfaceIp: IPAddress
  publicNetwork: IPSubnet
  publicGatewayIp: IPAddress
  publicVlanTag: Int
}

input SocketInterfaceLagInput {
  minLinks: Int!
}

input SocketInterfaceVrrpInput {
  vrrpType: VrrpType
}

input AddNetworkRangeInput {
  name: String!
  rangeType: SubnetType!
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
  """
  Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
  """
  localIp: IPAddress
  """Only relevant for ROUTED_ROUTE rangeType"""
  gateway: IPAddress
  """Only relevant for VLAN network rangeType"""
  vlan: Int
  """Only relevant for AZURE HA sites"""
  azureFloatingIp: IPAddress
  """Only relevant for NATIVE, VLAN rangeType"""
  dhcpSettings: NetworkDhcpSettingsInput
  """BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType"""
  mdnsReflector: Boolean
}

input UpdateNetworkRangeInput {
  name: String
  rangeType: SubnetType
  subnet: IPSubnet
  translatedSubnet: IPSubnet
  """
  Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
  """
  localIp: IPAddress
  """Only relevant for ROUTED_ROUTE rangeType"""
  gateway: IPAddress
  """Only relevant for VLAN network rangeType"""
  vlan: Int
  """Only relevant for AZURE HA sites"""
  azureFloatingIp: IPAddress
  """Only relevant for NATIVE, VLAN rangeType"""
  dhcpSettings: NetworkDhcpSettingsInput
  """BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType"""
  mdnsReflector: Boolean
}

input NetworkDhcpSettingsInput {
  dhcpType: DhcpType!
  ipRange: IPRange
  relayGroupId: ID
}

input UpdateHaInput {
  primaryManagementIp: IPAddress
  secondaryManagementIp: IPAddress
  vrid: Int
}

input AddStaticHostInput {
  name: String!
  ip: IPAddress!
  macAddress: String
}

input UpdateStaticHostInput {
  name: String
  ip: IPAddress
  macAddress: String
}

type RemoveSitePayload {
  siteId: ID!
}

type AddSocketSitePayload {
  siteId: ID!
}

type UpdateSiteGeneralDetailsPayload {
  siteId: ID!
}

type AddNetworkRangePayload {
  networkRangeId: ID!
}

type UpdateNetworkRangePayload {
  networkRangeId: ID!
}

type RemoveNetworkRangePayload {
  networkRangeId: ID!
}

type UpdateHaPayload {
  siteId: ID!
}

type AddStaticHostPayload {
  hostId: ID!
}

type UpdateStaticHostPayload {
  hostId: ID!
}

type RemoveStaticHostPayload {
  hostId: ID!
}

enum SocketInterfacePrecedenceEnum {
  ACTIVE
  PASSIVE
  LAST_RESORT
}

enum SiteConnectionTypeEnum {
  SOCKET_X1500
  SOCKET_X1600
  SOCKET_X1700
  SOCKET_ESX1500
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_X1600_LTE
}

type CatoEndpoint implements Endpoint & MergedIncident {
  """ID for the Endpoint Protection story"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  """enum that shows XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  enum for the Producer (specific XDR engine or service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """enum for the connection for this incident (ie. host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """"""
  queryName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """The ticket for this story"""
  ticket: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  TRUE indicates that the story is currently being researched by Security Analysts
  """
  research: Boolean
  """Site name related to the story"""
  siteName: String
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """Description of the threat"""
  description: String
  """
  Source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """Cato ID and name for the site"""
  site: SiteRef
  """Cato ID and name for the site"""
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  """Details for the EPP device (ie. device name, OS, MAC address)"""
  device: CatoEndpointDeviceDetails
  """Details for the threat detected by the EPP"""
  alerts: [CatoEndpointAlert!]!
}

enum CatoEndpointEngineType {
  Behavioral
  AntiMalware
}

type CatoEndpointDeviceDetails implements DeviceDetails {
  """Unique Cato ID for this story"""
  id: ID!
  """Name of the device"""
  deviceName: String
  """OS data (ie. type, build, version)"""
  osDetails: OsDetails
  """Data for one or more users logged in to the device"""
  loggedOnUsers: [EndpointUser!]!
  """MAC address of the device"""
  macAddress: String
}

type CatoEndpointUser implements EndpointUser {
  """ID for the user"""
  id: ID!
  """Username for the user whose activity generated the indication"""
  name: String!
}

type CatoEndpointAlert implements EndpointAlert {
  """Unique Cato ID for the Endpoint Protection story"""
  id: ID!
  """Title of the endpoint alert"""
  title: String
  """Description of the threat"""
  description: String
  """Name of threat detected on the device"""
  threatName: String
  """MITRE ATT&CK® technique for the threat"""
  mitreTechnique: [Mitre!]!
  """MITRE ATT&CK® sub-technique for the threat"""
  mitreSubTechnique: [Mitre!]!
  """Timestamp that the threat was detected and the alert generated"""
  createdDateTime: DateTime
  """Data for the remediation status of the alert"""
  resources: [CatoResource!]!
  """Unique Cato IDs for the activities related to the alert"""
  activities: [CatoActivity!]!
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """Enum for the EPP engine related to this story"""
  engineType: CatoEndpointEngineType
  """Enum for the remediation status of the EPP alert"""
  status: RemediationStatusEnum
  """EPP profile that is assigned to this device"""
  endpointProtectionProfile: String
}

interface CatoResource implements EndpointResource {
  """Unique Cato ID for this EPP resource"""
  id: ID!
  """Timestamp that the this resource was used"""
  createdDateTime: DateTime
  """Enum for the remediation status associated with this resource"""
  remediationStatus: RemediationStatusEnum
}

type CatoProcessResource implements ProcessResource & CatoResource & EndpointResource {
  """Unique Cato ID for this resource"""
  id: ID!
  """Timestamp that the this resource was used"""
  createdDateTime: DateTime
  """Enum for the remediation status associated with this resource"""
  remediationStatus: RemediationStatusEnum
  """ID for the process"""
  processId: Int!
  """CLI command related to this process"""
  processCommandLine: String
  """Details of the file related to this process"""
  imageFile: FileDetails
  """User account related to this process"""
  userAccount: EndpointUser
}

type CatoFileResource implements FileResource & CatoResource & EndpointResource {
  """Unique Cato ID for this file resource"""
  id: ID!
  """Timestamp that the this file resource was used"""
  createdDateTime: DateTime
  """Enum for the remediation status associated with this file resource"""
  remediationStatus: RemediationStatusEnum
  """Details of the file related to this resource"""
  fileDetails: FileDetails
  """Enum for the detection status of this file resource"""
  detectionStatus: DetectionStatusEnum
}

type CatoActivity implements Activity {
  """Unique Cato ID for this activity"""
  id: ID!
  """
  Unique Cato ID for the resource (process or file) involved in the alert
  """
  resourceId: ID!
  """
  Unique Cato ID for the preceding resource (process or file) in the alert
  """
  parentResourceId: ID!
}

interface Endpoint implements MergedIncident {
  """Unique Cato ID for the story"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  sourceIp: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  device: DeviceDetails
  alerts: [EndpointAlert!]!
}

interface EndpointAlert {
  id: ID!
  title: String
  description: String
  threatName: String
  mitreTechnique: [Mitre!]!
  mitreSubTechnique: [Mitre!]!
  createdDateTime: DateTime
  resources: [EndpointResource!]!
  activities: [Activity!]!
  criticality: Int
}

interface Activity {
  id: ID!
  resourceId: ID!
  parentResourceId: ID!
}

interface DeviceDetails {
  id: ID!
  deviceName: String
  osDetails: OsDetails
  loggedOnUsers: [EndpointUser!]!
}

type OsDetails {
  osType: String!
  osBuild: Int
  osVersion: String
}

interface EndpointUser {
  id: ID!
  name: String!
}

enum ResourceRoleEnum {
  CONTEXTUAL
  SCANNED
  SOURCE
  DESTINATION
  CREATED
  ADDED
  COMPROMISED
  EDITED
  ATTACKED
  ATTACKER
  COMMAND_AND_CONTROL
  LOADED
  SUSPICIOUS
  POLICY_VIOLATOR
}

enum RemediationStatusEnum {
  REMEDIATED
  PREVENTED
  BLOCKED
  NOT_FOUND
  SCAN_FAILED
  CLEAN
  DISINFECTED
  INFECTED
  SUSPICIOUS
  DELETED
  MOVED
  UNKNOWN
  DELETED_REBOOT
  PASSWORD_PROTECTED
  MOVED_REBOOT
  NOT_STARTED
  SUCCESS
  REBOOT_REQUIRED
  DISABLED
  DISINFECT_FAILED
}

enum DeviceHealthStatusEnum {
  ACTIVE
  INACTIVE
  IMPAIRED_COMMUNICATION
  NO_SENSOR_DATA
  NO_SENSOR_DATA_IMPAIRED_COMMUNICATION
}

enum DeviceAvStatusEnum {
  NOT_REPORTING
  DISABLED
  NOT_UPDATED
  UPDATED
}

interface EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
}

interface ProcessResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  processId: Int!
  processCommandLine: String
  imageFile: FileDetails
  userAccount: EndpointUser
}

interface FileResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  fileDetails: FileDetails
  detectionStatus: DetectionStatusEnum
}

interface RegistryResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  hive: String
  key: String
  value: String
  valueName: String
  valueType: String
}

type FileDetails {
  name: String
  path: String
  size: Int
  sha1: String
  sha256: String
  md5: String
  issuer: String
  signer: String
  publisher: String
}

enum DetectionStatusEnum {
  DETECTED
  BLOCKED
  PREVENTED
}

type XDR {
  """
  Define the paging, sort, and filter arguments to define the XDR stories that are returned in the query
  """
  stories(input: StoryInput!): StoriesData
  """
  Define either the story ID, or the incident ID and producer arguments, to query the specific XDR story
  """
  story(storyId: ID, producer: StoryProducerEnum, incidentId: ID): Story
}

enum StoryVerdictEnum {
  Suspicious
  Malicious
  Informational
  Benign
}

enum TargetType {
  ip
  url
  domain
  fqdn
}

input StoryInput {
  paging: PagingInput!
  sort: [StorySortInput!]
  filter: [StoryFilterInput!]!
}

input StorySortInput {
  fieldName: StorySortFieldName!
  order: SortDirectionEnum
}

enum StorySortFieldName {
  firstSignal
  updatedAt
  createdAt
  accountName
  severity
  riskScore
  criticality
  source
  status
  producer
  queryName
  sourceIp
  engineType
}

input StoryFilterInput {
  timeFrame: TimeFramePredicate!
  producer: StoryProducerPredicate
  status: StoryStatusPredicate
  criticality: IntPredicate
  source: StringPredicate
  severity: StorySeverityPredicate
  incidentId: StringPredicate
  ioa: StringPredicate
  accountId: AccountIdPredicate
  storyId: StoryIdPredicate
  queryName: StringPredicate
  verdict: StoryVerdictPredicate
  engineType: EngineTypePredicate
  vendor: VendorPredicate
  sourceIp: StringPredicate
  muted: BooleanPredicate
}

input StoryVerdictPredicate {
  in: [StoryVerdictEnum!]
  not_in: [StoryVerdictEnum!]
}

input TimeFramePredicate {
  time: TimeFrame!
  timeFrameModifier: TimeFrameModifier
}

enum TimeFrameModifier {
  StoryUpdate
  StoryCreate
  AnalystUpdate
}

input AccountIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input StoryIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input StorySeverityPredicate {
  in: [SeverityEnum!]
  not_in: [SeverityEnum!]
}

enum SeverityEnum {
  High
  Medium
  Low
}

input StoryProducerPredicate {
  in: [StoryProducerEnum!]
  not_in: [StoryProducerEnum!]
}

input StoryStatusPredicate {
  in: [StoryStatusEnum!]
  not_in: [StoryStatusEnum!]
}

input IntPredicate {
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  eq: Int
  in: [Int!]
  not_in: [Int!]
}

input StringPredicate {
  in: [String]
  not_in: [String]
  contains: String
}

input BooleanPredicate {
  is: String!
}

input EngineTypePredicate {
  in: [StoryEngineTypeEnum!]
  not_in: [StoryEngineTypeEnum!]
}

input VendorPredicate {
  in: [VendorEnum!]
  not_in: [VendorEnum!]
}

enum SortDirectionEnum {
  asc
  desc
}

type StoriesData {
  """
  Define the stories that are returned, similar to a page of stories in the Cato Management Application
  """
  paging: Paging!
  """Fields returned from the Story query"""
  items: [Story!]!
}

type Paging {
  """
  Based on the filter and sort parameters, the first story that is returned
  """
  from: Int!
  """
  Based on the filter and sort parameters, the number of stories returned after the from. For example, the argument {from: 10, limit: 10} returns stories 10-20.
  """
  limit: Int!
  """Total number of stories returned"""
  total: Int!
}

type Story {
  """Unique Cato ID for each story"""
  id: ID!
  """ID for your Cato account"""
  accountId: Int!
  """Name of analyst working on the story"""
  analystName: String
  """Email address of the analyst working on the story"""
  analystEmail: String
  """Name of the account in the Cato Management Application"""
  accountName: String
  """Timestamp when the story was most recently updated"""
  updatedAt: DateTime!
  """Timestamp when the story was created"""
  createdAt: DateTime!
  """
  URL for the playbook in the Knowledge Base to help troubleshoot the story
  """
  playbook: String
  """Summary of the story"""
  summary: String
  """
  Data related to the fields and incidents that were merged to create or update the story
  """
  incident: MergedIncident!
  """Data for the story timeline"""
  timeline: [TimelineItem!]!
}

enum StoryStatusEnum {
  Open
  Closed
  PendingMoreInfo
  PendingAnalysis
  Monitoring
  Reopen
}

type TimelineItem {
  """Timestamp the story was created"""
  createdAt: DateTime!
  """Description for the story in the timeline"""
  description: String!
  """Status of the timeline item"""
  context: String!
  """Enum for the type (ie. Diff, Action, Comment)"""
  type: TimelineTypeEnum!
  """Description for the story in the timeline"""
  descriptions: [String!]!
  """Enum for the timeline category (ie. Information, Warning, Error)"""
  category: TimelineItemCategoryEnum
  """Additional information about this timeline item"""
  additionalInfo: String
  """Data about the analyst for this timeline item (ie. name, email)"""
  analystInfo: AnalystInfo
}

type AnalystInfo {
  """Security analyst name"""
  name: String
  """Security analyst email address"""
  email: String
}

enum TimelineTypeEnum {
  Diff
  Action
  Comment
}

enum TimelineItemCategoryEnum {
  Information
  Warning
  Error
}

interface MergedIncident {
  """Unique Cato ID for each story"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
  
  For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """
  For Network stories - The site where the network issue is occurring
  
  For Security stories - IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """The ticket an analyst created for this story"""
  ticket: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  The value is TRUE when the story is currently being researched by Security Analysts
  """
  research: Boolean
  """Site name related to the story"""
  siteName: String
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """For Security stories, description of the threat"""
  description: String
  """
  The source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """Cato ID and name for the site"""
  site: SiteRef
  """Cato ID and name for the user"""
  user: UserRef
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
}

type AnalystFeedbackThreatType {
  name: String
  recommendedAction: String
  details: String
}

type AnalystFeedback {
  verdict: StoryVerdictEnum
  severity: SeverityEnum
  threatType: AnalystFeedbackThreatType
  threatClassification: String
  additionalInfo: String
}

interface Anomalies implements MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  sourceIp: String
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  direction: String
}

type AnomalyStats implements Anomalies & MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  sourceIp: String
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  srcSiteId: String
  os: String
  deviceName: String
  macAddress: String
  logonName: String
  clientClass: [String!]!
  drillDownFilter: [StoryDrillDownFilter!]
  breakdownField: String
  subjectType: String
  extra: [Extra!]
  gaussian: Gaussian
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  rules: [String!]
  timeSeries: [IncidentTimeseries!]
  targets: [IncidentTargetRep!]!
  direction: String
}

type AnomalyEvents implements Anomalies & MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  sourceIp: String
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  srcSiteId: String
  os: String
  deviceName: String
  macAddress: String
  logonName: String
  clientClass: [String!]!
  drillDownFilter: [StoryDrillDownFilter!]
  breakdownField: String
  subjectType: String
  extra: [Extra!]
  gaussian: Gaussian
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  rules: [String!]
  timeSeries: [IncidentTimeseries!]
  targets: [IncidentTargetRep!]!
  direction: String
}

type Metric {
  name: String!
  value: Float!
}

type Gaussian {
  std: Float
  ss: Float
  z_score: Float
  avg: Float
  n: Float
}

type Extra {
  name: String!
  type: String!
  value: String!
}

type MetricDetails {
  name: String!
  units: String!
}

type Threat implements MergedIncident {
  """Unique Cato ID for this threat"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """Timestamp for the first incident signal related to this story"""
  lastSignal: DateTime!
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """The ticket an analyst created for this story"""
  ticket: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  The value is TRUE when the story is currently being researched by Security Analysts
  """
  research: Boolean
  """Site name related to the story"""
  siteName: String
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """Description of the threat"""
  description: String
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """Cato ID and name for the site"""
  site: SiteRef
  """Cato ID and name for the user"""
  user: UserRef
  """Data for stories that are similar"""
  similarStoriesData: [SimilarStoryData!]!
  """Enum for Cato’s predicted verdict of the story (ie. Malicious, Benign)"""
  predictedVerdict: StoryVerdictEnum
  """Cato’s predicted threat type for the story"""
  predictedThreatType: String
  """Cato ID for the site that is the source of the threat"""
  srcSiteId: String
  """Cardinality of traffic flows for the threat"""
  flowsCardinality: Int
  """The estimated risk level of the threat (ie. Malicious, High, Low)"""
  riskLevel: RiskLevelEnum
  """OS for device or host that is the threat target"""
  os: String
  """Name of the device"""
  deviceName: String
  """MAC address of the device"""
  macAddress: String
  """
  The source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Username for the device"""
  logonName: String
  """Traffic direction for the threat"""
  direction: String
  """Client Class for the traffic flow"""
  clientClass: [String!]!
  """Data for the Cato event for this story"""
  events: [Event!]
  """Mitre data for the story (ie. ID, name)"""
  mitres: [Mitre!]
  """Timeseries data for the incident"""
  timeSeries: [IncidentTimeseries!]
  """Data about the target of the threat"""
  targets: [IncidentTargetRep!]!
  """Data about the traffic flow for the threat"""
  flows: [IncidentFlow!]
}

type ThreatPrevention implements MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  srcSiteId: String
  flowsCardinality: Int
  riskLevel: RiskLevelEnum
  os: String
  deviceName: String
  macAddress: String
  sourceIp: String
  logonName: String
  direction: String
  clientClass: [String!]!
  events: [Event!]
  mitres: [Mitre!]
  timeSeries: [IncidentTimeseries!]
  targets: [IncidentTargetRep!]!
  threatPreventionsEvents: [ThreatPreventionEvents!]
}

type SimilarStoryData {
  storyId: String
  threatTypeName: String
  verdict: String
  threatClassification: String
  similarityPercentage: Float
  indication: String
}

type ThreatPreventionEvents {
  appName: String
  clientClass: String
  sourceIp: String
  sourcePort: Int
  destinationCountry: String
  destinationIp: String
  destinationPort: Int
  direction: String
  createdAt: DateTime
  method: String
  url: String
  target: String
  domain: String
  sourceGeolocation: String
  destinationGeolocation: String
  tunnelGeolocation: String
  dnsResponseIP: String
  smbFileName: String
  user: String
  userAgent: String
  fileHash: String
  ja3: String
  referrer: String
  httpResponseCode: Int
}

enum NetworkXDREventTypeEnum {
  INSIGHT
  DEGRADED
  RESOLVED
}

enum LinkConfigPrecedenceEnum {
  ACTIVE
  PASSIVE
  LAST_RESORT
}

enum LinkStatusEnum {
  ACTIVE
  PASSIVE
}

enum DeviceConfigHaRoleEnum {
  PRIMARY
  SECONDARY
}

enum DeviceHaRoleStateEnum {
  MASTER
  BACKUP
}

enum NetworkEventSourceEnum {
  SITE
  LINK
  DEVICE
  ISP
  POP
  HOST
  BGP_SESSION
}

enum LinkQualityIssueTypeEnum {
  PACKET_LOSS
  DISTANCE
  JITTER
  CONGESTION
}

enum TrafficDirectionEnum {
  UPSTREAM
  DOWNSTREAM
}

type BGPConnection {
  connectionName: String
  peerIp: String
  peerAsn: Asn32
  catoIp: String
  catoAsn: Asn16
}

type LinkQualityIssue {
  issueType: LinkQualityIssueTypeEnum
  direction: TrafficDirectionEnum
  current: Int
  threshold: Int
}

type NetworkTimelineEvent {
  created: DateTime!
  validated: DateTime!
  description: String
  eventType: NetworkXDREventTypeEnum
  incidentId: String
  networkEventSource: NetworkEventSourceEnum
  eventIds: [String!]!
  acknowledged: Boolean
  linkId: String
  linkName: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  linkStatus: LinkStatusEnum
  linkConfigBandwidth: String
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  deviceHaRoleState: DeviceHaRoleStateEnum
  socketSerialId: String
  pop: String
  isp: String
  bgpConnection: BGPConnection
  linkQualityIssue: LinkQualityIssue
  hostIp: String
  ruleName: String
  tunnelResetCount: Int
  muted: Boolean
}

enum IlmmOnboardingStatus {
  MISSING
  PENDING
  FAILED
  COMPLETE
}

type IspLoaFile {
  fileName: String
  fileHash: String
  uploadedAt: Time
}

type IlmmContact {
  name: String
  phone: String
  email: String
}

type IlmmLinkDetails {
  linkId: String
  description: String
  ispLinkId: String
  comments: String
  onboardingStatus: IlmmOnboardingStatus
  activeLicense: Boolean
}

type IlmmIspDetails {
  name: String
  ispAccountId: String
  supportEmail: String
  supportPhone: String
  description: String
  countryCode: String
  loaFile: IspLoaFile
}

type IlmmDetails {
  linkDetails: IlmmLinkDetails
  ispDetails: IlmmIspDetails
  contacts: [IlmmContact!]
}

type NetworkXDRIncident implements MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String!
  storyDuration: Int
  description: String
  sourceIp: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  networkIncidentTimeline: [NetworkTimelineEvent!]!
  storyType: String!
  occurrences: Int
  siteConnectionType: String
  siteConfigLocation: String
  acknowledged: Boolean
  linkId: String
  linkName: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  licenseRegion: String
  licenseBandwidth: String
  pop: String
  isp: String
  bgpConnection: BGPConnection
  hostIp: String
  ruleName: String
  muted: Boolean
  ilmmDetails: IlmmDetails
}

enum ScanResult {
  VIRUS_FOUND
  ENCRYPTED
  BYPASS_BY_CONTENT_RULE
  CLEAN
  CANCELLED
  BYPASS_BY_OTHER
  BYPASS_BY_TYPE
}

type Event {
  signatureId: String
  eventType: String
  threatType: String
  threatName: String
  severity: String
  action: String
  ruleId: String
  virusName: String
  scanResult: ScanResult
  appId: String
  appName: String
  dnsProtectionCategory: String
}

type Mitre {
  id: String
  name: String
}

type IncidentTargetRep {
  type: TargetType
  name: String
  analysisScore: Float
  infectionSource: Boolean
  threatReference: String
  catoPopularity: Int
  threatFeeds: Int
  creationTime: DateTime
  categories: String
  countryOfRegistration: String
  searchHits: String
  engines: Int
  eventData: [Event!]!
}

type IncidentFlow {
  appName: String
  clientClass: String
  sourceIp: String
  sourcePort: Int
  destinationCountry: String
  destinationIp: String
  destinationPort: Int
  direction: String
  createdAt: DateTime
  referer: String
  userAgent: String
  method: String
  url: String
  target: String
  domain: String
  sourceGeolocation: String
  destinationGeolocation: String
  tunnelGeolocation: String
  httpResponseCode: Int
  dnsResponseIP: String
  smbFileName: String
  user: String
  fileHash: String
  ja3: String
}

type StoryDrillDownFilter {
  name: String!
  value: String!
}

enum RiskLevelEnum {
  Malicious
  Inconclusive
  Benign
  High
  Medium
  Low
  nan
}

enum StoryProducerEnum {
  AnomalyStats
  AnomalyEvents
  ThreatHunt
  ThreatPrevention
  NetworkMonitor
  NetworkXDR
  MicrosoftEndpointDefender
  CatoEndpointAlert
  EntraIdAlert
}

enum StoryEngineTypeEnum {
  ANOMALY
  THREAT
  ENDPOINT
  NETWORK
  IDENTITY
}

enum VendorEnum {
  CATO
  MICROSOFT
}

enum ConnectionTypeEnum {
  Site
  Host
  User
}

type IncidentTimeseries {
  """
  Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
  milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
  """
  data(
    "whether to normalize the data into per second (i.e. divide by granularity)"
    perSecond: Boolean = true
  ): [[Float!]]
  "Indicates the type of the timeseries"
  label: String!
  sum: Float
  """
  Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
  of data to make sense.
  """
  units: UnitType
  """
  Specific information about the timeseries, used to build its name, title etc
  """
  info: [String!]
  key: TimeseriesKey
}

type MicrosoftEndpoint implements Endpoint & MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  sourceIp: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  device: MicrosoftDeviceDetails
  alerts: [MicrosoftDefenderEndpointAlert!]!
}

type MicrosoftDeviceDetails implements DeviceDetails {
  id: ID!
  deviceName: String
  osDetails: OsDetails
  loggedOnUsers: [EndpointUser!]!
  firstSeenDateTime: DateTime
  avStatus: DeviceAvStatusEnum
  healthStatus: DeviceHealthStatusEnum
  rbacGroup: RbacGroup
  ipInterfaces: [String!]!
  azureAdDeviceId: String
  onboardingStatus: OnboardingStatusEnum
}

enum OnboardingStatusEnum {
  INSUFFICIENT_INFO
  ONBOARDED
  CAN_BE_ONBOARDED
}

type MicrosoftEndpointUser implements EndpointUser {
  id: ID!
  name: String!
  userSid: String
  accountName: String
  domainName: String
  principalName: String
}

type MicrosoftDefenderEndpointAlert implements EndpointAlert {
  id: ID!
  title: String
  description: String
  threatName: String
  mitreTechnique: [Mitre!]!
  mitreSubTechnique: [Mitre!]!
  createdDateTime: DateTime
  resources: [MicrosoftEndpointResource!]!
  activities: [MicrosoftActivity!]!
  criticality: Int
  comments: [String!]!
  recommendedActions: String
  category: String
  ownerName: String
  threatFamilyName: String
  threatType: String
  resolvedDateTime: DateTime
  firstActivityDateTime: DateTime
  lastActivityDateTime: DateTime
  lastUpdateDateTime: DateTime
  localIp: String
  destinationIp: String
  destinationUrl: String
  status: MsAlertStatus
  providerAlertId: String
  alertWebUrl: String
  determination: AlertDeterminationEnum
  detectionSource: DetectionSourceEnum
  classification: AlertClassificationEnum
}

interface MicrosoftEndpointResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  tags: [String!]!
  roles: [ResourceRoleEnum!]!
  verdict: MsResourceVerdictEnum
}

type MicrosoftProcessResource implements ProcessResource & MicrosoftEndpointResource & EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  tags: [String!]!
  roles: [ResourceRoleEnum!]!
  verdict: MsResourceVerdictEnum
  processId: Int!
  processCommandLine: String
  imageFile: FileDetails
  userAccount: EndpointUser
}

type MicrosoftFileResource implements FileResource & MicrosoftEndpointResource & EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  tags: [String!]!
  roles: [ResourceRoleEnum!]!
  verdict: MsResourceVerdictEnum
  fileDetails: FileDetails
  detectionStatus: DetectionStatusEnum
}

type MicrosoftRegistryResource implements RegistryResource & MicrosoftEndpointResource & EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  tags: [String!]!
  roles: [ResourceRoleEnum!]!
  verdict: MsResourceVerdictEnum
  hive: String
  key: String
  value: String
  valueName: String
  valueType: String
}

type MicrosoftActivity implements Activity {
  id: ID!
  resourceId: ID!
  parentResourceId: ID!
  action: String
  firstActivityDateTime: DateTime
  lastActivityDateTime: DateTime
}

type RbacGroup {
  id: ID!
  name: String
}

enum MsAlertStatus {
  NEW
  IN_PROGRESS
  RESOLVED
}

enum DetectionSourceEnum {
  MICROSOFT_DEFENDER_FOR_ENDPOINT
  ANTIVIRUS
  SMART_SCREEN
  CUSTOM_TI
  MICROSOFT_DEFENDER_FOR_OFFICE365
  AUTOMATED_INVESTIGATION
  MICROSOFT_THREAT_EXPERTS
  CUSTOM_DETECTION
  MICROSOFT_DEFENDER_FOR_IDENTITY
  CLOUD_APP_SECURITY
  MICROSOFT365_DEFENDER
  AZURE_AD_IDENTITY_PROTECTION
  MANUAL
  MICROSOFT_DATA_LOSS_PREVENTION
  APP_GOVERNANCE_POLICY
  APP_GOVERNANCE_DETECTION
}

enum AlertClassificationEnum {
  FALSE_POSITIVE
  TRUE_POSITIVE
  INFORMATIONAL_EXPECTED_ACTIVITY
}

enum AlertDeterminationEnum {
  APT
  MALWARE
  SECURITY_PERSONNEL
  SECURITY_TESTING
  UNWANTED_SOFTWARE
  MULTI_STAGED_ATTACK
  COMPROMISED_ACCOUNT
  PHISHING
  MALICIOUS_USER_ACTIVITY
  NOT_MALICIOUS
  NOT_ENOUGH_DATA_TO_VALIDATE
  CONFIRMED_ACTIVITY
  LINE_OF_BUSINESS_APPLICATION
  OTHER
}

enum MsResourceVerdictEnum {
  Suspicious
  Malicious
  Informational
  Benign
}
