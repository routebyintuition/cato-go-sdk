"""
The @beta directive is used within the type system definition language to indicate beta portions of a
GraphQL service's schema, such as beta fields, enum values, arguments or input fields.
"""
directive @beta on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE | OBJECT

"""
The @ga directive is used within the type system definition language to indicate GA portions of a
GraphQL service's schema, such as GA fields, enum values, arguments or input fields.
"""
directive @ga on FIELD_DEFINITION

type Query {
  accountBySubdomain(
    accountID: ID!
    """a list of required subdomains"""
    subdomains: [String!]!
  ): [AccountDataPayload!] @ga
  """
  The accountMetrics query helps you analyze the state and quality of the connections
  of sites and SDP users to the Cato Cloud. This data is for the traffic inside the DTLS
  tunnel between the site and the Cato Cloud. accountMetrics shows historical metrics,
  statics, and analytics for the account.
  """
  accountMetrics(
    """Unique Identifier of Account."""
    accountID: ID
    id: ID @deprecated(reason: "by accountID")
    """
    The time frame for the data that the query returns. The argument is in the format type.time value. This argument is mandatory.
    """
    timeFrame: TimeFrame!
    """
    When the boolean argument groupInterfaces is set to __true__, then the data for all the
    interfaces are aggregated to a single interface.
    """
    groupInterfaces: Boolean
    """
    When the boolean argument groupDevices is set to __true__, then the analytics for all the
    Sockets (usually two in high availability) are aggregated as one result.
    
    For the best results for aggregated Sockets, we recommend that there is consistent
    names and functionality (for example Destination) for the links on both Sockets.
    """
    groupDevices: Boolean
  ): AccountMetrics @ga
  accountRoles(accountID: ID!, accountType: AccountType): AccountRolesResult! @ga
  """
  Current snapshot-based metrics that show near real‑time data for the account.
  Provides analytics that are similar to the Topology page for the account.
  """
  accountSnapshot(
    """Unique Identifier of Account."""
    accountID: ID
    id: ID @deprecated(reason: "by accountID")
  ): AccountSnapshot @ga
  admin(accountId: ID!, adminID: ID!): GetAdminPayload @ga
  admins(accountID: ID!, limit: Int = 50, from: Int = 0, search: String = "", sort: [SortInput], adminIDs: [ID!]): AdminsResult @ga
  "BETA"
  appStats(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [Measure]
    dimensions: [Dimension]
    filters: [AppStatsFilter!]
    sort: [AppStatsSort!]
  ): AppStats @ga
  "BETA"
  appStatsTimeSeries(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [Measure]
    dimensions: [Dimension]
    filters: [AppStatsFilter!]
  ): AppStatsTimeSeries @ga
  """Audit Feed for account changes"""
  auditFeed(
    """List of Unique Account Identifiers."""
    accountIDs: [ID!]
    ids: [ID!] @deprecated(reason: "by accountIDs")
    timeFrame: TimeFrame!
    filters: [AuditFieldFilterInput!]
    "Marker to use to get results from"
    marker: String
  ): AuditFeed @ga
  container(accountId: ID!): ContainerQueries
  """Lookup entities with a specific type, potentially filtered and paged"""
  entityLookup(
    """The account ID (or 0 for non-authenticated requests)"""
    accountID: ID!
    """Type of entity to lookup for"""
    type: EntityType!
    """Sets the maximum number of items to retrieve"""
    limit: Int = 50
    """Sets the offset number of items (for paging)"""
    from: Int = 0
    """
    Return items under a parent entity (can be site, vpn user, etc),
    used to filter for networks that belong to a specific site for example
    """
    parent: EntityInput
    """
    Adds additional search parameters for the lookup. Available options:
    country lookup: "removeExcluded" to return only allowed countries
    countryState lookup: country code ("US", "CN", etc) to get country's states
    """
    search: String = ""
    """
    Adds additional search criteria to fetch by the selected list of entity IDs. This option is not
    universally available, and may not be applicable specific Entity types. If used on non applicable entity
    type, an error will be generated.
    """
    entityIDs: [ID!]
    """
    Adds additional sort criteria(s) for the lookup.
    This option is not universally available, and may not be applicable specific Entity types.
    """
    sort: [SortInput]
    """Custom filters for entityLookup"""
    filters: [LookupFilterInput]
    """Additional helper fields"""
    helperFields: [String!]
  ): EntityLookupResult! @ga
  "BETA"
  events(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [EventsMeasure]
    dimensions: [EventsDimension]
    filters: [EventsFilter!]
    sort: [EventsSort!]
  ): Events @ga
  """Event Feed for events paged by a topic partitions offsets marker"""
  eventsFeed(
    """List of Unique Account Identifiers."""
    accountIDs: [ID!]
    filters: [EventFeedFieldFilterInput!]
    "Marker to use to get results from"
    marker: String
  ): EventsFeedData @ga
  "BETA"
  eventsTimeSeries(
    "Account ID"
    accountID: ID!
    timeFrame: TimeFrame!
    measures: [EventsMeasure]
    dimensions: [EventsDimension]
    filters: [EventsFilter!]
  ): EventsTimeSeries @ga
  """Retrieve the account hardware inventory"""
  hardwareManagement(accountId: ID!): HardwareManagementQueries
  """Retrieve the account(s) license inventory and license consumption"""
  licensing(accountId: ID!): LicensingQueries
  policy(accountId: ID!): PolicyQueries
  """
  The subdomain query helps you retrieve the URL of an account. The usage of this query supports 3 different scenarios:
  1. Regular account - Return only 1 subdomain relating to the regular account
  2. Reseller account - Return all subdomains including the reseller account subdomain
  3. Reseller account - Return only the reseller account subdomain
  """
  subDomains(
    """Unique Identifier of Account"""
    accountID: ID!
    """
    When the boolean argument managedAccount is set to true (default), then the query returns all subdomains related to the account
    """
    managedAccount: Boolean
  ): [SubDomain!]! @ga
  xdr(accountID: ID!): XDR!
}

type Mutation {
  admin(accountId: ID!): AdminMutations!
  container(accountId: ID!): ContainerMutations
  policy(accountId: ID!): PolicyMutations
  site(accountId: ID!): SiteMutations! @deprecated(reason: "in favor of sites")
  sites(accountId: ID!): SiteMutations!
}

type MicrosoftEndpoint implements Endpoint & MergedIncident {
  alerts: [MicrosoftDefenderEndpointAlert!]!
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  device: MicrosoftDeviceDetails
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

type MicrosoftDeviceDetails implements DeviceDetails {
  avStatus: DeviceAvStatusEnum
  azureAdDeviceId: String
  deviceName: String
  firstSeenDateTime: DateTime
  healthStatus: DeviceHealthStatusEnum
  id: ID!
  ipInterfaces: [String!]!
  loggedOnUsers: [EndpointUser!]!
  onboardingStatus: OnboardingStatusEnum
  osDetails: OsDetails
  rbacGroup: RbacGroup
}

enum OnboardingStatusEnum {
  CAN_BE_ONBOARDED
  INSUFFICIENT_INFO
  ONBOARDED
}

type MicrosoftEndpointUser implements EndpointUser {
  accountName: String
  domainName: String
  id: ID!
  name: String!
  principalName: String
  userSid: String
}

type MicrosoftDefenderEndpointAlert implements EndpointAlert {
  activities: [MicrosoftActivity!]!
  alertWebUrl: String
  category: String
  classification: AlertClassificationEnum
  comments: [String!]!
  createdDateTime: DateTime
  criticality: Int
  description: String
  destinationIp: String
  destinationUrl: String
  detectionSource: DetectionSourceEnum
  determination: AlertDeterminationEnum
  firstActivityDateTime: DateTime
  id: ID!
  lastActivityDateTime: DateTime
  lastUpdateDateTime: DateTime
  localIp: String
  mitreSubTechnique: [Mitre!]!
  mitreTechnique: [Mitre!]!
  ownerName: String
  providerAlertId: String
  recommendedActions: String
  resolvedDateTime: DateTime
  resources: [MicrosoftEndpointResource!]!
  status: MsAlertStatus
  threatFamilyName: String
  threatName: String
  threatType: String
  title: String
}

interface MicrosoftEndpointResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  tags: [String!]!
  roles: [ResourceRoleEnum!]!
  verdict: MsResourceVerdictEnum
}

type MicrosoftProcessResource implements ProcessResource & MicrosoftEndpointResource & EndpointResource {
  createdDateTime: DateTime
  id: ID!
  imageFile: FileDetails
  processCommandLine: String
  processId: Int!
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  userAccount: EndpointUser
  verdict: MsResourceVerdictEnum
}

type MicrosoftFileResource implements FileResource & MicrosoftEndpointResource & EndpointResource {
  createdDateTime: DateTime
  detectionStatus: DetectionStatusEnum
  fileDetails: FileDetails
  id: ID!
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  verdict: MsResourceVerdictEnum
}

type MicrosoftRegistryResource implements RegistryResource & MicrosoftEndpointResource & EndpointResource {
  createdDateTime: DateTime
  hive: String
  id: ID!
  key: String
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  value: String
  valueName: String
  valueType: String
  verdict: MsResourceVerdictEnum
}

type MicrosoftActivity implements Activity {
  action: String
  firstActivityDateTime: DateTime
  id: ID!
  lastActivityDateTime: DateTime
  parentResourceId: ID!
  resourceId: ID!
}

type RbacGroup {
  id: ID!
  name: String
}

enum MsAlertStatus {
  IN_PROGRESS
  NEW
  RESOLVED
}

enum DetectionSourceEnum {
  ANTIVIRUS
  APP_GOVERNANCE_DETECTION
  APP_GOVERNANCE_POLICY
  AUTOMATED_INVESTIGATION
  AZURE_AD_IDENTITY_PROTECTION
  CLOUD_APP_SECURITY
  CUSTOM_DETECTION
  CUSTOM_TI
  MANUAL
  MICROSOFT_DATA_LOSS_PREVENTION
  MICROSOFT_DEFENDER_FOR_ENDPOINT
  MICROSOFT_DEFENDER_FOR_IDENTITY
  MICROSOFT_DEFENDER_FOR_OFFICE365
  MICROSOFT_THREAT_EXPERTS
  MICROSOFT365_DEFENDER
  SMART_SCREEN
}

enum AlertClassificationEnum {
  FALSE_POSITIVE
  INFORMATIONAL_EXPECTED_ACTIVITY
  TRUE_POSITIVE
}

enum AlertDeterminationEnum {
  APT
  COMPROMISED_ACCOUNT
  CONFIRMED_ACTIVITY
  LINE_OF_BUSINESS_APPLICATION
  MALICIOUS_USER_ACTIVITY
  MALWARE
  MULTI_STAGED_ATTACK
  NOT_ENOUGH_DATA_TO_VALIDATE
  NOT_MALICIOUS
  OTHER
  PHISHING
  SECURITY_PERSONNEL
  SECURITY_TESTING
  UNWANTED_SOFTWARE
}

enum MsResourceVerdictEnum {
  Benign
  Informational
  Malicious
  Suspicious
}

type XDR {
  """
  Define the paging, sort, and filter arguments to define the XDR stories that are returned in the query
  """
  stories(input: StoryInput!): StoriesData
  """
  Define either the story ID, or the incident ID and producer arguments, to query the specific XDR story
  """
  story(storyId: ID, producer: StoryProducerEnum, incidentId: ID): Story
}

enum StoryVerdictEnum {
  Benign
  Informational
  Malicious
  Suspicious
}

enum TargetType {
  domain
  fqdn
  ip
  url
}

input StoryInput {
  filter: [StoryFilterInput!]!
  paging: PagingInput!
  sort: [StorySortInput!]
}

input StorySortInput {
  fieldName: StorySortFieldName!
  order: SortDirectionEnum
}

enum StorySortFieldName {
  accountName
  createdAt
  criticality
  engineType
  firstSignal
  producer
  queryName
  riskScore
  severity
  source
  sourceIp
  status
  updatedAt
}

input StoryFilterInput {
  accountId: AccountIdPredicate
  criticality: IntPredicate
  engineType: EngineTypePredicate
  incidentId: StringPredicate
  ioa: StringPredicate
  muted: BooleanPredicate
  producer: StoryProducerPredicate
  queryName: StringPredicate
  severity: StorySeverityPredicate
  source: StringPredicate
  sourceIp: StringPredicate
  status: StoryStatusPredicate
  storyId: StoryIdPredicate
  timeFrame: TimeFramePredicate!
  vendor: VendorPredicate
  verdict: StoryVerdictPredicate
}

input StoryVerdictPredicate {
  in: [StoryVerdictEnum!]
  not_in: [StoryVerdictEnum!]
}

input TimeFramePredicate {
  time: TimeFrame!
  timeFrameModifier: TimeFrameModifier
}

enum TimeFrameModifier {
  AnalystUpdate
  StoryCreate
  StoryUpdate
}

input AccountIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input StoryIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input StorySeverityPredicate {
  in: [SeverityEnum!]
  not_in: [SeverityEnum!]
}

enum SeverityEnum {
  High
  Low
  Medium
}

input StoryProducerPredicate {
  in: [StoryProducerEnum!]
  not_in: [StoryProducerEnum!]
}

input StoryStatusPredicate {
  in: [StoryStatusEnum!]
  not_in: [StoryStatusEnum!]
}

input IntPredicate {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not_in: [Int!]
}

input StringPredicate {
  contains: String
  in: [String]
  not_in: [String]
}

input BooleanPredicate {
  is: String!
}

input EngineTypePredicate {
  in: [StoryEngineTypeEnum!]
  not_in: [StoryEngineTypeEnum!]
}

input VendorPredicate {
  in: [VendorEnum!]
  not_in: [VendorEnum!]
}

enum SortDirectionEnum {
  asc
  desc
}

type StoriesData {
  """Fields returned from the Story query"""
  items: [Story!]!
  """
  Define the stories that are returned, similar to a page of stories in the Cato Management Application
  """
  paging: Paging!
}

type Paging {
  """
  Based on the filter and sort parameters, the first story that is returned
  """
  from: Int!
  """
  Based on the filter and sort parameters, the number of stories returned after the from. For example, the argument {from: 10, limit: 10} returns stories 10-20.
  """
  limit: Int!
  """Total number of stories returned"""
  total: Int!
}

type Story {
  """ID for your Cato account"""
  accountId: Int!
  """Name of the account in the Cato Management Application"""
  accountName: String
  """Email address of the analyst working on the story"""
  analystEmail: String
  """Name of analyst working on the story"""
  analystName: String
  """Timestamp when the story was created"""
  createdAt: DateTime!
  """Unique Cato ID for each story"""
  id: ID!
  """
  Data related to the fields and incidents that were merged to create or update the story
  """
  incident: MergedIncident!
  """
  URL for the playbook in the Knowledge Base to help troubleshoot the story
  """
  playbook: String
  """Summary of the story"""
  summary: String
  """Data for the story timeline"""
  timeline: [TimelineItem!]!
  """Timestamp when the story was most recently updated"""
  updatedAt: DateTime!
}

enum StoryStatusEnum {
  Closed
  Monitoring
  Open
  PendingAnalysis
  PendingMoreInfo
  Reopened
}

type TimelineItem {
  """Additional information about this timeline item"""
  additionalInfo: String
  """Data about the analyst for this timeline item (ie. name, email)"""
  analystInfo: AnalystInfo
  """Enum for the timeline category (ie. Information, Warning, Error)"""
  category: TimelineItemCategoryEnum
  """Status of the timeline item"""
  context: String!
  """Timestamp the story was created"""
  createdAt: DateTime!
  """Description for the story in the timeline"""
  description: String!
  """Description for the story in the timeline"""
  descriptions: [String!]!
  """Enum for the type (ie. Diff, Action, Comment)"""
  type: TimelineTypeEnum!
}

type AnalystInfo {
  """Security analyst email address"""
  email: String
  """Security analyst name"""
  name: String
}

enum TimelineTypeEnum {
  Action
  Comment
  Diff
}

enum TimelineItemCategoryEnum {
  Error
  Information
  Warning
}

interface MergedIncident {
  """Unique Cato ID for each story"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
  
  For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """
  For Network stories - The site where the network issue is occurring
  
  For Security stories - IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """The ticket an analyst created for this story"""
  ticket: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  The value is TRUE when the story is currently being researched by Security Analysts
  """
  research: Boolean
  """Site name related to the story"""
  siteName: String
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """For Security stories, description of the threat"""
  description: String
  """
  The source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """Cato ID and name for the site"""
  site: SiteRef
  """Cato ID and name for the user"""
  user: UserRef
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
}

type AnalystFeedbackThreatType {
  details: String
  name: String
  recommendedAction: String
}

type AnalystFeedback {
  additionalInfo: String
  severity: SeverityEnum
  threatClassification: String
  threatType: AnalystFeedbackThreatType
  verdict: StoryVerdictEnum
}

interface Anomalies implements MergedIncident {
  id: ID!
  firstSignal: DateTime!
  lastSignal: DateTime!
  engineType: StoryEngineTypeEnum
  vendor: VendorEnum
  producer: StoryProducerEnum!
  producerName: String!
  connectionType: ConnectionTypeEnum
  indication: String!
  queryName: String
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  sourceIp: String
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  direction: String
}

type AnomalyStats implements Anomalies & MergedIncident {
  analystFeedback: AnalystFeedback
  breakdownField: String
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  drillDownFilter: [StoryDrillDownFilter!]
  engineType: StoryEngineTypeEnum
  extra: [Extra!]
  firstSignal: DateTime!
  gaussian: Gaussian
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  rules: [String!]
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  subjectType: String
  targets: [IncidentTargetRep!]!
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

type AnomalyEvents implements Anomalies & MergedIncident {
  analystFeedback: AnalystFeedback
  breakdownField: String
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  drillDownFilter: [StoryDrillDownFilter!]
  engineType: StoryEngineTypeEnum
  extra: [Extra!]
  firstSignal: DateTime!
  gaussian: Gaussian
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  rules: [String!]
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  subjectType: String
  targets: [IncidentTargetRep!]!
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

type Metric {
  name: String!
  value: Float!
}

type Gaussian {
  avg: Float
  n: Float
  ss: Float
  std: Float
  z_score: Float
}

type Extra {
  name: String!
  type: String!
  value: String!
}

type MetricDetails {
  name: String!
  units: String!
}

type Threat implements MergedIncident {
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """Client Class for the traffic flow"""
  clientClass: [String!]!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """Description of the threat"""
  description: String
  """Name of the device"""
  deviceName: String
  """Traffic direction for the threat"""
  direction: String
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Data for the Cato event for this story"""
  events: [Event!]
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """Data about the traffic flow for the threat"""
  flows: [IncidentFlow!]
  """Cardinality of traffic flows for the threat"""
  flowsCardinality: Int
  """Unique Cato ID for this threat"""
  id: ID!
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Timestamp for the first incident signal related to this story"""
  lastSignal: DateTime!
  """Username for the device"""
  logonName: String
  """MAC address of the device"""
  macAddress: String
  """Mitre data for the story (ie. ID, name)"""
  mitres: [Mitre!]
  """OS for device or host that is the threat target"""
  os: String
  """Cato’s predicted threat type for the story"""
  predictedThreatType: String
  """Enum for Cato’s predicted verdict of the story (ie. Malicious, Benign)"""
  predictedVerdict: StoryVerdictEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  The value is TRUE when the story is currently being researched by Security Analysts
  """
  research: Boolean
  """The estimated risk level of the threat (ie. Malicious, High, Low)"""
  riskLevel: RiskLevelEnum
  """Data for stories that are similar"""
  similarStoriesData: [SimilarStoryData!]!
  """Cato ID and name for the site"""
  site: SiteRef
  """Site name related to the story"""
  siteName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """
  The source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Cato ID for the site that is the source of the threat"""
  srcSiteId: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """Data about the target of the threat"""
  targets: [IncidentTargetRep!]!
  """The ticket an analyst created for this story"""
  ticket: String
  """Timeseries data for the incident"""
  timeSeries: [IncidentTimeseries!]
  """Cato ID and name for the user"""
  user: UserRef
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
}

type ThreatPrevention implements MergedIncident {
  analystFeedback: AnalystFeedback
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  engineType: StoryEngineTypeEnum
  events: [Event!]
  firstSignal: DateTime!
  flowsCardinality: Int
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  riskLevel: RiskLevelEnum
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  targets: [IncidentTargetRep!]!
  threatPreventionsEvents: [ThreatPreventionEvents!]
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

type SimilarStoryData {
  indication: String
  similarityPercentage: Float
  storyId: String
  threatClassification: String
  threatTypeName: String
  verdict: String
}

type ThreatPreventionEvents {
  appName: String
  clientClass: String
  createdAt: DateTime
  destinationCountry: String
  destinationGeolocation: String
  destinationIp: String
  destinationPort: Int
  direction: String
  dnsResponseIP: String
  domain: String
  fileHash: String
  httpResponseCode: Int
  ja3: String
  method: String
  referrer: String
  smbFileName: String
  sourceGeolocation: String
  sourceIp: String
  sourcePort: Int
  target: String
  tunnelGeolocation: String
  url: String
  user: String
  userAgent: String
}

enum NetworkXDREventTypeEnum {
  DEGRADED
  INSIGHT
  RESOLVED
}

enum LinkConfigPrecedenceEnum {
  ACTIVE
  LAST_RESORT
  PASSIVE
}

enum LinkStatusEnum {
  ACTIVE
  PASSIVE
}

enum DeviceConfigHaRoleEnum {
  PRIMARY
  SECONDARY
}

enum DeviceHaRoleStateEnum {
  BACKUP
  MASTER
}

enum NetworkEventSourceEnum {
  BGP_SESSION
  DEVICE
  HOST
  ISP
  LINK
  POP
  SITE
}

enum LinkQualityIssueTypeEnum {
  CONGESTION
  DISTANCE
  JITTER
  PACKET_LOSS
}

enum TrafficDirectionEnum {
  DOWNSTREAM
  UPSTREAM
}

type BGPConnection {
  catoAsn: Asn16
  catoIp: String
  connectionName: String
  peerAsn: Asn32
  peerIp: String
}

type LinkQualityIssue {
  current: Int
  direction: TrafficDirectionEnum
  issueType: LinkQualityIssueTypeEnum
  threshold: Int
}

type NetworkTimelineEvent {
  acknowledged: Boolean
  bgpConnection: BGPConnection
  created: DateTime!
  description: String
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  deviceHaRoleState: DeviceHaRoleStateEnum
  eventIds: [String!]!
  eventType: NetworkXDREventTypeEnum
  hostIp: String
  incidentId: String
  isp: String
  linkConfigBandwidth: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  linkId: String
  linkName: String
  linkQualityIssue: LinkQualityIssue
  linkStatus: LinkStatusEnum
  muted: Boolean
  networkEventSource: NetworkEventSourceEnum
  pop: String
  ruleName: String
  socketSerialId: String
  tunnelResetCount: Int
  validated: DateTime!
}

enum IlmmOnboardingStatus {
  COMPLETE
  FAILED
  MISSING
  PENDING
}

type IspLoaFile {
  fileHash: String
  fileName: String
  uploadedAt: Time
}

type IlmmContact {
  email: String
  name: String
  phone: String
}

type IlmmLinkDetails {
  activeLicense: Boolean
  comments: String
  description: String
  ispLinkId: String
  linkId: String
  onboardingStatus: IlmmOnboardingStatus
}

type IlmmIspDetails {
  countryCode: String
  description: String
  ispAccountId: String
  loaFile: IspLoaFile
  name: String
  supportEmail: String
  supportPhone: String
}

type IlmmDetails {
  contacts: [IlmmContact!]
  ispDetails: IlmmIspDetails
  linkDetails: IlmmLinkDetails
}

type NetworkXDRIncident implements MergedIncident {
  acknowledged: Boolean
  analystFeedback: AnalystFeedback
  bgpConnection: BGPConnection
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  hostIp: String
  id: ID!
  ilmmDetails: IlmmDetails
  indication: String!
  isp: String
  lastSignal: DateTime!
  licenseBandwidth: String
  licenseRegion: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  linkId: String
  linkName: String
  muted: Boolean
  networkIncidentTimeline: [NetworkTimelineEvent!]!
  occurrences: Int
  pop: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  ruleName: String
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteConfigLocation: String
  siteConnectionType: String
  siteName: String!
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  storyType: String!
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

enum ScanResult {
  BYPASS_BY_CONTENT_RULE
  BYPASS_BY_OTHER
  BYPASS_BY_TYPE
  CANCELLED
  CLEAN
  ENCRYPTED
  VIRUS_FOUND
}

type Event {
  action: String
  appId: String
  appName: String
  dnsProtectionCategory: String
  eventType: String
  ruleId: String
  scanResult: ScanResult
  severity: String
  signatureId: String
  threatName: String
  threatType: String
  virusName: String
}

type Mitre {
  id: String
  name: String
}

type IncidentTargetRep {
  analysisScore: Float
  categories: String
  catoPopularity: Int
  countryOfRegistration: String
  creationTime: DateTime
  engines: Int
  eventData: [Event!]!
  infectionSource: Boolean
  name: String
  searchHits: String
  threatFeeds: Int
  threatReference: String
  type: TargetType
}

type IncidentFlow {
  appName: String
  clientClass: String
  createdAt: DateTime
  destinationCountry: String
  destinationGeolocation: String
  destinationIp: String
  destinationPort: Int
  direction: String
  dnsResponseIP: String
  domain: String
  fileHash: String
  httpResponseCode: Int
  ja3: String
  method: String
  referer: String
  smbFileName: String
  sourceGeolocation: String
  sourceIp: String
  sourcePort: Int
  target: String
  tunnelGeolocation: String
  url: String
  user: String
  userAgent: String
}

type StoryDrillDownFilter {
  name: String!
  value: String!
}

enum RiskLevelEnum {
  Benign
  High
  Inconclusive
  Low
  Malicious
  Medium
  nan
}

enum StoryProducerEnum {
  AnomalyEvents
  AnomalyStats
  CatoEndpointAlert
  EntraIdAlert
  MicrosoftEndpointDefender
  NetworkMonitor
  NetworkXDR
  ThreatHunt
  ThreatPrevention
}

enum StoryEngineTypeEnum {
  ANOMALY
  ENDPOINT
  IDENTITY
  NETWORK
  THREAT
}

enum VendorEnum {
  CATO
  MICROSOFT
}

enum ConnectionTypeEnum {
  Host
  Site
  User
}

type IncidentTimeseries {
  """
  Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
  milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
  """
  data(
    "whether to normalize the data into per second (i.e. divide by granularity)"
    perSecond: Boolean = true
  ): [[Float!]]
  """
  Specific information about the timeseries, used to build its name, title etc
  """
  info: [String!]
  key: TimeseriesKey
  "Indicates the type of the timeseries"
  label: String!
  sum: Float
  """
  Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
  of data to make sense.
  """
  units: UnitType
}

interface Endpoint implements MergedIncident {
  """Unique Cato ID for the story"""
  id: ID!
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  """XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
  """
  Enum for the Producer (specific XDR engine and service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """Enum for the connection for this incident (ie. site, host, user)"""
  connectionType: ConnectionTypeEnum
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """Category for the indication ID related to the story"""
  queryName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  criticality: Int
  ticket: String
  status: StoryStatusEnum
  research: Boolean
  siteName: String
  storyDuration: Int
  description: String
  sourceIp: String
  analystFeedback: AnalystFeedback
  site: SiteRef
  user: UserRef
  similarStoriesData: [SimilarStoryData!]!
  predictedVerdict: StoryVerdictEnum
  predictedThreatType: String
  device: DeviceDetails
  alerts: [EndpointAlert!]!
}

interface EndpointAlert {
  id: ID!
  title: String
  description: String
  threatName: String
  mitreTechnique: [Mitre!]!
  mitreSubTechnique: [Mitre!]!
  createdDateTime: DateTime
  resources: [EndpointResource!]!
  activities: [Activity!]!
  criticality: Int
}

interface Activity {
  id: ID!
  resourceId: ID!
  parentResourceId: ID!
}

interface DeviceDetails {
  id: ID!
  deviceName: String
  osDetails: OsDetails
  loggedOnUsers: [EndpointUser!]!
}

type OsDetails {
  osBuild: Int
  osType: String!
  osVersion: String
}

interface EndpointUser {
  id: ID!
  name: String!
}

enum ResourceRoleEnum {
  ADDED
  ATTACKED
  ATTACKER
  COMMAND_AND_CONTROL
  COMPROMISED
  CONTEXTUAL
  CREATED
  DESTINATION
  EDITED
  LOADED
  POLICY_VIOLATOR
  SCANNED
  SOURCE
  SUSPICIOUS
}

enum RemediationStatusEnum {
  BLOCKED
  CLEAN
  DELETED
  DELETED_REBOOT
  DISABLED
  DISINFECT_FAILED
  DISINFECTED
  INFECTED
  MOVED
  MOVED_REBOOT
  NOT_FOUND
  NOT_STARTED
  PASSWORD_PROTECTED
  PREVENTED
  REBOOT_REQUIRED
  REMEDIATED
  SCAN_FAILED
  SUCCESS
  SUSPICIOUS
  UNKNOWN
}

enum DeviceHealthStatusEnum {
  ACTIVE
  IMPAIRED_COMMUNICATION
  INACTIVE
  NO_SENSOR_DATA
  NO_SENSOR_DATA_IMPAIRED_COMMUNICATION
}

enum DeviceAvStatusEnum {
  DISABLED
  NOT_REPORTING
  NOT_UPDATED
  UPDATED
}

interface EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
}

interface ProcessResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  processId: Int!
  processCommandLine: String
  imageFile: FileDetails
  userAccount: EndpointUser
}

interface FileResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  fileDetails: FileDetails
  detectionStatus: DetectionStatusEnum
}

interface RegistryResource implements EndpointResource {
  id: ID!
  createdDateTime: DateTime
  remediationStatus: RemediationStatusEnum
  hive: String
  key: String
  value: String
  valueName: String
  valueType: String
}

type FileDetails {
  issuer: String
  md5: String
  name: String
  path: String
  publisher: String
  sha1: String
  sha256: String
  signer: String
  size: Int
}

enum DetectionStatusEnum {
  BLOCKED
  DETECTED
  PREVENTED
}

type CatoEndpoint implements Endpoint & MergedIncident {
  """Details for the threat detected by the EPP"""
  alerts: [CatoEndpointAlert!]!
  """Fields related to analysts research of the threat incident"""
  analystFeedback: AnalystFeedback
  """enum for the connection for this incident (ie. host, user)"""
  connectionType: ConnectionTypeEnum
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """Description of the threat"""
  description: String
  """Details for the EPP device (ie. device name, OS, MAC address)"""
  device: CatoEndpointDeviceDetails
  """enum that shows XDR engine involved with the incident"""
  engineType: StoryEngineTypeEnum
  """Timestamp for the first incident signal related to this story"""
  firstSignal: DateTime!
  """ID for the Endpoint Protection story"""
  id: ID!
  """
  An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
  """
  indication: String!
  """
  Timestamp for the last (most recent) incident signal related to this story
  """
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  """
  enum for the Producer (specific XDR engine or service) involved with the incident
  """
  producer: StoryProducerEnum!
  """
  Full name of the Producer (specific XDR engine and service) involved with the incident
  """
  producerName: String!
  """"""
  queryName: String
  """
  TRUE indicates that the story is currently being researched by Security Analysts
  """
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  """Cato ID and name for the site"""
  site: SiteRef
  """Site name related to the story"""
  siteName: String
  """
  IP address, name of device, or SDP user on your network involved in the story
  """
  source: String
  """
  Source IP address of the device in your network sending or receiving the flow
  """
  sourceIp: String
  """Enum for the status of this story (ie. Open, Closed, Monitoring)"""
  status: StoryStatusEnum
  """
  Amount of time since the story was opened (no value for closed stories)
  """
  storyDuration: Int
  """The ticket for this story"""
  ticket: String
  """Cato ID and name for the site"""
  user: UserRef
  """Vendor that identified the incident, such as Cato or Microsoft"""
  vendor: VendorEnum
}

enum CatoEndpointEngineType {
  AntiMalware
  Behavioral
}

type CatoEndpointDeviceDetails implements DeviceDetails {
  """Name of the device"""
  deviceName: String
  """Unique Cato ID for this story"""
  id: ID!
  """Data for one or more users logged in to the device"""
  loggedOnUsers: [EndpointUser!]!
  """MAC address of the device"""
  macAddress: String
  """OS data (ie. type, build, version)"""
  osDetails: OsDetails
}

type CatoEndpointUser implements EndpointUser {
  """ID for the user"""
  id: ID!
  """Username for the user whose activity generated the indication"""
  name: String!
}

type CatoEndpointAlert implements EndpointAlert {
  """Unique Cato IDs for the activities related to the alert"""
  activities: [CatoActivity!]!
  """Timestamp that the threat was detected and the alert generated"""
  createdDateTime: DateTime
  """
  Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
  """
  criticality: Int
  """Description of the threat"""
  description: String
  """EPP profile that is assigned to this device"""
  endpointProtectionProfile: String
  """Enum for the EPP engine related to this story"""
  engineType: CatoEndpointEngineType
  """Unique Cato ID for the Endpoint Protection story"""
  id: ID!
  """MITRE ATT&CK® sub-technique for the threat"""
  mitreSubTechnique: [Mitre!]!
  """MITRE ATT&CK® technique for the threat"""
  mitreTechnique: [Mitre!]!
  """Data for the remediation status of the alert"""
  resources: [CatoResource!]!
  """Enum for the remediation status of the EPP alert"""
  status: RemediationStatusEnum
  """Name of threat detected on the device"""
  threatName: String
  """Title of the endpoint alert"""
  title: String
}

interface CatoResource implements EndpointResource {
  """Unique Cato ID for this EPP resource"""
  id: ID!
  """Timestamp that the this resource was used"""
  createdDateTime: DateTime
  """Enum for the remediation status associated with this resource"""
  remediationStatus: RemediationStatusEnum
}

type CatoProcessResource implements ProcessResource & CatoResource & EndpointResource {
  """Timestamp that the this resource was used"""
  createdDateTime: DateTime
  """Unique Cato ID for this resource"""
  id: ID!
  """Details of the file related to this process"""
  imageFile: FileDetails
  """CLI command related to this process"""
  processCommandLine: String
  """ID for the process"""
  processId: Int!
  """Enum for the remediation status associated with this resource"""
  remediationStatus: RemediationStatusEnum
  """User account related to this process"""
  userAccount: EndpointUser
}

type CatoFileResource implements FileResource & CatoResource & EndpointResource {
  """Timestamp that the this file resource was used"""
  createdDateTime: DateTime
  """Enum for the detection status of this file resource"""
  detectionStatus: DetectionStatusEnum
  """Details of the file related to this resource"""
  fileDetails: FileDetails
  """Unique Cato ID for this file resource"""
  id: ID!
  """Enum for the remediation status associated with this file resource"""
  remediationStatus: RemediationStatusEnum
}

type CatoActivity implements Activity {
  """Unique Cato ID for this activity"""
  id: ID!
  """
  Unique Cato ID for the preceding resource (process or file) in the alert
  """
  parentResourceId: ID!
  """
  Unique Cato ID for the resource (process or file) involved in the alert
  """
  resourceId: ID!
}

type SiteMutations {
  addIpsecIkeV2Site(input: AddIpsecIkeV2SiteInput!): AddIpsecIkeV2SitePayload
  addIpsecIkeV2SiteTunnels(siteId: ID!, input: AddIpsecIkeV2SiteTunnelsInput!): AddIpsecIkeV2SiteTunnelsPayload
  addNetworkRange(lanSocketInterfaceId: ID!, input: AddNetworkRangeInput!): AddNetworkRangePayload @ga
  addSocketSite(input: AddSocketSiteInput!): AddSocketSitePayload @ga
  addStaticHost(siteId: ID!, input: AddStaticHostInput!): AddStaticHostPayload @ga
  removeNetworkRange(networkRangeId: ID!): RemoveNetworkRangePayload @ga
  removeSite(siteId: ID!): RemoveSitePayload @ga
  removeStaticHost(hostId: ID!): RemoveStaticHostPayload @ga
  updateHa(siteId: ID!, input: UpdateHaInput!): UpdateHaPayload @ga
  updateIpsecIkeV2SiteGeneralDetails(siteId: ID!, input: UpdateIpsecIkeV2SiteGeneralDetailsInput!): UpdateIpsecIkeV2SiteGeneralDetailsPayload
  updateIpsecIkeV2SiteTunnels(siteId: ID!, input: UpdateIpsecIkeV2SiteTunnelsInput!): UpdateIpsecIkeV2SiteTunnelsPayload
  updateNetworkRange(networkRangeId: ID!, input: UpdateNetworkRangeInput!): UpdateNetworkRangePayload @ga
  updateSiteGeneralDetails(siteId: ID!, input: UpdateSiteGeneralDetailsInput!): UpdateSiteGeneralDetailsPayload @ga
  updateSocketInterface(siteId: ID!, socketInterfaceId: SocketInterfaceIDEnum!, input: UpdateSocketInterfaceInput!): UpdateSocketInterfacePayload @ga
  updateStaticHost(hostId: ID!, input: UpdateStaticHostInput!): UpdateStaticHostPayload @ga
}

input AddSocketSiteInput {
  connectionType: SiteConnectionTypeEnum! = SOCKET_X1500
  description: String
  name: String!
  nativeNetworkRange: IPSubnet!
  siteLocation: AddSiteLocationInput!
  siteType: SiteType! = BRANCH
  translatedSubnet: IPSubnet
}

input AddSiteLocationInput {
  """optional address"""
  address: String
  """city name, must belong to the country or country and state"""
  city: String
  """country code"""
  countryCode: String!
  """optional state code"""
  stateCode: String
  """time zone"""
  timezone: String!
}

input UpdateSiteGeneralDetailsInput {
  description: String
  name: String
  siteLocation: UpdateSiteLocationInput
  siteType: SiteType
}

input UpdateSiteLocationInput {
  address: String
  cityName: String
  countryCode: String
  stateCode: String
  timezone: String
}

input UpdateSocketInterfaceInput {
  """Only relevant for ALTERNATIVE, LAYER_2_WAN"""
  altWan: SocketInterfaceAltWanInput
  """Only relevant for CATO, ALTERNATIVE, LAYER_2_WAN"""
  bandwidth: SocketInterfaceBandwidthInput
  destType: SocketInterfaceDestType!
  """Only relevant for LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP"""
  lag: SocketInterfaceLagInput
  """
  Only relevant for LAN, VRRP_AND_LAN, LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
  """
  lan: SocketInterfaceLanInput
  name: String
  """Only relevant for CATO"""
  offCloud: SocketInterfaceOffCloudInput
  """Only relevant for VRRP"""
  vrrp: SocketInterfaceVrrpInput
  """Only relevant for CATO"""
  wan: SocketInterfaceWanInput
}

type UpdateSocketInterfacePayload {
  siteId: ID!
  socketInterfaceId: SocketInterfaceIDEnum!
}

input SocketInterfaceBandwidthInput {
  downstreamBandwidth: Int!
  upstreamBandwidth: Int!
}

input SocketInterfaceWanInput {
  precedence: SocketInterfacePrecedenceEnum!
  role: SocketInterfaceRole!
}

input SocketInterfaceLanInput {
  localIp: IPAddress!
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
}

input SocketInterfaceOffCloudInput {
  enabled: Boolean!
  publicIp: IPAddress
  publicStaticPort: Int
}

input SocketInterfaceAltWanInput {
  privateGatewayIp: IPAddress!
  privateInterfaceIp: IPAddress!
  privateNetwork: IPSubnet!
  privateVlanTag: Int
  publicGatewayIp: IPAddress
  publicInterfaceIp: IPAddress
  publicNetwork: IPSubnet
  publicVlanTag: Int
}

input SocketInterfaceLagInput {
  minLinks: Int!
}

input SocketInterfaceVrrpInput {
  vrrpType: VrrpType
}

input AddNetworkRangeInput {
  """Only relevant for AZURE HA sites"""
  azureFloatingIp: IPAddress
  """Only relevant for NATIVE, VLAN rangeType"""
  dhcpSettings: NetworkDhcpSettingsInput
  """Only relevant for ROUTED_ROUTE rangeType"""
  gateway: IPAddress
  """
  Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
  """
  localIp: IPAddress
  """BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType"""
  mdnsReflector: Boolean
  name: String!
  rangeType: SubnetType!
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
  """Only relevant for VLAN network rangeType"""
  vlan: Int
}

input UpdateNetworkRangeInput {
  """Only relevant for AZURE HA sites"""
  azureFloatingIp: IPAddress
  """Only relevant for NATIVE, VLAN rangeType"""
  dhcpSettings: NetworkDhcpSettingsInput
  """Only relevant for ROUTED_ROUTE rangeType"""
  gateway: IPAddress
  """
  Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
  """
  localIp: IPAddress
  """BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType"""
  mdnsReflector: Boolean
  name: String
  rangeType: SubnetType
  subnet: IPSubnet
  translatedSubnet: IPSubnet
  """Only relevant for VLAN network rangeType"""
  vlan: Int
}

input NetworkDhcpSettingsInput {
  dhcpType: DhcpType!
  ipRange: IPRange
  relayGroupId: ID
}

input UpdateHaInput {
  primaryManagementIp: IPAddress
  secondaryManagementIp: IPAddress
  vrid: Int
}

input AddStaticHostInput {
  ip: IPAddress!
  macAddress: String
  name: String!
}

input UpdateStaticHostInput {
  ip: IPAddress
  macAddress: String
  name: String
}

type RemoveSitePayload {
  siteId: ID!
}

type AddSocketSitePayload {
  siteId: ID!
}

type UpdateSiteGeneralDetailsPayload {
  siteId: ID!
}

type AddNetworkRangePayload {
  networkRangeId: ID!
}

type UpdateNetworkRangePayload {
  networkRangeId: ID!
}

type RemoveNetworkRangePayload {
  networkRangeId: ID!
}

type UpdateHaPayload {
  siteId: ID!
}

type AddStaticHostPayload {
  hostId: ID!
}

type UpdateStaticHostPayload {
  hostId: ID!
}

type RemoveStaticHostPayload {
  hostId: ID!
}

enum SocketInterfacePrecedenceEnum {
  ACTIVE
  LAST_RESORT
  PASSIVE
}

enum SiteConnectionTypeEnum {
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_ESX1500
  SOCKET_X1500
  SOCKET_X1600
  SOCKET_X1600_LTE
  SOCKET_X1700
}

scalar IPSubnet

"""A from-to range (used for DHCP range, for example)"""
scalar IPRange

"""A key value pairs object { "key1": "value1", "key2": "value2" }"""
scalar Map

"""
Enter the time frame for the data that the query returns.
The argument is in the format <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">\<type\>.\<time value\></span> This argument is mandatory.

These are the supported options to define the time frame:

last.\<time duration\> - The <time duration> value for the <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last</span> type is according to ISO-8601 and returns data
						for the previous specific times. For example:
<ul>
	<li>timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT5M</span> shows the previous 5 minutes</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT2H</span> shows the previous 2 hours</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1D</span> shows the previous 1 day</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P3M</span> shows the previous 3 months</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1Y</span> shows the previous 1 year</li>
</ul>

utc.\<short-time-frame-spec\>  - The time frame combines a start and end date in the format  YY-MM-DD/hh:mm:ss </br>
according to the specified time zone. </br> You must enter all the date and time values for the argument. For example:

<ul>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-{11/04:50:00--21/04:50:00}</span> shows 10 days of analytics data from February 11, 2020 4:50:00 am to February 21, 2020 4:50:00 am</li>
    <li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-11/{04:50:15--16:50:15}</span> shows 12 hours of analytics data on February 11, 2020, from 4:50:15 am to 16:50:15 pm</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-{02-11/04:50:00--04-11/04:50:00}</span> shows 2 months of analytics data from February 11, 2020 4:50:00 am to April 11 4:50:00 am</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.{2019-10-01/04:50:00--2020/02-01/04:50:00}</span> shows 4 months of analytics data from October 1, 2019 4:50:00 am to February 11 4:50:00 am</li>
</ul>

This format lets you configure a time frame the includes more than one calendar year
"""
scalar TimeFrame

"""File upload - https://gqlgen.com/reference/file-upload/"""
scalar Upload

enum UnitType {
  bits
  """Bits per second"""
  bps
  bytes
  """Bytes per second"""
  bytesPerSec
  """The number of occurrences for this unit"""
  count
  ms
  none
  packets
  percent
  """health analytics for the site"""
  score
  """
  For metrics that are measured in seconds, such as tunnelAge, the number of seconds
  """
  seconds
}

enum AggregationType {
  any
  avg
  changes
  count
  count_distinct
  distinct
  max
  min
  sum
  uniq_set
}

enum DirectionEnum {
  asc
  desc
}

enum FilterOperator {
  between
  exists
  gt
  gte
  in
  is
  is_not
  lt
  lte
  not_between
  not_exists
  not_in
}

type RBACRole {
  description: String
  id: ID!
  isPredefined: Boolean!
  name: String!
}

type AdminRole {
  allowedAccounts: [ID!]
  allowedEntities: [Entity!]
  role: RBACRole!
}

enum ConnectionOriginEnum {
  ANY
  REMOTE
  SITE
}

"Define settings for the Internet Firewall policy"
interface IPolicy {
  "TRUE = Policy is enabled, FALSE = Policy is disabled"
  enabled: Boolean!
  "Return list of rules in the policy"
  rules: [IPolicyRulePayload!]!
  "Return sections in the policy"
  sections: [PolicySectionPayload!]!
  "Audit data for the policy"
  audit: PolicyAudit
  "Return data for the Policy revision"
  revision: PolicyRevision
}

"Results of policy change"
interface IPolicyMutationPayload {
  "Data for the policy"
  policy: IPolicy
  "Enum for the status of the policy change"
  status: PolicyMutationStatus!
  "List of errors related to the policy change"
  errors: [PolicyMutationError!]!
}

interface IPolicyRule {
  "Rule ID"
  id: ID!
  "Name of the rule"
  name: String!
  "Description for the rule"
  description: String
  "Position / priority of rule"
  index: Int!
  "TRUE = Rule is enabled, FALSE = Rule is disabled"
  enabled: Boolean!
  "Policy section where the rule is located"
  section: PolicySectionInfo
}

"Results of rule change"
interface IPolicyRuleMutationPayload {
  "Returns settings for the rule"
  rule: IPolicyRulePayload
  "Enum for the status of the policy change"
  status: PolicyMutationStatus!
  "List of errors related to the policy change"
  errors: [PolicyMutationError!]!
}

"Results of changes to the rule"
interface IPolicyRulePayload {
  audit: PolicyElementAudit!
  "Rule that was changed"
  rule: IPolicyRule!
  "Summary of rule change, (ie. ADDED, UPDATED)"
  properties: [PolicyElementPropertiesEnum!]!
}

"The action applied by the Internet Firewall if the rule is matched"
enum InternetFirewallActionEnum {
  "Allow the network traffic to pass through the firewall."
  ALLOW
  "Deny the network traffic from passing through the firewall."
  BLOCK
  "Requests user confirmation to allow or block network traffic."
  PROMPT
  "Apply Remote Browser Isolation (RBI) to the network traffic"
  RBI
}

input InternetFirewallAddRuleDataInput {
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum! = BLOCK
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum! = ANY
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]! = []
  description: String! = ""
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestinationInput! = {application: [], customApp: [], appCategory: [], customCategory: [], sanctionedAppsCategory: [], country: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: [], remoteAsn: []}
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]! = []
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]! = []
  enabled: Boolean!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleExceptionInput!]! = []
  name: String!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleInput! = {activeOn: ALWAYS}
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceTypeInput! = {standard: [], custom: []}
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSourceInput! = {ip: [], host: [], site: [], subnet: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingInput! = {event: {enabled: false}, alert: {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}}
}

"Rule parameters and relevant position"
input InternetFirewallAddRuleInput {
  "Position of the rule in the policy"
  at: PolicyRulePositionInput
  "Parameters for the rule you are adding"
  rule: InternetFirewallAddRuleDataInput!
}

type InternetFirewallContainer {
  fqdnContainer: [FqdnContainerRef!]!
  ipAddressRangeContainer: [IpAddressRangeContainerRef!]!
}

input InternetFirewallContainerInput {
  fqdnContainer: [FqdnContainerRefInput!]! = []
  ipAddressRangeContainer: [IpAddressRangeContainerRefInput!]! = []
}

input InternetFirewallContainerUpdateInput {
  fqdnContainer: [FqdnContainerRefInput!]
  ipAddressRangeContainer: [IpAddressRangeContainerRefInput!]
}

"Destination match criteria set"
type InternetFirewallDestination {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRef!]!
  "Applications for the rule (pre-defined)"
  application: [ApplicationRef!]!
  # container: [ContainerRef!]!
  # containers: InternetFirewallContainer!
  "Countries"
  country: [CountryRef!]!
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRef!]!
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRef!]!
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]!
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "IPv4 addresses"
  ip: [IPAddress!]!
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRange!]!
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]!
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]!
}

"Destination match criteria set"
input InternetFirewallDestinationInput {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]! = []
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]! = []
  # container: [ContainerRefInput!]! = []
  # containers: InternetFirewallContainerInput! = {fqdnContainer: [], ipAddressRangeContainer: []}
  "Countries"
  country: [CountryRefInput!]! = []
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]! = []
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]! = []
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]! = []
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "IPv4 addresses"
  ip: [IPAddress!]! = []
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]! = []
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]! = []
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]! = []
}

"Destination match criteria set"
input InternetFirewallDestinationUpdateInput {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]
  container: [ContainerRefInput!]
  containers: InternetFirewallContainerUpdateInput
  "Countries"
  country: [CountryRefInput!]
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]
  "A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com."
  domain: [Domain!]
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "IPv4 addresses"
  ip: [IPAddress!]
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]
  "Remote Autonomous System Number (ASN)"
  remoteAsn: [Asn16!]
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  "Network subnets in CIDR notation"
  subnet: [NetworkSubnet!]
}

type InternetFirewallPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [InternetFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
}

input InternetFirewallPolicyInput {
  """
  A revision is a specific instance of the policy.
   Unpublished revisions are working copies of the policy available to a specific
   admin or a set of admins
   Published revisions are revisions that were applied to the account network.
   The last published revision is the active policy.
  """
  revision: PolicyRevisionInput
}

input InternetFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

"Internet Firewall policy information provided in the API response"
type InternetFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: InternetFirewallPolicy
  status: PolicyMutationStatus!
}

"The Internet firewall Policy information returned to the caller in the API response."
type InternetFirewallPolicyMutations {
  "Add a new rule to the Internet Firewall policy."
  addRule(input: InternetFirewallAddRuleInput!): InternetFirewallRuleMutationPayload!
  """
  Add a new section to the policy.
  First section behaves as follows:
  When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
  The first section containing the default system rules can be modified but not deleted.
  The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
  """
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload!
  "Create the policy revision. Create a new empty policy revision."
  createPolicyRevision(input: PolicyCreateRevisionInput!): InternetFirewallPolicyMutationPayload!
  "Discard the policy revision. All changes in this discarded revision are discarded, and the revision is deleted."
  discardPolicyRevision(input: PolicyDiscardRevisionInput): InternetFirewallPolicyMutationPayload!
  "Change the relative location of an existing rule within the Internet Firewall policy."
  moveRule(input: PolicyMoveRuleInput!): InternetFirewallRuleMutationPayload!
  """
  Move a section to a new position within the policy.
   The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
  """
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload!
  "Publish the policy revision. A published revision becomes the active policy, and its content is merged with all unpublished revisions for other admins."
  publishPolicyRevision(input: PolicyPublishRevisionInput): InternetFirewallPolicyMutationPayload!
  "Remove an existing rule from the Internet Firewall policy."
  removeRule(input: InternetFirewallRemoveRuleInput!): InternetFirewallRuleMutationPayload!
  "Delete an existing section. The first section in policy cannot be deleted."
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload!
  """
  Change the state of the policy, e.g. enable or disable the policy.
  Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
  """
  updatePolicy(input: InternetFirewallPolicyUpdateInput!): InternetFirewallPolicyMutationPayload!
  "Update an existing rule of the Internet Firewall policy."
  updateRule(input: InternetFirewallUpdateRuleInput!): InternetFirewallRuleMutationPayload!
  "Update policy section attributes"
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload!
}

type InternetFirewallPolicyQueries {
  policy(input: InternetFirewallPolicyInput): InternetFirewallPolicy!
  revisions: PolicyRevisionsPayload
}

input InternetFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input InternetFirewallRemoveRuleInput {
  id: ID!
}

type InternetFirewallRule implements IPolicyRule {
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum!
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum!
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRef!]!
  "Description for the rule"
  description: String!
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestination!
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRef!]!
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]!
  """
  TRUE = Rule is enabled 
   FALSE = Rule is disabled
  """
  enabled: Boolean!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleException!]!
  "Rule ID"
  id: ID!
  "Position / priority of rule"
  index: Int!
  "Name of the rule"
  name: String!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicySchedule!
  "Policy section where the rule is located"
  section: PolicySectionInfo!
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceType!
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSource!
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTracking!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
type InternetFirewallRuleException {
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum!
  "Source country matching criteria for the exception."
  country: [CountryRef!]!
  "Destination matching criteria for the exception."
  destination: InternetFirewallDestination!
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRef!]!
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]!
  "A unique name of the rule exception."
  name: String!
  "Destination service matching criteria for the exception."
  service: InternetFirewallServiceType!
  "Source traffic matching criteria for the exception."
  source: InternetFirewallSource!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
input InternetFirewallRuleExceptionInput {
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum! = ANY
  "Source country matching criteria for the exception."
  country: [CountryRefInput!]! = []
  "Destination matching criteria for the exception."
  destination: InternetFirewallDestinationInput! = {application: [], customApp: [], appCategory: [], customCategory: [], sanctionedAppsCategory: [], country: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: [], remoteAsn: [], container: [], containers: {fqdnContainer: [], ipAddressRangeContainer: []}}
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRefInput!]! = []
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]! = []
  "A unique name of the rule exception."
  name: String!
  "Destination service matching criteria for the exception."
  service: InternetFirewallServiceTypeInput! = {standard: [], custom: []}
  "Source traffic matching criteria for the exception."
  source: InternetFirewallSourceInput! = {ip: [], host: [], site: [], subnet: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
}

type InternetFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: InternetFirewallRulePayload
  status: PolicyMutationStatus!
}

"Internet Firewall policy information for a specific revision"
type InternetFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: InternetFirewallRule!
}

"Add the Service Type to which this Internet Firewall rule applies"
type InternetFirewallServiceType {
  custom: [CustomService!]!
  standard: [ServiceRef!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
input InternetFirewallServiceTypeInput {
  custom: [CustomServiceInput!]! = []
  standard: [ServiceRefInput!]! = []
}

"Add the Service Type to which this Internet Firewall rule applies"
input InternetFirewallServiceTypeUpdateInput {
  custom: [CustomServiceInput!]
  standard: [ServiceRefInput!]
}

"Returns the settings for Source of an Internet Firewall rule"
type InternetFirewallSource {
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRef!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "IPv4 address"
  ip: [IPAddress!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
}

"Input of the settings for Source of an Internet Firewall rule"
input InternetFirewallSourceInput {
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
}

"Input of the settings for Source of an Internet Firewall rule"
input InternetFirewallSourceUpdateInput {
  "Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP."
  floatingSubnet: [FloatingSubnetRefInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "IPv4 address"
  ip: [IPAddress!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
}

input InternetFirewallUpdateRuleDataInput {
  "The action applied by the Internet Firewall if the rule is matched"
  action: InternetFirewallActionEnum
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]
  description: String
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: InternetFirewallDestinationUpdateInput
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]
  enabled: Boolean
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [InternetFirewallRuleExceptionInput!]
  name: String
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleUpdateInput
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: InternetFirewallServiceTypeUpdateInput
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: InternetFirewallSourceUpdateInput
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingUpdateInput
}

input InternetFirewallUpdateRuleInput {
  id: ID!
  rule: InternetFirewallUpdateRuleDataInput!
}

"Enum for the type of time range a rule is active"
enum PolicyActiveOnEnum {
  ALWAYS
  CUSTOM_RECURRING
  CUSTOM_TIMEFRAME
  WORKING_HOURS
}

"Input for adding section info to a policy"
input PolicyAddSectionInfoInput {
  name: String!
}

"Input for adding a section to a policy"
input PolicyAddSectionInput {
  at: PolicySectionPositionInput!
  section: PolicyAddSectionInfoInput!
}

type PolicyAudit {
  publishedBy: String!
  publishedTime: DateTime!
}

input PolicyCreateRevisionInput {
  description: String! = ""
  name: String!
}

"Returns data for a custom recurring time range that a rule is active"
type PolicyCustomRecurring {
  days: [DayOfWeek!]!
  from: Time!
  to: Time!
}

"Input of data for a custom recurring time range that a rule is active"
input PolicyCustomRecurringInput {
  days: [DayOfWeek!]! = []
  from: Time!
  to: Time!
}

"Input of data for a custom recurring time range that a rule is active"
input PolicyCustomRecurringUpdateInput {
  days: [DayOfWeek!]
  from: Time
  to: Time
}

"Returns data for a custom one-time time range that a rule is active"
type PolicyCustomTimeframe {
  from: DateTime!
  to: DateTime!
}

"Input of data for a custom one-time time range that a rule is active"
input PolicyCustomTimeframeInput {
  from: DateTime!
  to: DateTime!
}

"Input of data for a custom one-time time range that a rule is active"
input PolicyCustomTimeframeUpdateInput {
  from: DateTime
  to: DateTime
}

"Discards unpublished revision for the policy and reverts to the settings for the published policy."
input PolicyDiscardRevisionInput {
  id: ID
}

type PolicyElementAudit {
  "The admin, or the API-key, that performed the last update"
  updatedBy: String!
  "The last date and time the rule was updated"
  updatedTime: DateTime!
}

"Attributes describing the rule state or type"
enum PolicyElementPropertiesEnum {
  "New (added) rule"
  ADDED
  """
  An object can not be moved, or referenced when moving other objects.
  However its properties and content can be modified.
  """
  ANCHORED
  "A rule locked for changes by other admins"
  LOCKED
  "A rule moved to a different position"
  MOVED
  "Removed (deleted) rule"
  REMOVED
  "A pre-defined (system) rule that cannot be modified or removed"
  SYSTEM
  "Updated (modified) existing rule"
  UPDATED
}

"Move the rule to a different position in the policy"
input PolicyMoveRuleInput {
  id: ID!
  to: PolicyRulePositionInput
}

"Input for moving a section within a policy"
input PolicyMoveSectionInput {
  id: ID!
  to: PolicySectionPositionInput
}

"""
The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.

## Policy Errors

### `ConcurrentPolicyPublish`
- **Error Message:** "Another policy is currently publishing"

### `PolicyRevisionMismatch`
- **Error Message:** "Revision is not owned by the admin"

### `PolicyRevisionNotFound`
- **Error Message:** "Revision was not found"

### `PolicyInvalidEntity`
- **Error Message:** "Invalid entity"

### `DuplicateRuleName`
- **Error Message:** "Rule with the same name already exists"

### `DuplicateSectionName`
- **Error Message:** "Section with the same name already exists"

### `PolicyFailure`
- **Error Message:** "Can’t publish policy due to an internal error. Please try again in a few minutes"


## Rule Errors

### `ruleIsLocked`
- **Error Message:** "Rule is locked by another revision"

### `ruleWasRemoved`
- **Error Message:** "Rule was already removed"

### `ruleNotExist`
- **Error Message:** "Rule does not exist"

### `ruleSectionNotExist`
- **Error Message:** "Section does not exist"

### `ruleSectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `rulePositionInvalid`
- **Error Message:** "Rule position is invalid"

### `ruleNameIsEmpty`
- **Error Message:** "Rule name can't be empty"

### `ruleNameAlreadyExists`
- **Error Message:** "Rule with the same name already exists"

### `ruleSystemModification`
- **Error Message:** "Can't modify a system rule"

### `ruleSystemMove`
- **Error Message:** "Can't add a rule above the system rules"

### `ruleHasInvalidEntity`
- **Error Message:** "Rule has an invalid entity"

### `failedValidatingRule`
- **Error Message:** "Something went wrong, couldn't validate rule"


## Section Errors

### `sectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `sectionSystemMove`
- **Error Message:** "Section with system rules cannot be moved or removed"

### `sectionNotExist`
- **Error Message:** "Section does not exist"

### `sectionPositionInvalid`
- **Error Message:** "Section position is invalid"
"""
type PolicyMutationError {
  errorCode: String
  errorMessage: String
}

input PolicyMutationRevisionInput {
  id: ID
}

"Enum for the status of a policy mutation"
enum PolicyMutationStatus {
  FAILURE
  SUCCESS
}

"Policies that can be configured with mutation APIs."
type PolicyMutations {
  internetFirewall(input: InternetFirewallPolicyMutationInput): InternetFirewallPolicyMutations
  wanFirewall(input: WanFirewallPolicyMutationInput): WanFirewallPolicyMutations
}

"""
Published revision is the active policy
applied on the traffic.
In addition, when a policy is published, revision changes become visible
to other admins, and rules locked by the revision become unlocked
"""
input PolicyPublishRevisionInput {
  description: String
  name: String
}

"policies which configuration can be read with query APIs."
type PolicyQueries {
  internetFirewall: InternetFirewallPolicyQueries
  wanFirewall: WanFirewallPolicyQueries
}

"Input for removing a section from a policy"
input PolicyRemoveSectionInput {
  id: ID!
}

"Returns data about the policy revision, such as when the change was made, how many rules were changed, etc."
type PolicyRevision {
  changes: Int!
  createdTime: DateTime!
  description: String!
  id: ID!
  name: String!
  updatedTime: DateTime!
}

"Input for specifying a policy revision"
input PolicyRevisionInput {
  id: ID
  type: PolicyRevisionType = PRIVATE
}

"Enum for the type of a policy revision"
enum PolicyRevisionType {
  PRIVATE
  PUBLIC
}

"Returns data for publishing the policy"
type PolicyRevisionsPayload {
  revision: [PolicyRevision!]!
}

"Enum for the position of a rule within a policy"
enum PolicyRulePositionEnum {
  "The rule position is after the pre-existing specified rule"
  AFTER_RULE
  "The rule position is before the pre-existing specified rule"
  BEFORE_RULE
  "The rule position is immediately after the system rules (first non-system rule)"
  FIRST_IN_POLICY
  "The rule position is first in the specified section"
  FIRST_IN_SECTION
  "The rule position is last in the policy"
  LAST_IN_POLICY
  "The rule position is last in the specified section"
  LAST_IN_SECTION
}

"Parameters required to define the rule position"
input PolicyRulePositionInput {
  "Position relative to a policy, a section or another rule"
  position: PolicyRulePositionEnum
  "The identifier of the object (e.g. a rule, a section) relative to which the position of the added rule is defined"
  ref: ID
}

"Returns data for the alert settings for the rule"
type PolicyRuleTrackingAlert {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean!
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum!
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRef!]!
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRef!]!
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRef!]!
}

"Input of data for the alert settings for the rule"
input PolicyRuleTrackingAlertInput {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean! = false
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum! = HOURLY
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRefInput!]! = []
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRefInput!]! = []
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRefInput!]! = []
}

"Input of data for the alert settings for the rule"
input PolicyRuleTrackingAlertUpdateInput {
  "TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched"
  enabled: Boolean
  "Returns data for the alert frequency"
  frequency: PolicyRuleTrackingFrequencyEnum
  "Returns data for the Mailing List that receives the alert"
  mailingList: [SubscriptionMailingListRefInput!]
  "Returns data for the Subscription Group that receives the alert"
  subscriptionGroup: [SubscriptionGroupRefInput!]
  "Returns data for the Webhook that receives the alert"
  webhook: [SubscriptionWebhookRefInput!]
}

"Returns data if an alert is sent for a rule"
type PolicyRuleTrackingEvent {
  enabled: Boolean!
}

"Input of data if an alert is sent for a rule"
input PolicyRuleTrackingEventInput {
  enabled: Boolean! = false
}

"Input of data if an alert is sent for a rule"
input PolicyRuleTrackingEventUpdateInput {
  enabled: Boolean
}

"Enum for the frequency of an alert event for a rule"
enum PolicyRuleTrackingFrequencyEnum {
  DAILY
  HOURLY
  IMMEDIATE
  WEEKLY
}

type PolicySchedule {
  activeOn: PolicyActiveOnEnum!
  customRecurring: PolicyCustomRecurring
  customTimeframe: PolicyCustomTimeframe
}

input PolicyScheduleInput {
  activeOn: PolicyActiveOnEnum! = ALWAYS
  customRecurring: PolicyCustomRecurringInput
  customTimeframe: PolicyCustomTimeframeInput
}

input PolicyScheduleUpdateInput {
  activeOn: PolicyActiveOnEnum
  customRecurring: PolicyCustomRecurringUpdateInput
  customTimeframe: PolicyCustomTimeframeUpdateInput
}

"Define settings for a policy section"
type PolicySectionInfo {
  id: ID!
  name: String!
}

type PolicySectionMutationPayload {
  errors: [PolicyMutationError!]!
  section: PolicySectionPayload
  status: PolicyMutationStatus!
}

type PolicySectionPayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  section: PolicySectionInfo!
}

enum PolicySectionPositionEnum {
  AFTER_SECTION
  BEFORE_SECTION
  LAST_IN_POLICY
}

input PolicySectionPositionInput {
  position: PolicySectionPositionEnum!
  ref: ID
}

"Enum for the state of a policy"
enum PolicyToggleState {
  DISABLED
  ENABLED
}

type PolicyTracking {
  alert: PolicyRuleTrackingAlert!
  event: PolicyRuleTrackingEvent!
}

input PolicyTrackingInput {
  alert: PolicyRuleTrackingAlertInput! = {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}
  event: PolicyRuleTrackingEventInput! = {enabled: false}
}

input PolicyTrackingUpdateInput {
  alert: PolicyRuleTrackingAlertUpdateInput
  event: PolicyRuleTrackingEventUpdateInput
}

input PolicyUpdateSectionInfoInput {
  name: String
}

input PolicyUpdateSectionInput {
  id: ID!
  section: PolicyUpdateSectionInfoInput!
}

enum WanFirewallActionEnum {
  "Allow the network traffic to pass through the firewall."
  ALLOW
  "Deny the network traffic from passing through the firewall."
  BLOCK
  "Requests user confirmation to allow or block network traffic."
  PROMPT
}

input WanFirewallAddRuleDataInput {
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum! = BLOCK
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplicationInput! = {application: [], appCategory: [], customApp: [], customCategory: [], sanctionedAppsCategory: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: []}
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum! = ANY
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]! = []
  description: String! = ""
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestinationInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]! = []
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]! = []
  direction: WanFirewallDirectionEnum! = TO
  enabled: Boolean!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleExceptionInput!]! = []
  name: String!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleInput! = {activeOn: ALWAYS}
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceTypeInput! = {standard: [], custom: []}
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSourceInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingInput! = {event: {enabled: false}, alert: {enabled: false, frequency: HOURLY, subscriptionGroup: [], webhook: [], mailingList: []}}
}

"Rule parameters and relevant position"
input WanFirewallAddRuleInput {
  "Position of the rule in the policy"
  at: PolicyRulePositionInput
  "Parameters for the rule you are adding"
  rule: WanFirewallAddRuleDataInput!
}

"Application match criteria set"
type WanFirewallApplication {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRef!]!
  "Applications for the rule (pre-defined)"
  application: [ApplicationRef!]!
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRef!]!
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRef!]!
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]!
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "IPv4 addresses"
  ip: [IPAddress!]!
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRange!]!
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
}

"Application match criteria set"
input WanFirewallApplicationInput {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]! = []
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]! = []
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]! = []
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]! = []
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]! = []
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "IPv4 addresses"
  ip: [IPAddress!]! = []
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]! = []
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
}

"Application match criteria set"
input WanFirewallApplicationUpdateInput {
  "Cato category of applications which are dynamically updated by Cato"
  appCategory: [ApplicationCategoryRefInput!]
  "Applications for the rule (pre-defined)"
  application: [ApplicationRefInput!]
  "Custom (user-defined) applications"
  customApp: [CustomApplicationRefInput!]
  "Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc."
  customCategory: [CustomCategoryRefInput!]
  """
  A Second-Level Domain (SLD).
  It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
  Example: example.com.
  """
  domain: [Domain!]
  "An exact match of the fully qualified domain (FQDN). Example: www.my.example.com."
  fqdn: [Fqdn!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "IPv4 addresses"
  ip: [IPAddress!]
  "A range of IPs. Every IP within the range will be matched"
  ipRange: [IpAddressRangeInput!]
  "Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization."
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
}

"Returns the settings for Destination of a Wan Firewall rule"
type WanFirewallDestination {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRef!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "IPv4 address"
  ip: [IPAddress!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
}

"Input of the settings for Destination of a Wan Firewall rule"
input WanFirewallDestinationInput {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
}

"Input of the settings for Destination of a Wan Firewall rule"
input WanFirewallDestinationUpdateInput {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "IPv4 address"
  ip: [IPAddress!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
}

enum WanFirewallDirectionEnum {
  BOTH
  TO
}

type WanFirewallPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [WanFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
}

input WanFirewallPolicyInput {
  """
  A revision is a specific instance of the policy.
   Unpublished revisions are working copies of the policy available to a specific
   admin or a set of admins
   Published revisions are revisions that were applied to the account network.
   The last published revision is the active policy.
  """
  revision: PolicyRevisionInput
}

input WanFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

"Wan Firewall policy information provided in the API response"
type WanFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: WanFirewallPolicy
  status: PolicyMutationStatus!
}

"The Wan Firewall Policy information returned to the caller in the API response."
type WanFirewallPolicyMutations {
  "Add a new rule to the Wan Firewall policy."
  addRule(input: WanFirewallAddRuleInput!): WanFirewallRuleMutationPayload!
  """
  Add a new section to the policy.
  First section behaves as follows:
  When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
  The first section containing the default system rules can be modified but not deleted.
  The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
  """
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload!
  createPolicyRevision(input: PolicyCreateRevisionInput!): WanFirewallPolicyMutationPayload!
  discardPolicyRevision(input: PolicyDiscardRevisionInput): WanFirewallPolicyMutationPayload!
  "Change the relative location of an existing rule within the Wan Firewall policy."
  moveRule(input: PolicyMoveRuleInput!): WanFirewallRuleMutationPayload!
  """
  Move a section to a new position within the policy.
   The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
  """
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload!
  publishPolicyRevision(input: PolicyPublishRevisionInput): WanFirewallPolicyMutationPayload!
  "Remove an existing rule from the Wan Firewall policy."
  removeRule(input: WanFirewallRemoveRuleInput!): WanFirewallRuleMutationPayload!
  "Delete an existing section. The first section in policy cannot be deleted."
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload!
  """
  Change the state of the policy, e.g. enable or disable the policy.
  Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
  """
  updatePolicy(input: WanFirewallPolicyUpdateInput!): WanFirewallPolicyMutationPayload!
  "Update an existing rule of the Wan Firewall policy."
  updateRule(input: WanFirewallUpdateRuleInput!): WanFirewallRuleMutationPayload!
  "Update policy section attributes"
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload!
}

type WanFirewallPolicyQueries {
  policy(input: WanFirewallPolicyInput): WanFirewallPolicy!
  revisions: PolicyRevisionsPayload
}

input WanFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input WanFirewallRemoveRuleInput {
  id: ID!
}

type WanFirewallRule implements IPolicyRule {
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum!
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplication!
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum!
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRef!]!
  "Description for the rule"
  description: String!
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestination!
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRef!]!
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]!
  direction: WanFirewallDirectionEnum!
  """
  TRUE = Rule is enabled 
   FALSE = Rule is disabled
  """
  enabled: Boolean!
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleException!]!
  "Rule ID"
  id: ID!
  "Position / priority of rule"
  index: Int!
  "Name of the rule"
  name: String!
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicySchedule!
  "Policy section where the rule is located"
  section: PolicySectionInfo!
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceType!
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSource!
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTracking!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
type WanFirewallRuleException {
  "Application matching criteria for the exception."
  application: WanFirewallApplication!
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum!
  "Source country matching criteria for the exception."
  country: [CountryRef!]!
  "Destination matching criteria for the exception."
  destination: WanFirewallDestination!
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRef!]!
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]!
  "Direction origin matching criteria for the exception"
  direction: WanFirewallDirectionEnum!
  "A unique name of the rule exception."
  name: String!
  "Destination service matching criteria for the exception."
  service: WanFirewallServiceType!
  "Source matching criteria for the exception."
  source: WanFirewallSource!
}

"Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules."
input WanFirewallRuleExceptionInput {
  "Application matching criteria for the exception."
  application: WanFirewallApplicationInput! = {application: [], appCategory: [], customApp: [], customCategory: [], sanctionedAppsCategory: [], domain: [], fqdn: [], ip: [], subnet: [], ipRange: [], globalIpRange: []}
  "Connection origin matching criteria for the exception."
  connectionOrigin: ConnectionOriginEnum! = ANY
  "Source country matching criteria for the exception."
  country: [CountryRefInput!]! = []
  "Destination matching criteria for the exception."
  destination: WanFirewallDestinationInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
  "Source Device Profile matching criteria for the exception."
  device: [DeviceProfileRefInput!]! = []
  "Source device OS matching criteria for the exception."
  deviceOS: [OperatingSystem!]! = []
  "Direction origin matching criteria for the exception"
  direction: WanFirewallDirectionEnum! = TO
  "A unique name of the rule exception."
  name: String!
  "Destination service matching criteria for the exception."
  service: WanFirewallServiceTypeInput! = {standard: [], custom: []}
  "Source matching criteria for the exception."
  source: WanFirewallSourceInput! = {host: [], site: [], subnet: [], ip: [], ipRange: [], globalIpRange: [], networkInterface: [], siteNetworkSubnet: [], floatingSubnet: [], user: [], usersGroup: [], group: [], systemGroup: []}
}

type WanFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: WanFirewallRulePayload
  status: PolicyMutationStatus!
}

"Wan Firewall policy information for a specific revision"
type WanFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: WanFirewallRule!
}

"Add the Service Type to which this Internet Firewall rule applies"
type WanFirewallServiceType {
  custom: [CustomService!]!
  standard: [ServiceRef!]!
}

"Add the Service Type to which this Internet Firewall rule applies"
input WanFirewallServiceTypeInput {
  custom: [CustomServiceInput!]! = []
  standard: [ServiceRefInput!]! = []
}

"Add the Service Type to which this Internet Firewall rule applies"
input WanFirewallServiceTypeUpdateInput {
  custom: [CustomServiceInput!]
  standard: [ServiceRefInput!]
}

"Returns the settings for Source of an Wan Firewall rule"
type WanFirewallSource {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRef!]!
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRef!]!
  "Groups defined for your account"
  group: [GroupRef!]!
  "Hosts and servers defined for your account"
  host: [HostRef!]!
  "IPv4 address"
  ip: [IPAddress!]!
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRange!]!
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRef!]!
  "Site defined for the account"
  site: [SiteRef!]!
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]!
  "Predefined Cato groups"
  systemGroup: [SystemGroupRef!]!
  "Individual users defined for the account"
  user: [UserRef!]!
  "Group of users"
  usersGroup: [UsersGroupRef!]!
}

"Input of the settings for Source of an Wan Firewall rule"
input WanFirewallSourceInput {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  "Groups defined for your account"
  group: [GroupRefInput!]! = []
  "Hosts and servers defined for your account"
  host: [HostRefInput!]! = []
  "IPv4 address"
  ip: [IPAddress!]! = []
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]! = []
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]! = []
  "Site defined for the account"
  site: [SiteRefInput!]! = []
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]! = []
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]! = []
  "Individual users defined for the account"
  user: [UserRefInput!]! = []
  "Group of users"
  usersGroup: [UsersGroupRefInput!]! = []
}

"Input of the settings for Source of an Wan Firewall rule"
input WanFirewallSourceUpdateInput {
  """
  Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
  They are not associated with a specific site.
  This is useful in scenarios such as active-standby high availability routed via BGP.
  """
  floatingSubnet: [FloatingSubnetRefInput!]
  "Globally defined IP range, IP and subnet objects"
  globalIpRange: [GlobalIpRangeRefInput!]
  "Groups defined for your account"
  group: [GroupRefInput!]
  "Hosts and servers defined for your account"
  host: [HostRefInput!]
  "IPv4 address"
  ip: [IPAddress!]
  "Multiple separate IP addresses or an IP range"
  ipRange: [IpAddressRangeInput!]
  "Network range defined for a site"
  networkInterface: [NetworkInterfaceRefInput!]
  "Site defined for the account"
  site: [SiteRefInput!]
  "GlobalRange + InterfaceSubnet"
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  "Subnets and network ranges defined for the LAN interfaces of a site"
  subnet: [NetworkSubnet!]
  "Predefined Cato groups"
  systemGroup: [SystemGroupRefInput!]
  "Individual users defined for the account"
  user: [UserRefInput!]
  "Group of users"
  usersGroup: [UsersGroupRefInput!]
}

input WanFirewallUpdateRuleDataInput {
  "The action applied by the Internet Firewall if the rule is matched"
  action: WanFirewallActionEnum
  """
  Application traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  application: WanFirewallApplicationUpdateInput
  "Connection origin of the traffic"
  connectionOrigin: ConnectionOriginEnum
  """
  Source country traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  country: [CountryRefInput!]
  description: String
  """
  Destination traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  destination: WanFirewallDestinationUpdateInput
  """
  Source Device Profile traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  device: [DeviceProfileRefInput!]
  """
  Source device Operating System traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  deviceOS: [OperatingSystem!]
  direction: WanFirewallDirectionEnum
  enabled: Boolean
  """
  The set of exceptions for the rule.
  Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
  """
  exceptions: [WanFirewallRuleExceptionInput!]
  name: String
  "The time period specifying when the rule is enabled, otherwise it is disabled."
  schedule: PolicyScheduleUpdateInput
  """
  Destination service traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  service: WanFirewallServiceTypeUpdateInput
  """
  Source traffic matching criteria.
  Logical ‘OR’ is applied within the criteria set.
  Logical ‘AND’ is applied between criteria sets.
  """
  source: WanFirewallSourceUpdateInput
  "Tracking information when the rule is matched, such as events and notifications"
  tracking: PolicyTrackingUpdateInput
}

input WanFirewallUpdateRuleInput {
  id: ID!
  rule: WanFirewallUpdateRuleDataInput!
}

type AccountMetrics {
  """Starting time"""
  from: DateTime
  """The size of a single time bucket in seconds"""
  granularity: Int
  """Unique Identifier of Account."""
  id: ID
  """Site connectivity metrics for the requested sites."""
  sites(
    """
    A list of unique IDs for each site. If specified, only sites in this list are returned. Otherwise, all sites are returned.
    """
    siteIDs: [ID!]
    ids: [String!] @deprecated(reason: "by siteIDs")
  ): [SiteMetrics!]
  timeseries(
    labels: [TimeseriesMetricType!]
    "number of buckets, defaults to 10, max 1000"
    buckets: Int
  ): [Timeseries!]
  """Ending time"""
  to: DateTime
  """
  Connectivity metrics for the requested users connecting remotely with the Client.
  Doesn’t include user traffic behind a site.
  """
  users(
    """
    A list of unique IDs for each user. If specified, only users in this list are returned. Otherwise, no user metrics are returned.
    """
    userIDs: [ID!]
  ): [SiteMetrics!]
}

type AccountSnapshot {
  """Unique Identifier of Account"""
  id: ID
  "Sites includes information about online as well as offline sites"
  sites(
    """
    List of Unique Site Identifiers. If specified, only sites in list will be returned
    """
    siteIDs: [ID!]
    ids: [Int!] @deprecated(reason: "by siteIDs")
  ): [SiteSnapshot!]
  timestamp: DateTime
  "VPN users information includes only connected users by default (Unlike sites), unless specific ID is requested"
  users(
    "request specific IDs, regardless of if connected or not"
    userIDs: [ID!]
    ids: [Int!] @deprecated(reason: "by userIDs")
  ): [UserSnapshot!]
}

"""A general structure to contain IP detailed information"""
type IPInfo {
  """Geolocation city"""
  city: String
  """Geolocation ISO country code"""
  countryCode: String
  """Geolocation country name"""
  countryName: String
  """IP address of the link"""
  ip: String
  """Geolocation latitude for the ISP"""
  latitude: Float
  """Geolocation longitude for the ISP"""
  longitude: Float
  """ISP Internet provider"""
  provider: String
  """Geolocation state"""
  state: String
}

"""Basic information about socket"""
type SocketInfo {
  """Unique ID for Socket"""
  id: String
  """
  For HA configurations, when this boolean value is true, this the primary Socket
  """
  isPrimary: Boolean
  """Shows Socket type"""
  platform: SocketPlatform
  """Serial number for the Socket"""
  serial: String
  """Software version number that is currently installed on the Socket"""
  version: String
  """Timestamp when the Socket upgraded to the current hardware version"""
  versionUpdateTime: DateTime
}

"""Basic IPSec configuration information"""
type IPSecInfo {
  """The source IP address for the IPsec tunnel in the Cato Cloud"""
  catoIP: String
  """Shows 1 for IKEv1 and 2 for IKEv2"""
  ikeVersion: Int
  """
  For HA configurations, when this boolean value is true, this the primary IPsec firewall or routing device
  """
  isPrimary: Boolean
  """The destination IP address for the IPsec tunnel (in the site)"""
  remoteIP: String
}

"""Basic Socket Interface configuration information"""
type InterfaceInfo {
  """The destination type configured to the Socket interface"""
  destType: String
  """
  Maximum allowed bandwidth for traffic on this port, from the Cato Cloud to the site
  """
  downstreamBandwidth: Int
  """ID for the Socket port in the Socket WebUI Monitor tab"""
  id: ID!
  """Name for the port in the Cato Management Application"""
  name: String
  """
  Maximum allowed bandwidth on this port, for traffic from the site to the Cato Cloud
  """
  upstreamBandwidth: Int
}

"""Basic Site configuration information"""
type SiteInfo {
  """City of the physical site location"""
  cityName: String
  """
  The Connection Type field defines how the site connects to the Cato Cloud, such as X1500 Socket or AWS vSocket (array with nested fields)
  """
  connType: ProtoType
  """Code for the Country that is the physical location of the site"""
  countryCode: String
  """Country that is the physical location of the site"""
  countryName: String
  """State of the country that is the physical site location"""
  countryStateName: String
  """Timestamp for when the site was created"""
  creationTime: DateTime
  """User defined description of the site"""
  description: String
  """Basic configuration information about the Socket interface"""
  interfaces: [InterfaceInfo!]
  """data related to IPsec sites, such as IKE version"""
  ipsec: [IPSecInfo!]
  """
  When this boolean value is true, the site is enabled for high availability
  """
  isHA: Boolean
  """Name for the site"""
  name: String
  """Geographical PoP region that the site is licensed to use"""
  region: String
  """
  Data related to Socket and vSocket sites, such as serial number and Socket version (array with nested fields)
  """
  sockets: [SocketInfo!]
  """
  Site type in the Cato Management Application, such as branch office or datacenter
  """
  type: SiteType
}

"""Basic Site Ha readiness information"""
type HaStatus {
  keepalive: HaSubStatus
  readiness: HaReadiness
  socketVersion: HaSubStatus
  wanConnectivity: HaSubStatus
}

"Basic User configuration information"
type UserInfo {
  "Additional authentication mechanism, currently MFA or NONE"
  authMethod: String
  """Timestamp when the VPN user was created in the account"""
  creationTime: DateTime
  """Email address of the VPN user"""
  email: String
  """Name of the VPN user"""
  name: String
  "User creation mechanism, current supported REGULAR or LDAP"
  origin: String
  """Phone number for the VPN user"""
  phoneNumber: String
  """Status of the Client as the type STRING"""
  status: OperationalStatus
}

type RecentConnection {
  """Serial number for the Device"""
  deviceName: String
  "The duration of the connection"
  duration: Int
  """Name for the port in the Cato Management Application"""
  interfaceName: String
  "The last time this connection was detected (so lastConnected - duration is the start of the connection"
  lastConnected: DateTime
  "The name of the PoP that the traffic flow was connected to"
  popName: String
  """IP address the ISP allocates to the WAN link"""
  remoteIP: String
  """
  IP address, ISP, and geographical information related to the PoP that the traffic flow was connected to
  """
  remoteIPInfo: IPInfo
}

type InterfaceLinkState {
  """Shows the duplex mode for the link"""
  duplex: String
  """The ID for the specific Socket port, for example LAN1 or LAN2"""
  id: ID
  """Shows the maximum bandwidth configured for the link"""
  linkSpeed: String
  """
  When this boolean value is true, then a cable is connected to the Socket port
  """
  mediaIn: Boolean
  """When this boolean value is true, then the link for the port is up"""
  up: Boolean
}

type DeviceSnapshot {
  """
  A boolean value that indicates if the site is connected to the Cato Cloud
  """
  connected: Boolean
  """For connected devices (this somewhat overlaps to last duration)"""
  connectedSince: DateTime
  """
  Shows if this is the primary or secondary Socket in high availability mode
  """
  haRole: String
  """Unique internal Cato ID for the Socket"""
  id: ID
  """Unique identifier for the device"""
  identifier: String
  """Snapshot data for outbound facing interfaces"""
  interfaces: [InterfaceSnapshot!]
  """
  Information of the link state of various interfaces in the devices. Unlike the `interfacess` field, it contains
     all links of the device, not just the outbound facing ones
  """
  interfacesLinkState: [InterfaceLinkState!]
  """Device's internal IP in the account's routing table"""
  internalIP: String
  """The last time the device was seen"""
  lastConnected: DateTime
  """
  The uptime of the last tunnel from this device (or current), in seconds
  """
  lastDuration: Int
  """The ID of the PoP that the Socket is connected to"""
  lastPopID: Int
  """The PoP name that the Socket is connected to"""
  lastPopName: String
  """The time the mfa cookie (for sdp users) was created"""
  mfaCreationTime: Int
  """Shows the amount of time remaining before the MFA token expires"""
  mfaExpirationTime: Int
  """Name of the device"""
  name: String
  """Operating system of the Device."""
  osType: String
  """Version of the Socket operating system"""
  osVersion: String
  """Data related to the most recent completed traffic flows"""
  recentConnections: [RecentConnection!]
  """Shows the release group for the site"""
  releaseGroup: String
  """Shows data related to the Socket, such as version and serial number"""
  socketInfo: SocketInfo
  """Shows the Socket model or vSocket type"""
  type: String
  """Device version"""
  version: String
  """Device major version"""
  versionNumber: Int
}

type InterfaceMetrics {
  """Time stamp annotation that shows a time increment for a GUI"""
  annotations(types: [String!]): [TimeAnnotation!]
  """
  Basic configuration information about the Socket interface . Applicable only for site
  """
  interfaceInfo: InterfaceInfo
  """
  Data related to IPsec sites, such as IKE version . Applicable only for site
  """
  ipsecInfo: IPSecInfo
  """Traffic data for the link"""
  metrics(
    "Normalize collected metrics as per-second values"
    toRate: Boolean = false
  ): Metrics
  """Link name in the Cato Management Application"""
  name: String
  """object that is a specific time duration"""
  periods: [TimePeriod!]
  """IP address the ISP allocates to the WAN link"""
  remoteIP: String
  """Data related to the link IP address, such as country code"""
  remoteIPInfo: IPInfo
  """
  Data related to Socket and vSocket sites, such as serial number and Socket version. Applicable only for site
  """
  socketInfo: SocketInfo
  """
  For site metrics, timeseries info field will include: siteID, interfaceName, for last mile metrics it will also
  include the destination last mile check
  """
  timeseries(buckets: Int, labels: [TimeseriesMetricType!]): [Timeseries!]
}

type InterfaceSnapshot {
  """Information about cellular (LTE) interface"""
  cellularInterfaceInfo: CellularInterface
  """Shows if the WAN link is connected to the PoP"""
  connected: Boolean
  """Interface ID for the WAN link"""
  id: ID
  """
  data about the WAN link that is configured in the Socket Configuration window for the site
  """
  info: InterfaceInfo
  """WAN link name in the Cato Management Application"""
  name: String
  """Interface Natural order for WAN link"""
  naturalOrder: Int
  """Physical WAN port on the Socket"""
  physicalPort: Int
  """The name of the PoP that the WAN link is connected to"""
  popName: String
  """
  The ID of the PoP that the WAN link was connected to before the current one
  """
  previousPopID: Int
  """
  The name of the PoP that the WAN link was connected to before the current one
  """
  previousPopName: String
  """
  Reason that the tunnel required a new connection (for example, PoP or Socket restarted)
  """
  tunnelConnectionReason: String
  """IP address of the WAN ISP"""
  tunnelRemoteIP: String
  """IP address, ISP, and geographical information related to the WAN ISP"""
  tunnelRemoteIPInfo: IPInfo
  """Number of seconds that the tunnel is connected to a PoP"""
  tunnelUptime: Int
  type: String @deprecated(reason: "No longer supported")
}

type Metrics {
  """total downstream traffic (from the Cato Cloud to the site)"""
  bytesDownstream: Float
  """total traffic for the site"""
  bytesTotal: Float
  """total upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstream: Float
  """total amount of time for the site data"""
  duration: Int
  """
  The number of flows (connections) in the tunnel. Relevant only for per site Metrics, ignored in per-interface
  metrics.
  """
  flowCount: Float
  """duration in seconds for a single metrics bucket"""
  granularity: Int
  """
  The number of hosts in the tunnel. Relevant only for per site Metrics, ignored in per-interface metrics.
  """
  hostCount: Float
  """
  The configurable limit of the number of hosts in the tunnel. Relevant only for per site Metrics, ignored in
  per-interface metrics.
  """
  hostLimit: Float
  """
  jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterDownstream: Float
  """
  jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterUpstream: Float
  """number of packets lost for downstream traffic"""
  lostDownstream: Float
  """percent of packet loss for downstream traffic"""
  lostDownstreamPcnt: Float
  """number of packets lost for upstream traffic"""
  lostUpstream: Float
  """percent of packet loss for upstream traffic"""
  lostUpstreamPcnt: Float
  """total packets discarded for downstream traffic"""
  packetsDiscardedDownstream: Float
  """total packets discarded for upstream traffic"""
  packetsDiscardedUpstream: Float
  """total downstream packets"""
  packetsDownstream: Float
  """total upstream packets"""
  packetsUpstream: Float
  """round-trip time from the site to the Cato Cloud"""
  rtt: Int
}

type CellularInterface {
  """
  Represents the Access Point Name (e.g., uwap.orange.co.il). Configurable from Socket WebUI or SIM switch.
  """
  apn: String
  """
  Determines how the APN is selected. Valid values are Auto or Manual (configurable in WebUI).
  """
  apnSelectionMethod: ApnMethod
  """
  Displays the reason for the modem disconnecting. Valid values are 0 (No reason provided) or 1 (The session timed out).
  """
  disconnectionReason: CellularDisconnectionReason
  """Unique identifier (20-digit number) for the modem."""
  iccid: String
  """Unique identifier (15-digit number) for a specific SIM."""
  imei: String
  """
  Indicates if the cellular modem is currently connected to the internet.
  """
  isModemConnected: Boolean!
  """Indicates if the modem is currently suspended."""
  isModemSuspended: Boolean!
  """Indicates whether roaming is enabled."""
  isRoamingAllowed: Boolean!
  """Indicates whether a SIM is detected in the first slot."""
  isSimSlot1Detected: Boolean!
  """Indicates whether a SIM is detected in the second slot."""
  isSimSlot2Detected: Boolean!
  """
  Represents the current status of the modem. Valid values are Error, OK, or Unknown.
  """
  modemStatus: CellularModemStatus
  """2G, 3G, or 4G"""
  networkType: CellularNetworkType
  """Displays the operator or carrier name, such as Verizon."""
  operatorName: String
  """
  Represents the signal strength of the cellular connection, in units of calculation.
  """
  signalStrength: String
  """The phone number associated with the SIM."""
  simNumber: String
  """
  Shows the currently active SIM slot; the other slot is in standby. Slot 1 is active by default.
  """
  simSlotId: Int
}

enum CellularNetworkType {
  TYPE_2G
  TYPE_3G
  TYPE_4G
  TYPE_UNKNOWN
}

enum CellularModemStatus {
  STATUS_ERROR
  STATUS_OK
  STATUS_UNKNOWN
}

enum CellularDisconnectionReason {
  REASON_NONE
  REASON_TIMEOUT
}

enum ApnMethod {
  METHOD_AUTO
  METHOD_MANUAL
  METHOD_UNKNOWN
}

type SiteMetrics {
  """
  Timeseries with the number of flows (connections) in the site. Applicable only for site
  """
  flowCount: Timeseries
  """
  Timeseries with the number of hosts in the site. Applicable only for site
  """
  hostCount: Timeseries
  """
  Timeseries with the configurable limit of the number of hosts in the site. Applicable only for site
  """
  hostLimit: Timeseries
  """Site ID"""
  id: ID
  """
  Shows general information about the site (array with nested fields). Applicable only for site
  """
  info: SiteInfo
  """Analytics that are returned for the links for a site"""
  interfaces: [InterfaceMetrics!]
  """Traffic metrics and data for sites"""
  metrics(
    "Normalize collected metrics as per-second values"
    toRate: Boolean = false
  ): Metrics
  """Site names"""
  name: String
  samples: Int @deprecated(reason: "internal use")
}

enum HaReadiness {
  not_ready
  ready
}

enum HaSubStatus {
  fail
  ok
}

enum ConnectivityStatus {
  """Connected to the Cato Cloud"""
  connected
  """Disconnected from the Cato Cloud"""
  disconnected
}

enum OperationalStatus {
  """Passing traffic"""
  active
  """Disabled in the Cato Management Application"""
  disabled
  """License has expired for this site and you can't configure it"""
  locked
  """After you create the site before it is connected to the Cato Cloud"""
  new
  "For VPN users only"
  pending_code_generation
  "For VPN users only"
  pending_mfa_configuration
  "For VPN users only"
  pending_user_configuration
}

type UserSnapshot {
  """
  In this state the client does not create its own connection, but reuses
  the Office's socket connection
  """
  connectedInOffice: Boolean
  """Connectivity to the Cato Cloud"""
  connectivityStatus: ConnectivityStatus
  "The host name of the device"
  deviceName: String
  """Data related to the Client"""
  devices: [DeviceSnapshot!]
  """VPN user ID"""
  id: ID
  """General information about the VPN user"""
  info: UserInfo
  """IP address of the PoP that the Client is connected to"""
  internalIP: String
  "Last time the user was connected (relevant if not currently connected)"
  lastConnected: DateTime
  "User name from configuration, same as info.name"
  name: String
  """Status for a site or VPN user"""
  operationalStatus: OperationalStatus
  """Operating system of the device the Client is running on"""
  osType: String
  """Version of the operating system for the device"""
  osVersion: String
  """ID of the PoP that the Client is connected to"""
  popID: Int
  """Name of the PoP that the VPN user is connected to"""
  popName: String
  """Data related to the most recent completed VPN connections"""
  recentConnections: [RecentConnection!]
  """IP address of the Client"""
  remoteIP: String
  """IP address, ISP, and geographical information related to the Client"""
  remoteIPInfo: IPInfo
  "How long has the user been connected (in seconds)"
  uptime: Int
  "VPN client version string"
  version: String
  "VPN client version number"
  versionNumber: Int
}

type SiteSnapshot {
  """Alternative WAN connectivity status"""
  altWanStatus: String
  """For connected sites, since when are they connected"""
  connectedSince: DateTime
  """Connectivity to the Cato Cloud"""
  connectivityStatus: ConnectivityStatus
  """Data related to the Sockets for a site"""
  devices: [DeviceSnapshot!]
  """Site HA readiness information"""
  haStatus: HaStatus
  """Number of hosts connected to a site"""
  hostCount: Int
  """site ID"""
  id: ID
  """General real-time information about the site"""
  info: SiteInfo
  """
  Relevant when the site is disconnected - the last time the device was connected
  """
  lastConnected: DateTime
  """Status for a site or VPN user"""
  operationalStatus: OperationalStatus
  """Name of the PoP that the site is connected to"""
  popName: String
  protoId: ID
}

type Timeseries {
  """
  Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
  milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
  """
  data(
    "whether to normalize the data into per second (i.e. divide by granularity)"
    perSecond: Boolean = true
    "If false, the data field will be set to '0' for buckets with no reported data. Otherwise it will be set to -1"
    withMissingData: Boolean = false
  ): [[Float!]]
  "List of dimension values for this timeseries"
  dimensions: [DimensionData!]
  """
  Specific information about the timeseries, used to build its name, title etc
  """
  info: [String!]
  "Timeseries key: measure and dimension values"
  key: TimeseriesKey
  "Indicates the type of the timeseries"
  label: String!
  """Summary of the metrics over the given time frame"""
  sum: Float
  """
  Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
  of data to make sense.
  """
  units: UnitType
}

"""An object for marking specific events in time."""
type TimeAnnotation {
  """Description of the event"""
  label: String!
  """Brief description of the event"""
  shortLabel: String!
  """Timestamp of the event"""
  time: Float!
  """
  Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
  charts to attach to it.
  """
  type: AnnotationType!
}

"""An object for marking durations!"""
type TimePeriod {
  """
  An tuple of two numbers representing  start time, end time in ms since epoch, start bucket index, end bucket index
  """
  duration: [Float!]!
  """Label that describes the metrics"""
  title: String!
  """
  Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
  charts to attach to it.
  """
  type: PeriodType!
}

enum TimeseriesMetricType {
  """Total avg downstream traffic (from the Cato Cloud to the site)"""
  bytesDownstream
  """Total max downstream traffic (from the site to the Cato Cloud)"""
  bytesDownstreamMax
  """Total number of bytes of upstream and downstream traffic"""
  bytesTotal
  """Total avg upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstream
  """Total max upstream traffic (from the site to the Cato Cloud)"""
  bytesUpstreamMax
  """Health analytics for the site"""
  health @deprecated(reason: "No longer supported")
  """
  Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterDownstream
  """
  Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
  """
  jitterUpstream
  """
  Latency from socket directly to a well known global service, not through Cato. This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMileLatency
  """
  Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMilePacketLoss
  """Number of packets lost for downstream traffic"""
  lostDownstream
  """Percent of packet loss for downstream traffic"""
  lostDownstreamPcnt
  """Number of packets lost for upstream traffic"""
  lostUpstream
  """Percent of packet loss for upstream traffic"""
  lostUpstreamPcnt
  """Total packets discarded for downstream traffic"""
  packetsDiscardedDownstream
  """Percent packets discarded for downstream traffic"""
  packetsDiscardedDownstreamPcnt
  """Total packets discarded for upstream traffic"""
  packetsDiscardedUpstream
  """Percent packets discarded for upstream traffic"""
  packetsDiscardedUpstreamPcnt
  """Total downstream packets"""
  packetsDownstream
  """Total upstream packets"""
  packetsUpstream
  """Round-trip time from the Socket to the Cato Cloud"""
  rtt
  "The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)"
  tunnelAge
}

enum PeriodType {
  "traffic was seen"
  active
  "some packets were discarded after queue timeout"
  congested
  "unspecified period type"
  generic
  "multiple last mile destinations measured large latency (greater than 500ms)"
  lastmileLatency
  "multiple last mile destinations measured packet loss"
  lastmilePacketLoss
  "missing data"
  missingData
  "some packets were queued"
  overlowed
  "packet loss connectivity issue"
  packetLoss
  "interface in standby mode"
  passiveLink
  "period connected to specific pop instance"
  pop
}

enum AnnotationType {
  """Other events that are included in annotations"""
  generic
  """The site connects to a different PoP"""
  popChange
  """The ISP IP address (remote IP) changed"""
  remoteIPChange
  """Change for HA status role"""
  roleChange
}

type DimensionData {
  "Type of the dimension"
  label: String!
  "String value of the dimension"
  value: String
}

type TimeseriesKey {
  "List of dimension key-value pair for this timeseries key"
  dimensions: [DimensionKey!]
  "Measure field"
  measureFieldName: String!
}

type DimensionKey {
  "Dimension field"
  fieldName: String!
  "String value of the dimension"
  value: String
}

type EventRecord {
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
  time: DateTime
}

type EventsFeedAccountRecords {
  errorString: String
  id: ID
  records(fieldNames: [EventFieldName!]): [EventRecord!]
}

type EventsFeedData {
  accounts: [EventsFeedAccountRecords]
  fetchedCount: Int!
  marker: String
}

input EventFeedFieldFilterInput {
  fieldName: EventFeedFilterFieldName!
  "Use event_type and event_sub_type for events"
  operator: EventFeedFilterOperator!
  values: [String!]
}

"""Search operators on Event Feed"""
enum EventFeedFilterOperator {
  in
  is
  is_not
  not_in
}

enum EventFeedFilterFieldName {
  "Sub-type for Routing, Security, Connectivity, System or Sockets Management event"
  event_sub_type
  "Routing, Security, Connectivity, System or Sockets Management event"
  event_type
}

input AddIpsecIkeV2SiteInput {
  description: String
  """The name of the site"""
  name: String!
  """The native range of the site"""
  nativeNetworkRange: IPSubnet!
  """The location of the site"""
  siteLocation: AddSiteLocationInput!
  """Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER."""
  siteType: SiteType! = BRANCH
}

input UpdateIpsecIkeV2SiteGeneralDetailsInput {
  """The auth message parameters."""
  authMessage: IpsecIkeV2MessageInput
  """
  Determines the protocol for establishing the Security Association (SA) Tunnel. Valid values are:
  Responder-Only Mode: Cato Cloud only responds to incoming requests by the initiator (e.g. a Firewall device) to establish a security association.
  Bidirectional Mode: Both Cato Cloud and the peer device on customer site can initiate the IPSec SA establishment.
  """
  connectionMode: ConnectionMode
  """
  The authentication identification type used for SA authentication. When using “BIDIRECTIONAL”, it is set to “IPv4” by default. Other methods are available in Responder mode only.
  """
  identificationType: IdentificationType
  """The init message parameters"""
  initMessage: IpsecIkeV2MessageInput
  """The local IP ranges for the SAs"""
  networkRanges: [IPSubnet]
}

input IpsecIkeV2MessageInput {
  """
  The SA tunnel encryption method. Note: For situations where GCM isn’t supported for the INIT phase, we recommend that you use the CBC algorithm for the INIT phase, and GCM for AUTH
  """
  cipher: IpSecCipher
  """
  The Diffie-Hellman Group. The first number is the DH-group number, and the second number is the corresponding prime modulus size in bits
  """
  dhGroup: IpSecDHGroup
  """
  The algorithm used to verify the integrity and authenticity of IPsec packets
  """
  integrity: IpSecHash
  """
  The Pseudo-random function (PRF) used to derive the cryptographic keys used in the SA establishment process
  """
  prf: IpSecHash
}

input LastMileBwInput {
  """
  The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
  """
  downstream: Int
  """
  The maximum upstream bandwidth, in Mbps. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
  """
  upstream: Int
}

input AddIpsecIkeV2TunnelInput {
  """
  The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
  """
  lastMileBw: LastMileBwInput
  """
  Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateCatoIp: IPAddress
  """
  Site private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateSiteIp: IPAddress
  """Pre-shared key. This field is write-only."""
  psk: String!
  """The public IP address where the IPsec tunnel is initiated"""
  publicSiteIp: IPAddress
}

input UpdateIpsecIkeV2TunnelInput {
  """
  The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
  """
  lastMileBw: LastMileBwInput
  """
  Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateCatoIp: IPAddress
  """
  Site private IP, used for BGP routing. Applicable for sites using BGP only
  """
  privateSiteIp: IPAddress
  """Pre-shared key. This field is write-only."""
  psk: String
  """The public IP address where the IPsec tunnel is initiated"""
  publicSiteIp: IPAddress
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId!
}

input UpdateIpsecIkeV2TunnelsInput {
  """The destination type of the IPsec tunnel"""
  destinationType: DestinationType
  """The PoP location ID"""
  popLocationId: ID
  """
  The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
  """
  publicCatoIpId: ID
  tunnels: [UpdateIpsecIkeV2TunnelInput!]!
}

input AddIpsecIkeV2TunnelsInput {
  """The destination type of the IPsec tunnel"""
  destinationType: DestinationType
  """The PoP location ID"""
  popLocationId: ID
  """
  The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
  """
  publicCatoIpId: ID
  tunnels: [AddIpsecIkeV2TunnelInput!]!
}

input UpdateIpsecIkeV2SiteTunnelsInput {
  """The configuration of the site’s primary tunnel"""
  primary: UpdateIpsecIkeV2TunnelsInput
  """The configuration of the site’s secondary tunnel"""
  secondary: UpdateIpsecIkeV2TunnelsInput
}

input AddIpsecIkeV2SiteTunnelsInput {
  """The configuration of the site’s primary tunnel"""
  primary: AddIpsecIkeV2TunnelsInput
  """The configuration of the site’s secondary tunnel"""
  secondary: AddIpsecIkeV2TunnelsInput
}

type AddIpsecIkeV2SitePayload {
  """The ID of the site"""
  siteId: ID!
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload {
  """The local ID for the site"""
  localId: String
  """The ID of the site"""
  siteId: ID!
}

type UpdateIpsecIkeV2SiteTunnelPayload {
  """The local ID for the tunnel"""
  localId: String
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload {
  """Cato’s FQDN for the multi-tunnel"""
  fqdn: Fqdn
  tunnels: [UpdateIpsecIkeV2SiteTunnelPayload!]!
}

type AddIpsecIkeV2SiteTunnelPayload {
  """The local ID for the tunnel"""
  localId: String
  """The ID of the tunnel"""
  tunnelId: IPSecV2InterfaceId
}

type AddIpsecIkeV2SiteMultiTunnelPayload {
  """Cato’s FQDN for the multi-tunnel"""
  fqdn: Fqdn
  tunnels: [AddIpsecIkeV2SiteTunnelPayload!]!
}

type UpdateIpsecIkeV2SiteTunnelsPayload {
  """The primary multi-tunnel"""
  primary: UpdateIpsecIkeV2SiteMultiTunnelPayload
  """The secondary multi-tunnel"""
  secondary: UpdateIpsecIkeV2SiteMultiTunnelPayload
  """The ID of the site"""
  siteId: ID!
}

type AddIpsecIkeV2SiteTunnelsPayload {
  """Cato’s FQDN for the primary tunnel"""
  primary: AddIpsecIkeV2SiteMultiTunnelPayload
  """Cato’s FQDN for the secondary tunnel"""
  secondary: AddIpsecIkeV2SiteMultiTunnelPayload
  """The ID of the site"""
  siteId: ID!
}

type HardwareManagementQueries {
  """Retrieve the account socket inventory"""
  socketInventory(input: SocketInventoryInput): SocketInventoryPayload!
}

input SocketInventoryInput {
  filter: SocketInventoryFilterInput
  paging: PagingInput
  sort: SocketInventoryOrderInput
}

input SocketInventoryFilterInput {
  """
  Will run contains operation for the provided text on the following fields serialNumber,socketMac,socketVersion,installedSite,
  shippingCompany,trackingNumber,deliverySiteName,description with OR between them
  """
  freeText: FreeTextFilterInput
}

input SocketInventoryOrderInput {
  deliverySiteName: SortOrderInput
  description: SortOrderInput
  installedSite: SortOrderInput
  serialNumber: SortOrderInput
  shippingCompany: SortOrderInput
  shippingDate: SortOrderInput
  socketType: SortOrderInput
  """Default sort field"""
  status: SortOrderInput
}

type SocketInventoryPayload {
  items: [SocketInventoryItem!]!
  pageInfo: PageInfo!
}

type SocketInventoryItem {
  """Socket account"""
  account: AccountRef!
  """Available upgrade versions"""
  availableUpgradeVersions: [String!]!
  """Name of the delivery site"""
  deliverySiteName: String
  """Description"""
  description: String
  """ID"""
  id: ID!
  """Is primary socket"""
  isPrimary: Boolean!
  """Registration status"""
  registrationStatus: SocketRegistrationStatus
  """Serial number (unique)"""
  serialNumber: String
  """Shipping company"""
  shippingCompany: String
  """Shipping date"""
  shippingDate: DateTime
  """Socket's site"""
  site: SiteRef
  """Mac address"""
  socketMac: MacAddress
  """Socket Type"""
  socketType: SocketPlatform
  """Socket version"""
  socketVersion: String
  """Socket status (see SocketInventoryItemStatus)"""
  status: SocketInventoryItemStatus
  """tracking number from the shipping company"""
  trackingNumber: String
  """tracking url from the shipping company"""
  trackingUrl: Url
  """Are automatic upgrade paused"""
  upgradesPaused: Boolean!
  """Upgrade status"""
  upgradeStatus: SocketUpgradeStatus
}

enum SocketInventoryItemStatus {
  CONNECTED
  DELIVERED
  INSTALLED
  ORDERED
  SHIPPED
}

type Events {
  from: DateTime
  id: ID
  records(limit: Int, from: Int): [EventsRecord!]
  to: DateTime
  total: Int
  totals: Map
}

type EventsRecord {
  fields: [EventField!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  fieldsUnitTypes: [UnitType!]
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
  prevTimeFrame: Map
  trends: Map
}

type EventsTimeSeries {
  from: DateTime
  granularity: Int
  id: ID
  timeseries(buckets: Int!): [Timeseries!]
  to: DateTime
}

input EventsMeasure {
  aggType: AggregationType!
  fieldName: EventFieldName!
  trend: Boolean
}

input EventsDimension {
  fieldName: EventFieldName!
}

input EventsFilter {
  fieldName: EventFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input EventsSort {
  fieldName: EventFieldName!
  order: DirectionEnum!
}

type EventField {
  name: EventFieldName!
  value: Value!
}

enum EventFieldName {
  "Identifies system access software or device"
  access_method
  "Account ID"
  account_id
  "Firewall, QoS or LAG action"
  action
  "Active Directory name"
  ad_name
  alert_id
  "Always-on Configuration"
  always_on_configuration
  "Analyst Verdict"
  analyst_verdict
  api_name
  api_type
  "Name of application activity"
  app_activity
  "SaaS user activities into categories."
  app_activity_category
  "Activity type"
  app_activity_type
  "Related Apps"
  app_stack
  "For Internet firewall, app for this event"
  application
  "Application ID of the flow"
  application_id
  "Application of the flow"
  application_name
  "Application risk score"
  application_risk
  "Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN"
  auth_method
  "Examples: MFA or password"
  authentication_type
  "BGP ASN for Cato peer"
  bgp_cato_asn
  "BGP IP for Cato peer"
  bgp_cato_ip
  "BGP disconnect error code"
  bgp_error_code
  "BGP ASN for remote peer"
  bgp_peer_asn
  "Description from Cato Management Application for BGP peer"
  bgp_peer_description
  "BGP IP for remote peer"
  bgp_peer_ip
  "CIDR for BGP route"
  bgp_route_cidr
  "BGP disconnect error message"
  bgp_suberror_code
  "Always-On Bypass Duration In Seconds"
  bypass_duration_sec
  "Always-On Bypass Method"
  bypass_method
  "Always-On Bypass Reason"
  bypass_reason
  "Cato system category"
  categories
  "Cato App"
  cato_app
  classification
  "Expiration date for Client certificate"
  client_cert_expires
  "Name of Client certificate"
  client_cert_name
  "Type of process generating this traffic"
  client_class
  "Socket or SDP Client version"
  client_version
  "Shows the display name of the target user involved in an activity"
  collaborator_name
  "For SaaS Security API, email addresses of the users that received the file"
  collaborators
  "Confidence Level"
  confidence_level
  "For hosts configured with a static IP in the Cato Management Application, the host name"
  configured_host_name
  "The algorithm that is used (CUBIC /NewReno / BBR)"
  congestion_algorithm
  "Connect on boot Enabled/Disabled"
  connect_on_boot
  "For SaaS Security API, name of the connector"
  connector_name
  "For SaaS Security API, status of the connector"
  connector_status
  "For SaaS Security API, SaaS app for the connector"
  connector_type
  "Criticality"
  criticality
  "Unique Cato ID for the custom category"
  custom_categories @deprecated(reason: "use custom_category_id/custom_category_name instead")
  "Name for the custom category defined in the Cato Management Application"
  custom_category @deprecated(reason: "use custom_category_id/custom_category_name instead")
  "Custom category ID"
  custom_category_id
  "Custom category name"
  custom_category_name
  "For Internet traffic, country where the destination host is located"
  dest_country
  "For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)"
  dest_country_code
  "The unique identifier by the SaaS vendor for the target group in an activity."
  dest_group_id
  "Identifies the target group involved in an activity"
  dest_group_name
  "For Internet traffic, destination host IP address"
  dest_ip
  "For WAN traffic, destination is site or SDP user"
  dest_is_site_or_vpn
  "For Internet traffic, destination host port"
  dest_port
  "For WAN traffic, name of destination site or SDP user"
  dest_site @deprecated(reason: "use dest_site_id/dest_site_name instead")
  "Unique internal Cato ID for the destination site or remote user"
  dest_site_id
  "For Internet traffic, destination host IP address"
  dest_site_name
  "Device Categories"
  device_categories
  "Device Certificate Validated/Not Validated"
  device_certificate
  "Unique Cato ID for devices"
  device_id
  "Device Manufacturer"
  device_manufacturer
  "Device Model"
  device_model
  "Name for device related to the event"
  device_name
  "Device OS Type"
  device_os_type
  "Device posture profiles"
  device_posture_profile
  "Device posture profiles"
  device_posture_profiles @deprecated(reason: "use device_posture_profile instead")
  "Device Type"
  device_type
  "Host name of Domain Controller that created LDAP event"
  directory_host_name
  "IP address of Domain Controller that created LDAP event"
  directory_ip
  "Result of LDAP Domain Controller sync event"
  directory_sync_result
  "Type of LDAP Domain Controller sync event"
  directory_sync_type
  "DLP fail mode"
  dlp_fail_mode
  "DLP profiles related to the event"
  dlp_profiles
  "Data Classifiers"
  dlp_scan_types
  "Cato’s DNS Protection type that matched the DNS request"
  dns_protection_category
  "Domain queried in the DNS request"
  dns_query
  "Domain name based on the SSL SNI, HTTP host name, or DNS name"
  domain_name
  "Egress PoP Name"
  egress_pop_name
  "Egress Site Name for backhauling traffic"
  egress_site_name
  "Email Subject"
  email_subject
  "Count for events that are repeated multiple times during one minute"
  event_count
  "Cato's description of the event"
  event_message
  "Sub-type for Routing, Security, Connectivity, System or Sockets Management event"
  event_sub_type
  "Routing, Security, Connectivity, System or Sockets Management event"
  event_type
  failure_reason
  "File hash"
  file_hash
  "File name"
  file_name
  "File size"
  file_size
  "File type"
  file_type
  final_object_status
  "Amount of flows for a given incident"
  flows_cardinality
  "Full path URL application activity"
  full_path_url
  "IP address of host related to event"
  host_ip
  "MAC address of host related to event"
  host_mac
  "HTTP request method (ie. Get, Post)"
  http_request_method
  "For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)"
  incident_aggregation
  "Unique Cato ID that identifies this security incident"
  incident_id
  "Indication"
  indication
  "Indicator"
  indicator
  "Cato Internal-use only"
  internalId
  "Network protocol for this event"
  ip_protocol
  "Classifies users based on their permissions."
  is_admin
  "Indicates whether an activity requires administrative permissions."
  is_admin_activity
  "Is Compliant"
  is_compliant
  "Is Managed"
  is_managed
  "Is the app for this event defined as a sanctioned app? (True/False)"
  is_sanctioned_app
  """
  The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
  """
  ISP_name
  "Name defined for the public API Key in the Cato Management Application"
  key_name
  "Data that measures the congestion for a specific link"
  link_health_is_congested
  "Data that measures the jitter for a specific link"
  link_health_jitter
  "Data that measures the latency for a specific link"
  link_health_latency
  "Data that measures the packet loss for a specific link"
  link_health_pkt_loss
  "Link type – Cato, Alt. WAN or LAG"
  link_type
  logged_in_user
  "Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)"
  login_type
  "Matched DLP data types related to the event"
  matched_data_types
  "Mitre attack subtechniques"
  mitre_attack_subtechniques
  "Mitre attack tactics"
  mitre_attack_tactics
  "Mitre attack techniques"
  mitre_attack_techniques
  "Network Access"
  network_access
  "Matched network rule"
  network_rule
  "For SaaS Security API, API Error of Apps Security Notification"
  notification_api_error
  "For SaaS Security API, description of Apps Security Notification"
  notification_description
  object_id
  object_name
  object_type
  "Office mode Enabled/Disabled"
  office_mode
  "Host OS or tunnel device"
  os_type
  "OS version for the device (such as 14.3.0)"
  os_version
  out_of_band_access
  "For SaaS Security API, email address of the file owner"
  owner
  "Pac File Enabled/Disabled"
  pac_file
  "For SaaS Security API, parent Microsoft 365 connector"
  parent_connector_name
  parent_pid @deprecated(reason: "use src_process_parent_pid instead")
  pid @deprecated(reason: "use src_pid instead")
  "Name of PoP location"
  pop_name
  process_path @deprecated(reason: "use src_process_path instead")
  "Producer"
  producer
  "Prompt Page Selected Action"
  prompt_action
  "Used Public IP"
  public_ip
  "QoS Priority value"
  qos_priority
  "For QoS, the time that this QoS event started. The event is generated when the QoS event finishes"
  qos_reported_time
  quarantine_folder_path
  "Raw Data"
  raw_data
  recommended_actions
  "The URL that links directly to the object involved in the activity"
  reference_url
  "Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)"
  registration_code
  "(IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low – ie. adware Medium – ie. network scans High – ie. spyware or worms"
  risk_level
  "Name of security rule related to the event"
  rule @deprecated(reason: "use rule_name instead")
  "Unique Cato ID for the security rule related to the event"
  rule_id
  "Rule name"
  rule_name
  "Severity defined for the rule"
  severity
  "Sharing Options for the file (such as SharePoint)"
  sharing_scope
  "Sign In Types"
  sign_in_event_types
  "For IPS and SAM, ID of the IPS signature"
  signature_id
  "Name for Socket interface"
  socket_interface
  "Socket interface ID"
  socket_interface_id
  "For Socket upgrades, new version number"
  socket_new_version
  "For Socket upgrade, previous version number"
  socket_old_version
  "Type of Socket reset (Hardware/Software)"
  socket_reset
  "For Socket HA events, indicates if the Socket is primary or secondary"
  socket_role
  "Socket version number"
  socket_version
  "Split Tunnel Configuration"
  split_tunnel_configuration
  "Country in which the source host is located (detected via public IP address)"
  src_country
  "Country Code of country in which the source host is located (detected via public IP address)"
  src_country_code
  "IP for host or Cato Client"
  src_ip
  "Source type: site or remote user"
  src_is_site_or_vpn
  "IP address provided by ISP to site or Client"
  src_isp_ip
  """
  Source or destination site or remote user ID.
  This field can only be used in filter.
  """
  src_or_dest_site_id
  "Internal port number"
  src_port
  "Name of site or user initiating the connection"
  src_site
  "Unique internal Cato ID for the site or remote user"
  src_site_id
  "Source site or remote user"
  src_site_name
  "Static host"
  static_host
  status
  "Story Id"
  story_id
  "Name of subnet as defined in Cato Management Application"
  subnet_name
  "Number of targets (servers) associated with this event"
  targets_cardinality
  "Shows if traffic was TCP accelerated or not"
  tcp_acceleration
  "Tenant Id"
  tenant_id
  "Tenant Name"
  tenant_name
  "For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked"
  threat_name
  "Link to external malware reference"
  threat_reference
  "Type of malware event"
  threat_type
  "Result of malware event (clean indicates a safe file)"
  threat_verdict
  "Time stamp of event (Linux epoch format)"
  time
  title
  "TLS Certificate Error"
  tls_certificate_error
  "TLS Error Description"
  tls_error_description
  "TLS Error Type"
  tls_error_type
  "Shows if traffic was TLS inspected or not"
  tls_inspection
  "TLS Inspection rule name"
  tls_rule_name
  "TLS Version"
  tls_version
  "Direction of network traffic for this event, values are inbound or outbound"
  traffic_direction
  "Trigger"
  trigger
  "Trust Type"
  trust_type
  "Trusted networks Enabled/Disabled"
  trusted_networks
  "Tunnel Protocol TCP/UDP"
  tunnel_ip_protocol
  "Protocol for the tunnel"
  tunnel_protocol
  "Socket upgrade end time (Linux epoch format):"
  upgrade_end_time
  "Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)"
  upgrade_initiated_by
  "Socket upgrade start time (Linux epoch format)"
  upgrade_start_time
  "URL associated with the event"
  url
  "User Agent"
  user_agent
  "Method used to get identity with User Awareness (such as Identity Agent)"
  user_awareness_method
  "User ID"
  user_id
  "User that generated the event"
  user_name
  "For Block/Prompt page, reference ID to report incorrect category"
  user_reference_id
  vendor
  "Shows the id of the target user involved in an activity"
  vendor_collaborator_id
  "Vendor Device Id"
  vendor_device_id
  "Vendor Device Name"
  vendor_device_name
  "Vendor Event Id"
  vendor_event_id
  vendor_user_id
  "Unique Cato Visible ID for devices"
  visible_device_id
  "Lan access Allowed / Blocked"
  vpn_lan_access
  "User’s email address"
  vpn_user_email
  "For LDAP sync events, name of the AD domain"
  windows_domain_name
  "XFF HTTP header indicates the original IP address for the connections"
  xff
}

type AuditFeedAccountRecords {
  id: ID
  records(fieldNames: [AuditFieldName!]): [AuditRecord!]
}

type AuditFeed {
  accounts: [AuditFeedAccountRecords]
  fetchedCount: Int!
  from: DateTime
  hasMore: Boolean
  marker: String
  to: DateTime
}

"""
Search operators on ElasticSearch. Between operators are applicable only to numeric fields
Note that not operators are slower
"""
enum ElasticOperator {
  between
  exists
  in
  is
  is_not
  not_between
  not_exists
  not_in
}

"""
FieldName for the different types of FieldName inputs
Use the EventFieldName for events, and AuditFieldName for audit
"""
input FieldNameInput {
  AuditFieldName: AuditFieldName
  EventFieldName: EventFieldName
}

input AuditFieldFilterInput {
  fieldName: FieldNameInput!
  "Use AuditFieldName for audits"
  operator: ElasticOperator!
  values: [String!]
}

"""Represents a single event in the audit database"""
type AuditRecord {
  account: EntityInfo
  admin: Entity
  apiKey: Entity
  "All fields in the audit record (including the admin and object)"
  fields: [AuditField!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
  object: Entity
  time: DateTime
}

type StringValue {
  string: String
}

type DateValue {
  date: DateTime
}

union Value = StringValue | DateValue | Entity

type AuditField {
  name: String!
  value: Value!
}

enum AuditFieldName {
  "The name of the account on which the record was created"
  account
  "The id of the account on which the record was created"
  account_id
  "The admin whose action generated the record"
  admin
  "The ID of the admin whose action generated the record"
  admin_id
  "The api key whose action generated the record"
  apiKey
  audit_creation_type
  "the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`"
  change_type
  "Time the record was created"
  creation_date
  "Time the record was committed to storage"
  insertion_date
  "The name of the object that was affected, e.g. 'My Site'"
  model_name
  "The type of object that was affected. e.g. Site, Socket, SocketInterface"
  model_type
  "Less granular than model_name, a general marker of the modified area: administration, configuration, security"
  module
}

enum EntityType {
  """A reference to a configured Account under reseller"""
  account
  """An account administrator (user in Cato Console)"""
  admin
  """An external IP address in a specific PoP reserved for the account"""
  allocatedIP
  """Any entity (matches everything)"""
  any
  "Pooled licenses available for use"
  availablePooledUsage
  "Site licenses available for use"
  availableSiteUsage
  """A settlement with over 1K population"""
  city
  """Geographical and political entity recognized internationally"""
  country
  """
  Represents a state or territory within a country. It is a sub-division of the country
  """
  countryState
  "A reference to DHCP Relay Group within account"
  dhcpRelayGroup
  groupSubscription
  """A reference to the configured Host within Site"""
  host
  "A reference to LAN Firewall Rule within Site"
  lanFirewall
  "A reference to Local Routing Rule within Site"
  localRouting
  location
  mailingListSubscription
  """A reference to the configured Network Interface within Site"""
  networkInterface
  "Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number"
  portProtocol
  "l4 services for LAN firewall rules"
  simpleService
  """A reference to a configured Site within Account"""
  site
  "union of the globalRange and a Subnet"
  siteRange
  """
  Time zone, which is a geographical region where clocks are set to the same time
  """
  timezone
  """A reference to the configured VPN User within Account"""
  vpnUser
  webhookSubscription
}

type ContainerQueries {
  fqdn: FqdnContainerQueries!
  ipAddressRange: IpAddressRangeContainerQueries!
  list(input: ContainerSearchInput!): ContainerSearchPayload!
}

type ContainerMutations {
  delete(input: DeleteContainerInput!): DeleteContainerPayload!
  fqdn: FqdnContainerMutations!
  ipAddressRange: IpAddressRangeContainerMutations!
}

"A group with members of a single type of entity (for example: IPAddress, FQDN)"
interface Container {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
  "Description for the container"
  description: String
  "Number of items in the container"
  size: Int!
  "Audit metadata about the container"
  audit: ContainerAudit!
}

"Audit metadata about the container"
type ContainerAudit {
  "Indicates when the container was created"
  createdAt: DateTime!
  "Indicates who created the container"
  createdBy: String!
  "Indicated when the container was last updated"
  lastModifiedAt: DateTime!
  "Indicates who was the last to update the container"
  lastModifiedBy: String!
}

"Container search result, including all containers that matched input criteria"
type ContainerSearchPayload {
  "A list of matched containers"
  containers: [Container!]!
}

type DeleteContainerPayload {
  "The data of the container before it was deleted"
  container: Container!
}

"Filtering input to container search"
input ContainerSearchInput {
  "Allows filtering container search by container ID or container name"
  refs: [ContainerRefInput!]! = []
  "Allows filtering container search by specific container types"
  types: [ContainerType!]! = []
}

"Identification of container for delete operation"
input DeleteContainerInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
}

enum ContainerType {
  FQDN
  IP_RANGE
}

type FqdnContainerMutations {
  addValues(input: FqdnContainerAddValuesInput!): FqdnContainerAddValuesPayload!
  createFromFile(input: CreateFqdnContainerFromFileInput!): CreateFqdnContainerFromFilePayload!
  removeValues(input: FqdnContainerRemoveValuesInput!): FqdnContainerRemoveValuesPayload!
  updateFromFile(input: UpdateFqdnContainerFromFileInput!): UpdateFqdnContainerFromFilePayload!
}

type FqdnContainerQueries {
  downloadFile(input: DownloadFqdnContainerFileInput!): DownloadFqdnContainerFilePayload!
  search(input: FqdnContainerSearchInput!): FqdnContainerSearchPayload!
  searchFqdn(input: FqdnContainerSearchFqdnInput!): FqdnContainerSearchFqdnPayload!
}

"A group with members of FQDN type"
type FqdnContainer implements Container {
  "Audit metadata about the container"
  audit: ContainerAudit!
  "Description for the container"
  description: String
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
  "Number of items in the container"
  size: Int!
}

"Payload of FQDN container search"
type FqdnContainerSearchPayload {
  "Container with members of type FQDN"
  container: FqdnContainer!
}

"Payload of FQDN search query"
type FqdnContainerSearchFqdnPayload {
  "List of containers with members of type FQDN"
  containers: [FqdnContainer!]!
}

"Payload of AddValues operation on FQDN typed container"
type FqdnContainerAddValuesPayload {
  "Container with members of type FQDN"
  container: FqdnContainer!
}

"Payload of RemoveValues operation on FQDN typed container"
type FqdnContainerRemoveValuesPayload {
  "Container with members of type FQDN"
  container: FqdnContainer!
}

"Payload of CreateFromFile operation on FQDN typed container"
type CreateFqdnContainerFromFilePayload {
  "Container with members of type FQDN"
  container: FqdnContainer!
}

"Payload of UpdateFromFile operation on FQDN typed container"
type UpdateFqdnContainerFromFilePayload {
  "Container with members of type FQDN"
  container: FqdnContainer!
}

"Payload of download FQDN typed container file"
type DownloadFqdnContainerFilePayload {
  "Content of a file encoded in base64 format"
  encodedFile: String!
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

"Input for creating FQDN typed container from file"
input CreateFqdnContainerFromFileInput {
  "Description for the container"
  description: String!
  "Name for the container"
  name: String!
  "Multipart file containing FQDNs with csv/newline delimiter"
  uploadFile: Upload!
}

"Input for updating FQDN typed container from file"
input UpdateFqdnContainerFromFileInput {
  "Description for the container"
  description: String!
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  "Multipart file containing FQDNs with csv/newline delimiter"
  uploadFile: Upload
}

"Input for adding values to existing FQDN typed container"
input FqdnContainerAddValuesInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  values: [Fqdn!]! = []
}

"Input for removing values from existing FQDN typed container"
input FqdnContainerRemoveValuesInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  values: [Fqdn!]! = []
}

"Input for searching FQDN typed container"
input FqdnContainerSearchInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
}

"Input for searching FQDN typed containers that contain a specific FQDN"
input FqdnContainerSearchFqdnInput {
  fqdn: Fqdn!
}

"Input for searching FQDN typed container to download its content"
input DownloadFqdnContainerFileInput {
  by: ObjectRefBy!
  input: String!
}

type IpAddressRangeContainerMutations {
  addValues(input: IpAddressRangeContainerAddValuesInput!): IpAddressRangeContainerAddValuesPayload!
  createFromFile(input: CreateIpAddressRangeContainerFromFileInput!): CreateIpAddressRangeContainerFromFilePayload!
  removeValues(input: IpAddressRangeContainerRemoveValuesInput!): IpAddressRangeContainerRemoveValuesPayload!
  updateFromFile(input: UpdateIpAddressRangeContainerFromFileInput!): UpdateIpAddressRangeContainerFromFilePayload!
}

type IpAddressRangeContainerQueries {
  downloadFile(input: DownloadIpAddressRangeContainerFileInput!): DownloadIpAddressRangeContainerFilePayload!
  search(input: IpAddressRangeContainerSearchInput!): IpAddressRangeContainerSearchPayload!
  searchIpAddressRange(input: IpAddressRangeContainerSearchIpAddressRangeInput!): IpAddressRangeContainerSearchIpAddressRangePayload!
}

"A group with members of IPAddressRange type"
type IpAddressRangeContainer implements Container {
  "Audit metadata about the container"
  audit: ContainerAudit!
  "Description for the container"
  description: String
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
  "Number of items in the container"
  size: Int!
}

"Payload of IPAddressRange container search"
type IpAddressRangeContainerSearchPayload {
  "Container with members of type IPAddressRange"
  container: IpAddressRangeContainer!
}

"Payload of IPAddressRange search query"
type IpAddressRangeContainerSearchIpAddressRangePayload {
  "List of containers with members of type IPAddressRange"
  containers: [IpAddressRangeContainer!]!
}

"Payload of AddValues operation on IPAddressRange typed container"
type IpAddressRangeContainerAddValuesPayload {
  "Container with members of type IPAddressRange"
  container: IpAddressRangeContainer!
}

"Payload of AddValues operation on IPAddressRange typed container"
type IpAddressRangeContainerRemoveValuesPayload {
  "Container with members of type IPAddressRange"
  container: IpAddressRangeContainer!
}

"Payload of CreateFromFile operation on IPAddressRange typed container"
type CreateIpAddressRangeContainerFromFilePayload {
  "Container with members of type IPAddressRange"
  container: IpAddressRangeContainer!
}

"Payload of UpdateFromFile operation on IPAddressRange typed container"
type UpdateIpAddressRangeContainerFromFilePayload {
  "Container with members of type IPAddressRange"
  container: IpAddressRangeContainer!
}

"Payload of download IPAddressRange typed container file"
type DownloadIpAddressRangeContainerFilePayload {
  "Content of a file encoded in base64 format"
  encodedFile: String!
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

"Input for creating IPAddressRange typed container from file"
input CreateIpAddressRangeContainerFromFileInput {
  "Description for the container"
  description: String!
  "Name for the container"
  name: String!
  "Multipart file containing IPAddressRanges with csv/newline delimiter"
  uploadFile: Upload!
}

"Input for updating existing IPAddressRange typed container from file"
input UpdateIpAddressRangeContainerFromFileInput {
  "Description for the container"
  description: String!
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  "Multipart file containing IPAddressRanges with csv/newline delimiter"
  uploadFile: Upload
}

"Input for adding values to existing IPAddressRange typed container"
input IpAddressRangeContainerAddValuesInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  values: [IpAddressRangeInput!]! = []
}

"Input for removing values from existing IPAddressRange typed container"
input IpAddressRangeContainerRemoveValuesInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
  values: [IpAddressRangeInput!]! = []
}

"Filtering input to IPAddressRange container search"
input IpAddressRangeContainerSearchInput {
  "Reference to existing container by container ID or container name"
  ref: ContainerRefInput!
}

"Input for searching IPAddressRange typed containers that contain a specific IPAddressRange"
input IpAddressRangeContainerSearchIpAddressRangeInput {
  ipAddressRange: IpAddressRangeInput!
}

"Input for searching IPAddressRange typed container to download its content"
input DownloadIpAddressRangeContainerFileInput {
  by: ObjectRefBy!
  input: String!
}

enum SocketInterfaceDestType {
  ALTERNATIVE
  CATO
  INTERFACE_DISABLED
  LAN
  LAN_AND_HA
  LAN_LAG_MASTER
  LAN_LAG_MASTER_AND_VRRP
  LAN_LAG_MEMBER
  LAYER_2_WAN
  VRRP
  VRRP_AND_LAN
}

enum VrrpType {
  DIRECT_LINK
  VIA_SWITCH
}

"SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids"
enum SocketInterfaceIDEnum {
  INT_1
  INT_10
  INT_11
  INT_12
  INT_2
  INT_3
  INT_4
  INT_5
  INT_6
  INT_7
  INT_8
  INT_9
  LAN1
  LAN2
  LTE
  USB1
  USB2
  WAN1
  WAN2
  WLAN
}

enum SocketInterfaceRole {
  wan_1
  wan_2
  wan_3
  wan_4
}

enum IPSecV2InterfaceId {
  PRIMARY1
  PRIMARY2
  PRIMARY3
  SECONDARY1
  SECONDARY2
  SECONDARY3
}

type SubDomain {
  accountId: ID!
  accountName: String!
  accountType: String!
  subDomain: String!
}

input UpdateAccountRoleInput {
  id: ID!
  name: String
}

input UpdateAdminRoleInput {
  allowedAccounts: [ID!]
  allowedEntities: [EntityInput!]
  role: UpdateAccountRoleInput!
}

enum SiteType {
  BRANCH
  CLOUD_DC
  DATACENTER
  HEADQUARTERS
}

type AdminsResult {
  items: [Admin!]!
  total: Int!
}

type EntityLookupResult {
  items: [EntityInfo!]!
  total: Int
}

"""A CC2 administrator"""
type Admin {
  allowedItems: [Entity!]
  creationDate: DateTime
  email: String
  firstName: String
  id: ID!
  lastName: String
  managedRoles: [AdminRole!]
  mfaEnabled: Boolean
  modifyDate: DateTime
  nativeAccountID: ID
  passwordNeverExpires: Boolean
  presentUsageAndEvents: Boolean
  resellerRoles: [AdminRole!]
  role: UserRole
  status: OperationalStatus
  version: String!
}

enum UserRole {
  EDITOR
  OWNER
  PUBLIC_EDITOR
  PUBLIC_VIEWER
  SITES_VIEWER
  SUPER_USER
  VIEWER
}

enum AccountType {
  ALL
  REGULAR
  RESELLER
  SYSTEM
}

enum IpSecCipher {
  AES_CBC_128
  AES_CBC_256
  AES_GCM_128
  AES_GCM_256
  AUTOMATIC
  DES3_CBC
  NONE
}

enum IpSecHash {
  AUTOMATIC
  MD5
  NONE
  SHA1
  SHA256
  SHA384
  SHA512
}

enum IpSecDHGroup {
  AUTOMATIC
  DH_14_MODP2048
  DH_15_MODP3072
  DH_16_MODP4096
  DH_19_ECP256
  DH_2_MODP1024
  DH_20_ECP384
  DH_21_ECP521
  DH_5_MODP1536
  NONE
}

enum ConnectionMode {
  BIDIRECTIONAL
  RESPONDER_ONLY
}

enum IdentificationType {
  EMAIL
  FQDN
  IPV4
  KEY_ID
}

enum DestinationType {
  FQDN
  IPv4
}

enum ProtoType {
  CROSS_CONNECT
  IPSEC_CLIENT
  IPSEC_HOST
  IPSEC_V2
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_ESX1500
  SOCKET_X1500
  SOCKET_X1600
  SOCKET_X1600_LTE
  SOCKET_X1700
  VSOCKET_VGX
}

enum SocketRegistrationStatus {
  ASSIGNED_SITE
  ASSIGNED_SITE_PENDING_REGISTER
  NEW
  PENDING
  REGISTERED
  REJECTED
  UNASSIGNING
}

enum SocketUpgradeStatus {
  CANCEL
  FAIL
  FATAL
  PENDING
  PENDING_REBOOT
  RETRY
  SKIP
  STARTED
  STARTING
  SUCCESS
}

enum SocketPlatform {
  AWS1500
  AZ1500
  ESX1500
  X1500
  X1500_BR2
  X1500B_BR2
  X1600
  X1600_LTE
  X1700
  X1700B
}

enum SubnetType {
  Direct
  Native
  Routed
  SecondaryNative
  VLAN
}

enum DhcpType {
  ACCOUNT_DEFAULT
  DHCP_DISABLED
  DHCP_RANGE
  DHCP_RELAY
}

input LookupFilterInput {
  filter: LookupFilterType
  value: String
}

enum LookupFilterType {
  """Custom filter for country, used by city and state entityLookup"""
  country
  """
  Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
  "true",
  "false",
  """
  filterByAltWan
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
  "true",
  "false",
  """
  filterByBackhaulingGW
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
  "SOCKET_X1500",
  "SOCKET_X1600",
  "SOCKET_X1700",
  "VSOCKET_VGX_ESX",
  "VSOCKET_VGX_AWS"
  "VSOCKET_VGX_AZURE"
  "SOCKET_X1600_LTE",
  """
  filterByConnectionType
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
  "SOCKET",
  "IPSEC",
  "vSOCKET",
  "PHYSICAL_SOCKET"
  """
  filterByConnectionTypeFamily
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
  "true",
  "false",
  """
  filterByOffCloudTransportEnabled
  """Custom filter for state used by city entityLookup"""
  state
}

type AccountRolesResult {
  items: [RBACRole!]!
  total: Int!
}

type AccountDataPayload {
  id: ID!
  name: String!
  subdomain: String!
}

type Entity {
  id: ID!
  name: String
  type: EntityType!
}

input EntityInput {
  id: ID!
  name: String
  type: EntityType!
}

type EntityInfo {
  description: String!
  entity: Entity!
  helperFields: Map!
}

interface ObjectRef {
  "Object's unique identifier"
  id: ID!
  "Object's unique name"
  name: String!
}

enum ObjectRefBy {
  ID
  NAME
}

"Wall time. E.g.: 12:34:56 or 12:34"
scalar Time

"2006-01-02T15:04:05Z07:00 (RFC3339)"
scalar DateTime

"An IPv4 IP address"
scalar IPAddress

"""
Top level domain is actually second level domain (e.g. example.com)
It is recommended to use as a broad way of distinguishing domains, because they **frequently use multiple hosts**.
"""
scalar Domain

"""Fully Qualified Domain Name: An exact host name (e.g. www.example.com)"""
scalar Fqdn

enum OperatingSystem {
  ANDROID
  EMBEDDED
  IOS
  LINUX
  MACOS
  WINDOWS
}

"Network port number. Must be in range [0-65535] E.g.: 433, 8080, 80, etc.."
scalar Port

"16 bit autonomous system number [0-65535]"
scalar Asn16

"32 bit autonomous system number [0-4294967295]"
scalar Asn32

"A Uniform Resource Locator, colloquially known as an address on the Web. E.g.: http://www.example.com/page/"
scalar Url

enum DayOfWeek {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

"FF:FF:FF:FF OR FF-FF-FF-FF"
scalar MacAddress

"Subnet in CIDR notation E.g.: 10.0.0.0/24"
scalar NetworkSubnet

"Inclusive range of IPs"
type IpAddressRange {
  from: IPAddress!
  to: IPAddress!
}

"Inclusive range of IPs"
input IpAddressRangeInput {
  from: IPAddress!
  to: IPAddress!
}

"Inclusive network port range"
type PortRange {
  from: Port!
  to: Port!
}

"Inclusive network port range"
input PortRangeInput {
  from: Port!
  to: Port!
}

enum IpProtocol {
  ANY
  ICMP
  TCP
  "TCP or UDP"
  TCP_UDP
  UDP
}

"Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol"
type CustomService {
  port: [Port!]
  portRange: PortRange
  protocol: IpProtocol!
}

"Add a Custom Service defined by a combination of L4 ports and an IP Protocol"
input CustomServiceInput {
  port: [Port!]
  portRange: PortRangeInput
  protocol: IpProtocol!
}

type UserRef implements ObjectRef {
  id: ID!
  name: String!
}

input UserRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type UsersGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input UsersGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type DeviceProfileRef implements ObjectRef {
  id: ID!
  name: String!
}

input DeviceProfileRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CustomCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input CustomCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type GroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input GroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

"""
Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
type FloatingSubnetRef implements ObjectRef {
  "Unique Floating Subnet ID"
  id: ID!
  "Name for the Floating Subnet"
  name: String!
}

"""
Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
input FloatingSubnetRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

type HostRef implements ObjectRef {
  id: ID!
  name: String!
}

input HostRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type NetworkInterfaceRef implements ObjectRef {
  id: ID!
  name: String!
}

input NetworkInterfaceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SiteRef implements ObjectRef {
  id: ID!
  name: String!
}

input SiteRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type AccountRef implements ObjectRef {
  id: ID!
  name: String!
}

type SiteNetworkSubnetRef implements ObjectRef {
  id: ID!
  name: String!
}

input SiteNetworkSubnetRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

input ApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ApplicationCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input ApplicationCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SanctionedAppsCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

input SanctionedAppsCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CustomApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

input CustomApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type ServiceRef implements ObjectRef {
  id: ID!
  name: String!
}

input ServiceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type CountryRef implements ObjectRef {
  id: ID!
  name: String!
}

input CountryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SubscriptionGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SubscriptionWebhookRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionWebhookRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SubscriptionMailingListRef implements ObjectRef {
  id: ID!
  name: String!
}

input SubscriptionMailingListRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type SystemGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

input SystemGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

type GlobalIpRangeRef implements ObjectRef {
  id: ID!
  name: String!
}

input GlobalIpRangeRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

interface IContainerRef implements ObjectRef {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

"A group with members of FQDN type"
type FqdnContainerRef implements ObjectRef & IContainerRef {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

input IpAddressRangeContainerRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

input FqdnContainerRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

"A group with members of IPAddressRange type"
type IpAddressRangeContainerRef implements ObjectRef & IContainerRef {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

"Add a container by ID or name"
input ContainerRefInput {
  "Defines the object identification method – by ID (default) or by name"
  by: ObjectRefBy! = ID
  "The object identification (ID or name) value"
  input: String!
}

"A group with members of a single type of entity (for example: IP, FQDN)"
type ContainerRef implements ObjectRef {
  "Unique container ID"
  id: ID!
  "Name for the container"
  name: String!
}

input SortOrderInput {
  direction: SortOrder! = ASC
  priority: Int! = 1
}

enum SortOrder {
  ASC
  DESC
}

type PageInfo {
  total: Int!
}

input FreeTextFilterInput {
  search: String!
}

input PagingInput {
  from: Int! = 0
  limit: Int! = 100
}

input SortInput {
  field: String
  order: DirectionInput
}

enum DirectionInput {
  asc
  desc
}

enum AppStatsFieldName {
  "Active Directory name"
  ad_name
  "The application identifier"
  app
  "The application name"
  application
  "Cato system category of the application"
  category
  "Application description"
  description
  "IP for destination host or Cato Client"
  dest_ip
  "Destination is site or remote user"
  dest_is_site_or_vpn
  "Destination site or remote user identifier"
  dest_site
  "Destination Site or remote user identifier"
  dest_site_id
  "Destination Site or remote user name"
  dest_site_name
  "Name for device related to the traffic"
  device_name
  ""
  discovered_app
  ""
  domain
  "data downloaded from cloud applications"
  downstream
  ""
  flows_created
  "the country in which the registered application headquarteres is located"
  hq_location
  ""
  ip
  "indicates whether the application is considered cloud app/SaaS app"
  is_cloud_app
  "new cloud application identifier"
  new_app
  ""
  risk_level
  "the application risk score assigned by Cato"
  risk_score
  "Is the application defined as sanctioned?"
  sanctioned
  "Country in which the source host is located"
  site_country
  "State in which the source host is located"
  site_state
  "Name for Socket interface"
  socket_interface
  "IP for source host or Cato Client"
  src_ip
  "Source is site or remote user"
  src_is_site_or_vpn
  "Source site or remote user identifier"
  src_site_id
  "Source site or remote user name"
  src_site_name
  "Name of subnet as defined in Cato Management Application"
  subnet
  "the total sum of upstream and downstream data in bytes"
  traffic
  "Traffic direction"
  traffic_direction
  "data uploaded to cloud applications"
  upstream
  "User identifier"
  user_id
  "User name"
  user_name
  ""
  vpn_user_id @deprecated(reason: "use user_id instead")
}

type AppStats {
  from: DateTime
  id: ID
  records(limit: Int, from: Int): [AppStatsRecord!]
  to: DateTime
  total: Int
  totals: Map
}

type AppStatsRecord {
  fields: [AppStatsField!]
  "fields in map format (see Map scalar)"
  fieldsMap: Map
  fieldsUnitTypes: [UnitType!]
  """
  Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
  """
  flatFields: [[String!]]
  prevTimeFrame: Map
  trends: Map
}

type AppStatsTimeSeries {
  from: DateTime
  granularity: Int
  id: ID
  timeseries(buckets: Int!): [Timeseries!]
  to: DateTime
}

type AppStatsField {
  name: AppStatsFieldName!
  value: Value!
}

input Measure {
  aggType: AggregationType!
  fieldName: AppStatsFieldName!
  trend: Boolean
}

input Dimension {
  fieldName: AppStatsFieldName!
}

input AppStatsFilter {
  fieldName: AppStatsFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input AppStatsSort {
  fieldName: AppStatsFieldName!
  order: DirectionEnum!
}

type AdminMutations {
  addAdmin(input: AddAdminInput!): AddAdminPayload @ga
  removeAdmin(adminID: ID!): RemoveAdminPayload @ga
  updateAdmin(adminID: ID!, input: UpdateAdminInput!): UpdateAdminPayload @ga
}

type GetAdminPayload {
  creationDate: String!
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  managedRoles: [AdminRole!]
  mfaEnabled: Boolean!
  passwordNeverExpires: Boolean!
  resellerRoles: [AdminRole!]
}

input AddAdminInput {
  email: String!
  firstName: String!
  lastName: String!
  managedRoles: [UpdateAdminRoleInput!]
  mfaEnabled: Boolean!
  passwordNeverExpires: Boolean!
  resellerRoles: [UpdateAdminRoleInput!]
}

input UpdateAdminInput {
  firstName: String
  lastName: String
  managedRoles: [UpdateAdminRoleInput!]
  mfaEnabled: Boolean
  passwordNeverExpires: Boolean
  resellerRoles: [UpdateAdminRoleInput!]
}

type AddAdminPayload {
  adminID: ID!
}

type RemoveAdminPayload {
  adminID: ID!
}

type UpdateAdminPayload {
  adminID: ID!
}

type LicensingQueries {
  """BETA"""
  licensingInfo: LicensingInfo
}

"""Public license API"""
type LicensingInfo {
  """License usage and allocation across the managed accounts"""
  globalLicenseAllocations: GlobalLicenseAllocations!
  """License inventory"""
  licenses: [License!]!
}

"""License usage and allocation across all accounts"""
type GlobalLicenseAllocations {
  """Public IP addresses usage across the accounts"""
  publicIps: PublicIpsLicenseAllocations
  """ZTNA license allocation across the accounts"""
  ztnaUsers: ZtnaUsersLicenseAllocations
}

"""IP addresses license usage and allocation across all accounts"""
type PublicIpsLicenseAllocations {
  allocated: Int!
  available: Int!
  total: Int!
}

"""Global ZTNA license usage and allocation across all accounts"""
type ZtnaUsersLicenseAllocations {
  """Total users allocated a ZTNA license"""
  allocated: Int!
  """Available users not yet allocated a license"""
  available: Int!
  """Total ZTNA licenses for users"""
  total: Int!
}

"""enum for license plan type (site license, service license, etc...)"""
enum LicensePlan {
  COMMERCIAL
  TRIAL
}

"""
enum for account plan status – the current license status within the license lifecycle
"""
enum LicenseStatus {
  """A license that is currently active"""
  ACTIVE
  """An expired license is no longer active"""
  DISABLED
  """A license in a grace period"""
  LOCKED
  """
  An existing license with a future start date that is not currently active
  """
  SCHEDULED
  """
  A license that is active before its start date, for partners and customers to verify the relevant configurations
  """
  STAGING
}

"""
An interface containing properties that are common to all license types
"""
interface License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License start date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
}

interface QuantifiableLicense implements License {
  description: String
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License activation status"""
  status: LicenseStatus!
  """License initiation date"""
  startDate: DateTime
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """license quantity"""
  total: Int!
}

enum LicenseSku {
  """Cato Anti Malware (legacy) service SKU"""
  CATO_ANTI_MALWARE
  """Cato Anti Malware Next Generation (legacy) service SKU"""
  CATO_ANTI_MALWARE_NG
  """Cato CASB service SKU"""
  CATO_CASB
  """Cato datalake Group SKU"""
  CATO_DATALAKE
  """12 months data retention SKU"""
  CATO_DATALAKE_12M
  """3 months data retention SKU"""
  CATO_DATALAKE_3M
  """6 months data retention SKU"""
  CATO_DATALAKE_6M
  """Cato DEM service SKU"""
  CATO_DEM
  """Cato DEM Pro service SKU"""
  CATO_DEM_PRO @deprecated(reason: "replaced with CATO_DEM")
  """Cato DLP service SKU"""
  CATO_DLP
  """Cato EPP service SKU"""
  CATO_EPP
  """Cato ILMM service SKU"""
  CATO_ILMM
  """Public IPs SKU"""
  CATO_IP_ADD
  """Cato IPS (legacy) service SKU"""
  CATO_IPS
  """Cato MDR (XDR Pro) service SKU"""
  CATO_MDR
  """Cato NOCaaS service SKU"""
  CATO_NOCAAS_HF
  """Site pooled bandwidth SASE SKU"""
  CATO_PB
  """Site pooled bandwidth SSE SKU"""
  CATO_PB_SSE
  """Cato Remote Browser Isolation (RBI) service SKU"""
  CATO_RBI
  """Cato SAAS Group SKU"""
  CATO_SAAS
  CATO_SAAS_SECURITY_API
  """
  Cato SAAS Security API with more than two Applications integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_ALL_APPS
  """
  Cato SAAS Security API with one application integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_ONE_APP
  """
  Cato SAAS Security API with two applications integration (legacy) service SKU
  """
  CATO_SAAS_SECURITY_API_TWO_APPS
  """Site bandwidth SASE SKU"""
  CATO_SITE
  """Site bandwidth SSE SKU"""
  CATO_SSE_SITE
  """Cato Threat Prevention (legacy) service SKU"""
  CATO_THREAT_PREVENTION
  """Cato XDR service SKU"""
  CATO_XDR_PRO
  """ZTNA remote users SKU"""
  CATO_ZTNA_USERS
  """ZTNA remote users SKU"""
  MOBILE_USERS @deprecated(reason: "replaced with CATO_ZTNA_USERS")
}

type DataLakeLicense implements License & QuantifiableLicense {
  description: String
  """
  The version of the Data Processing Agreement (DPA) that your company signed with Cato.
  """
  dpaVersion: DpaVersion!
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """
  Data retention period, in months, during which the account data may remain on the Cato Cloud. After this period the data will be permanently deleted.
  """
  retentionPeriod: Int
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """
  Total number of the Data Storage Units under this license. Each Data Storage Unit increases the allowed ingestion rate (events per hour and total events storage)
  """
  total: Int!
}

"""The DPA agreement, based on your contract with Cato"""
enum DpaVersion {
  DPA_2019_01
  DPA_2021_01
  DPA_2023_01
}

"""Public IP address license"""
type PublicIpsLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """The number of public IPs available in the licenses"""
  total: Int!
}

"""Site bandwidth license"""
type SiteLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """
  For the relevant license groups, indicates whether this is a global or regional license. For other regions, the value is set to ‘NA’ (not applicable).
  """
  regionality: Regionality
  """Identifying data for the site the license is assigned to"""
  site: SiteRef
  """The license group."""
  siteLicenseGroup: SiteLicenseGroup!
  """The selected service type, e.g SASE or SSE."""
  siteLicenseType: SiteLicenseType!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """Maximum available bandwidth for the site, in Mbps"""
  total: Int!
}

type PooledBandwidthLicense implements License & QuantifiableLicense {
  """
  Accounts that this license is assigned to (and the license usage within each account)
  """
  accounts: [PartnerPooledBandwidthLicenseAccount!]!
  """
  allocated bandwidth, in Mbps, for all the sites assigned to this license.
  """
  allocatedBandwidth: Int!
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """Regional license group"""
  siteLicenseGroup: SiteLicenseGroup!
  """The selected service type, e.g SASE or SSE."""
  siteLicenseType: SiteLicenseType!
  """
  Sites that this license is assigned to (and the license usage within each site)
  """
  sites: [PooledBandwidthLicenseSite!]!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """
  Maximum available bandwidth, in Mbps, for all the sites under this license. This constitutes the bandwidth pool that is allocated to different sites.
  """
  total: Int!
}

type PooledBandwidthLicenseSite {
  """Allocated bandwidth for this site"""
  allocatedBandwidth: Int!
  """Identifying data for the site"""
  site: SiteRef!
}

type PartnerPooledBandwidthLicenseAccount {
  """Identifying data for the account"""
  account: AccountRef!
  """Allocated bandwidth for this account"""
  allocatedBandwidth: Int!
}

enum SiteLicenseGroup {
  """legacy license group"""
  AFRICA
  """legacy license group"""
  ANZ
  """legacy license group"""
  APJ
  """Country with stand-alone licenses (not part of a group)"""
  CHINA
  """legacy license group"""
  DUBAI
  """legacy license group"""
  EUROPE
  GROUP_1
  GROUP_2
  """legacy license group"""
  LATAM
  """legacy license group"""
  MIDDLE_EAST
  """Country with stand-alone licenses (not part of a group)"""
  MOROCCO
  """legacy license group"""
  NAM
  """Country with stand-alone licenses (not part of a group)"""
  VIETNAM
}

enum SiteLicenseType {
  SASE
  SSE
}

"""ZTNA remote users license"""
type ZtnaUsersLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """The maximum amount of ZTNA users for the region."""
  total: Int!
  """Specify a license group that you are limiting the number of ZTNA users"""
  ztnaUsersLicenseGroup: ZtnaUsersLicenseGroup!
}

"""Geographical regions that can be associated with a remote user license"""
enum ZtnaUsersLicenseGroup {
  """Country with stand-alone licenses (not part of a group)"""
  CHINA
  """Legacy group"""
  DUBAI
  GENERAL
  """Legacy group"""
  LATAM
  """Country with stand-alone licenses (not part of a group)"""
  MOROCCO
  """Country with stand-alone licenses (not part of a group)"""
  VIETNAM
}

"""
REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
"""
enum Regionality {
  """Global traffic going outside of the region"""
  GLOBAL
  """Site traffic within the region"""
  REGIONAL
}

"""End Point Protection (EPP) license details"""
type EndpointProtectionLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """The maximum number of users that can use this service"""
  total: Int!
}

"""Intelligent Last Mile Monitoring (ILMM) License details"""
type IlmmLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """The total amount of ILMM licenses."""
  total: Int!
}

"""
Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
"""
type IpsLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Anti-Malware service license details (Legacy license, replaced by TP)"""
type MalwareProtectionLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""
NG Anti-Malware service license details (Legacy license, replaced by TP)
"""
type NextGenMalwareProtectionLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Threat Prevention (TP) license details"""
type ThreatPreventionLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""NOC as a Service (NOCaaS) service license details"""
type NOCaaSLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Cloud Access Security Broker (CASB) service license details"""
type CasbLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Data Loss Prevention (DLP) Service license details"""
type DlpLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Managed XDR service license details"""
type ManagedXdrLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""Remote Browser Isolation (RBI) service license details"""
type RbiLicense implements License {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
}

"""SaaS Security API service license details"""
type SaasSecurityApiLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """license quantity"""
  total: Int!
}

"""XDR Pro (extended detection and response) service license details"""
type XdrProLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """The number of knowledge users that the XDR Pro service refers to"""
  total: Int!
}

"""DEM Pro service license details"""
type DemProLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """License quantity"""
  total: Int!
}

"""DEM service license details"""
type DemLicense implements License & QuantifiableLicense {
  description: String
  """License expiration date"""
  expirationDate: DateTime!
  """The date of the last update to the license"""
  lastUpdated: DateTime
  """License plan type"""
  plan: LicensePlan!
  """The license SKU"""
  sku: LicenseSku!
  """License start date"""
  startDate: DateTime
  """License activation status"""
  status: LicenseStatus!
  """License quantity"""
  total: Int!
}
