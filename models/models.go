// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package cato_models

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/routebyintuition/cato-go-sdk/scalars"
)

type Activity interface {
	IsActivity()
	GetID() string
	GetResourceID() string
	GetParentResourceID() string
}

type Anomalies interface {
	IsMergedIncident()
	IsAnomalies()
	GetID() string
	GetFirstSignal() string
	GetLastSignal() string
	GetEngineType() *StoryEngineTypeEnum
	GetVendor() *VendorEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetConnectionType() *ConnectionTypeEnum
	GetIndication() string
	GetQueryName() *string
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSourceIP() *string
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDirection() *string
}

type CatoResource interface {
	IsEndpointResource()
	IsCatoResource()
	// Unique Cato ID for this EPP resource
	GetID() string
	// Timestamp that the this resource was used
	GetCreatedDateTime() *string
	// Enum for the remediation status associated with this resource
	GetRemediationStatus() *RemediationStatusEnum
}

// A group with members of a single type of entity (for example: IPAddress, FQDN)
type Container interface {
	IsContainer()
	// Unique container ID
	GetID() string
	// Name for the container
	GetName() string
	// Description for the container
	GetDescription() *string
	// Number of items in the container
	GetSize() int64
	// Audit metadata about the container
	GetAudit() *ContainerAudit
}

type DeviceDetails interface {
	IsDeviceDetails()
	GetID() string
	GetDeviceName() *string
	GetOsDetails() *OsDetails
	GetLoggedOnUsers() []EndpointUser
}

type Endpoint interface {
	IsMergedIncident()
	IsEndpoint()
	// Unique Cato ID for the story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Enum for the connection for this incident (ie. site, host, user)
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetSourceIP() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDevice() DeviceDetails
	GetAlerts() []EndpointAlert
}

type EndpointAlert interface {
	IsEndpointAlert()
	GetID() string
	GetTitle() *string
	GetDescription() *string
	GetThreatName() *string
	GetMitreTechnique() []*Mitre
	GetMitreSubTechnique() []*Mitre
	GetCreatedDateTime() *string
	GetResources() []EndpointResource
	GetActivities() []Activity
	GetCriticality() *int64
}

type EndpointResource interface {
	IsEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
}

type EndpointUser interface {
	IsEndpointUser()
	GetID() string
	GetName() string
}

type FileResource interface {
	IsEndpointResource()
	IsFileResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetFileDetails() *FileDetails
	GetDetectionStatus() *DetectionStatusEnum
}

type IContainerRef interface {
	IsObjectRef()
	IsIContainerRef()
	// Unique container ID
	GetID() string
	// Name for the container
	GetName() string
}

// Define settings for the Internet Firewall policy
type IPolicy interface {
	IsIPolicy()
	// TRUE = Policy is enabled, FALSE = Policy is disabled
	GetEnabled() bool
	// Return list of rules in the policy
	GetRules() []IPolicyRulePayload
	// Return sections in the policy
	GetSections() []*PolicySectionPayload
	// Audit data for the policy
	GetAudit() *PolicyAudit
	// Return data for the Policy revision
	GetRevision() *PolicyRevision
}

// Results of policy change
type IPolicyMutationPayload interface {
	IsIPolicyMutationPayload()
	// Data for the policy
	GetPolicy() IPolicy
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

type IPolicyRule interface {
	IsIPolicyRule()
	// Rule ID
	GetID() string
	// Name of the rule
	GetName() string
	// Description for the rule
	GetDescription() *string
	// Position / priority of rule
	GetIndex() int64
	// TRUE = Rule is enabled, FALSE = Rule is disabled
	GetEnabled() bool
	// Policy section where the rule is located
	GetSection() *PolicySectionInfo
}

// Results of rule change
type IPolicyRuleMutationPayload interface {
	IsIPolicyRuleMutationPayload()
	// Returns settings for the rule
	GetRule() IPolicyRulePayload
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

// Results of changes to the rule
type IPolicyRulePayload interface {
	IsIPolicyRulePayload()
	GetAudit() *PolicyElementAudit
	// Rule that was changed
	GetRule() IPolicyRule
	// Summary of rule change, (ie. ADDED, UPDATED)
	GetProperties() []PolicyElementPropertiesEnum
}

// An interface containing properties that are common to all license types
type License interface {
	IsLicense()
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License start date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
}

type MergedIncident interface {
	IsMergedIncident()
	// Unique Cato ID for each story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Enum for the connection for this incident (ie. site, host, user)
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
	//
	// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	GetCriticality() *int64
	// For Network stories - The site where the network issue is occurring
	//
	// For Security stories - IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	// The ticket an analyst created for this story
	GetTicket() *string
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	GetStatus() *StoryStatusEnum
	// The value is TRUE when the story is currently being researched by Security Analysts
	GetResearch() *bool
	// Site name related to the story
	GetSiteName() *string
	// Amount of time since the story was opened (no value for closed stories)
	GetStoryDuration() *int64
	// For Security stories, description of the threat
	GetDescription() *string
	// The source IP address of the device in your network sending or receiving the flow
	GetSourceIP() *string
	// Fields related to analysts research of the threat incident
	GetAnalystFeedback() *AnalystFeedback
	// Cato ID and name for the site
	GetSite() *SiteRef
	// Cato ID and name for the user
	GetUser() *UserRef
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
}

type MicrosoftEndpointResource interface {
	IsEndpointResource()
	IsMicrosoftEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetRemediationStatusDetails() *string
	GetTags() []string
	GetRoles() []ResourceRoleEnum
	GetVerdict() *MsResourceVerdictEnum
}

type ObjectRef interface {
	IsObjectRef()
	// Object's unique identifier
	GetID() string
	// Object's unique name
	GetName() string
}

type ProcessResource interface {
	IsEndpointResource()
	IsProcessResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetProcessID() int64
	GetProcessCommandLine() *string
	GetImageFile() *FileDetails
	GetUserAccount() EndpointUser
}

type QuantifiableLicense interface {
	IsLicense()
	IsQuantifiableLicense()
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License initiation date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
	// license quantity
	GetTotal() int64
}

type RegistryResource interface {
	IsEndpointResource()
	IsRegistryResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetHive() *string
	GetKey() *string
	GetValue() *string
	GetValueName() *string
	GetValueType() *string
}

type Value interface {
	IsValue()
}

type AccountDataPayload struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Subdomain string `json:"subdomain"`
}

type AccountIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type AccountMetrics struct {
	// Starting time
	From *string `json:"from,omitempty"`
	// The size of a single time bucket in seconds
	Granularity *int64 `json:"granularity,omitempty"`
	// Unique Identifier of Account.
	ID *string `json:"id,omitempty"`
	// Site connectivity metrics for the requested sites.
	Sites      []*SiteMetrics `json:"sites,omitempty"`
	Timeseries []*Timeseries  `json:"timeseries,omitempty"`
	// Ending time
	To *string `json:"to,omitempty"`
	// Connectivity metrics for the requested users connecting remotely with the Client.
	// Doesn’t include user traffic behind a site.
	Users []*SiteMetrics `json:"users,omitempty"`
}

type AccountRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AccountRef) IsObjectRef() {}

// Object's unique identifier
func (this AccountRef) GetID() string { return this.ID }

// Object's unique name
func (this AccountRef) GetName() string { return this.Name }

type AccountRolesResult struct {
	Items []*RBACRole `json:"items"`
	Total int64       `json:"total"`
}

type AccountSnapshot struct {
	// Unique Identifier of Account
	ID *string `json:"id,omitempty"`
	// Sites includes information about online as well as offline sites
	Sites     []*SiteSnapshot `json:"sites,omitempty"`
	Timestamp *string         `json:"timestamp,omitempty"`
	// VPN users information includes only connected users by default (Unlike sites), unless specific ID is requested
	Users []*UserSnapshot `json:"users,omitempty"`
}

type AddAdminInput struct {
	Email                string                  `json:"email"`
	FirstName            string                  `json:"firstName"`
	LastName             string                  `json:"lastName"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           bool                    `json:"mfaEnabled"`
	PasswordNeverExpires bool                    `json:"passwordNeverExpires"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddIpsecIkeV2SiteInput struct {
	Description *string `json:"description,omitempty"`
	// The name of the site
	Name string `json:"name"`
	// The native range of the site
	NativeNetworkRange string `json:"nativeNetworkRange"`
	// The location of the site
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
	// Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER.
	SiteType SiteType `json:"siteType"`
}

type AddIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                           `json:"fqdn,omitempty"`
	Tunnels []*AddIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type AddIpsecIkeV2SitePayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteTunnelPayload struct {
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *AddIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *AddIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsPayload struct {
	// Cato’s FQDN for the primary tunnel
	Primary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// Cato’s FQDN for the secondary tunnel
	Secondary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2TunnelInput struct {
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk string `json:"psk"`
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
}

type AddIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The PoP location ID
	PopLocationID *string `json:"popLocationId,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string                     `json:"publicCatoIpId,omitempty"`
	Tunnels        []*AddIpsecIkeV2TunnelInput `json:"tunnels"`
}

type AddNetworkRangeInput struct {
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway *string `json:"gateway,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector    *bool      `json:"mdnsReflector,omitempty"`
	Name             string     `json:"name"`
	RangeType        SubnetType `json:"rangeType"`
	Subnet           string     `json:"subnet"`
	TranslatedSubnet *string    `json:"translatedSubnet,omitempty"`
	// Only relevant for VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
}

type AddNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type AddSiteLocationInput struct {
	// optional address
	Address *string `json:"address,omitempty"`
	// city name, must belong to the country or country and state
	City *string `json:"city,omitempty"`
	// country code
	CountryCode string `json:"countryCode"`
	// optional state code
	StateCode *string `json:"stateCode,omitempty"`
	// time zone
	Timezone string `json:"timezone"`
}

type AddSocketSiteInput struct {
	ConnectionType     SiteConnectionTypeEnum `json:"connectionType"`
	Description        *string                `json:"description,omitempty"`
	Name               string                 `json:"name"`
	NativeNetworkRange string                 `json:"nativeNetworkRange"`
	SiteLocation       *AddSiteLocationInput  `json:"siteLocation"`
	SiteType           SiteType               `json:"siteType"`
	TranslatedSubnet   *string                `json:"translatedSubnet,omitempty"`
}

type AddSocketSitePayload struct {
	SiteID string `json:"siteId"`
}

type AddStaticHostInput struct {
	IP         string  `json:"ip"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       string  `json:"name"`
}

type AddStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// A CC2 administrator
type Admin struct {
	AllowedItems          []*Entity          `json:"allowedItems,omitempty"`
	CreationDate          *string            `json:"creationDate,omitempty"`
	Email                 *string            `json:"email,omitempty"`
	FirstName             *string            `json:"firstName,omitempty"`
	ID                    string             `json:"id"`
	LastName              *string            `json:"lastName,omitempty"`
	ManagedRoles          []*AdminRole       `json:"managedRoles,omitempty"`
	MfaEnabled            *bool              `json:"mfaEnabled,omitempty"`
	ModifyDate            *string            `json:"modifyDate,omitempty"`
	NativeAccountID       *string            `json:"nativeAccountID,omitempty"`
	PasswordNeverExpires  *bool              `json:"passwordNeverExpires,omitempty"`
	PresentUsageAndEvents *bool              `json:"presentUsageAndEvents,omitempty"`
	ResellerRoles         []*AdminRole       `json:"resellerRoles,omitempty"`
	Role                  *UserRole          `json:"role,omitempty"`
	Status                *OperationalStatus `json:"status,omitempty"`
	Version               string             `json:"version"`
}

type AdminMutations struct {
	AddAdmin    *AddAdminPayload    `json:"addAdmin,omitempty"`
	RemoveAdmin *RemoveAdminPayload `json:"removeAdmin,omitempty"`
	UpdateAdmin *UpdateAdminPayload `json:"updateAdmin,omitempty"`
}

type AdminRole struct {
	AllowedAccounts []string  `json:"allowedAccounts,omitempty"`
	AllowedEntities []*Entity `json:"allowedEntities,omitempty"`
	Role            *RBACRole `json:"role"`
}

type AdminsResult struct {
	Items []*Admin `json:"items"`
	Total int64    `json:"total"`
}

type AnalystFeedback struct {
	AdditionalInfo       *string                    `json:"additionalInfo,omitempty"`
	Severity             *SeverityEnum              `json:"severity,omitempty"`
	ThreatClassification *string                    `json:"threatClassification,omitempty"`
	ThreatType           *AnalystFeedbackThreatType `json:"threatType,omitempty"`
	Verdict              *StoryVerdictEnum          `json:"verdict,omitempty"`
}

type AnalystFeedbackThreatType struct {
	Details           *string `json:"details,omitempty"`
	Name              *string `json:"name,omitempty"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

type AnalystInfo struct {
	// Security analyst email address
	Email *string `json:"email,omitempty"`
	// Security analyst name
	Name *string `json:"name,omitempty"`
}

type AnomalyEvents struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyEvents) IsAnomalies()                                {}
func (this AnomalyEvents) GetID() string                          { return this.ID }
func (this AnomalyEvents) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyEvents) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyEvents) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyEvents) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyEvents) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyEvents) GetProducerName() string                { return this.ProducerName }
func (this AnomalyEvents) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyEvents) GetIndication() string                  { return this.Indication }
func (this AnomalyEvents) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyEvents) GetSource() *string                     { return this.Source }
func (this AnomalyEvents) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyEvents) GetTicket() *string                     { return this.Ticket }
func (this AnomalyEvents) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyEvents) GetResearch() *bool                     { return this.Research }
func (this AnomalyEvents) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyEvents) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyEvents) GetDescription() *string                { return this.Description }
func (this AnomalyEvents) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyEvents) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyEvents) GetUser() *UserRef                      { return this.User }
func (this AnomalyEvents) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyEvents) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyEvents) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyEvents) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyEvents) GetDirection() *string                  { return this.Direction }

func (AnomalyEvents) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type AnomalyStats struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyStats) IsAnomalies()                                {}
func (this AnomalyStats) GetID() string                          { return this.ID }
func (this AnomalyStats) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyStats) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyStats) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyStats) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyStats) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyStats) GetProducerName() string                { return this.ProducerName }
func (this AnomalyStats) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyStats) GetIndication() string                  { return this.Indication }
func (this AnomalyStats) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyStats) GetSource() *string                     { return this.Source }
func (this AnomalyStats) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyStats) GetTicket() *string                     { return this.Ticket }
func (this AnomalyStats) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyStats) GetResearch() *bool                     { return this.Research }
func (this AnomalyStats) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyStats) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyStats) GetDescription() *string                { return this.Description }
func (this AnomalyStats) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyStats) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyStats) GetUser() *UserRef                      { return this.User }
func (this AnomalyStats) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyStats) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyStats) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyStats) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyStats) GetDirection() *string                  { return this.Direction }

func (AnomalyStats) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type AppStats struct {
	From    *string                `json:"from,omitempty"`
	ID      *string                `json:"id,omitempty"`
	Records []*AppStatsRecord      `json:"records,omitempty"`
	To      *string                `json:"to,omitempty"`
	Total   *int64                 `json:"total,omitempty"`
	Totals  map[string]interface{} `json:"totals,omitempty"`
}

type AppStatsField struct {
	Name  AppStatsFieldName `json:"name"`
	Value Value             `json:"value"`
}

type AppStatsFilter struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Operator  FilterOperator    `json:"operator"`
	Values    []string          `json:"values"`
}

type AppStatsRecord struct {
	Fields []*AppStatsField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap       map[string]interface{} `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType             `json:"fieldsUnitTypes,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields    [][]string             `json:"flatFields,omitempty"`
	PrevTimeFrame map[string]interface{} `json:"prevTimeFrame,omitempty"`
	Trends        map[string]interface{} `json:"trends,omitempty"`
}

type AppStatsSort struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Order     DirectionEnum     `json:"order"`
}

type AppStatsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type ApplicationCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationCategoryRef) GetName() string { return this.Name }

type ApplicationCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationRef) GetName() string { return this.Name }

type ApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AuditFeed struct {
	Accounts     []*AuditFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                      `json:"fetchedCount"`
	From         *string                    `json:"from,omitempty"`
	HasMore      *bool                      `json:"hasMore,omitempty"`
	Marker       *string                    `json:"marker,omitempty"`
	To           *string                    `json:"to,omitempty"`
}

type AuditFeedAccountRecords struct {
	ID      *string        `json:"id,omitempty"`
	Records []*AuditRecord `json:"records,omitempty"`
}

type AuditField struct {
	Name  string `json:"name"`
	Value Value  `json:"value"`
}

type AuditFieldFilterInput struct {
	FieldName *FieldNameInput `json:"fieldName"`
	// Use AuditFieldName for audits
	Operator ElasticOperator `json:"operator"`
	Values   []string        `json:"values,omitempty"`
}

// Represents a single event in the audit database
type AuditRecord struct {
	Account *EntityInfo `json:"account,omitempty"`
	Admin   *Entity     `json:"admin,omitempty"`
	APIKey  *Entity     `json:"apiKey,omitempty"`
	// All fields in the audit record (including the admin and object)
	Fields []*AuditField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap map[string]interface{} `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
	Object     *Entity    `json:"object,omitempty"`
	Time       *string    `json:"time,omitempty"`
}

type BGPConnection struct {
	CatoAsn        *scalars.Asn16 `json:"catoAsn,omitempty"`
	CatoIP         *string        `json:"catoIp,omitempty"`
	ConnectionName *string        `json:"connectionName,omitempty"`
	PeerAsn        *scalars.Asn32 `json:"peerAsn,omitempty"`
	PeerIP         *string        `json:"peerIp,omitempty"`
}

type BooleanPredicate struct {
	Is string `json:"is"`
}

// Cloud Access Security Broker (CASB) service license details
type CasbLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (CasbLicense) IsLicense()                   {}
func (this CasbLicense) GetDescription() *string { return this.Description }

// License plan type
func (this CasbLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this CasbLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this CasbLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this CasbLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this CasbLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this CasbLicense) GetLastUpdated() *string { return this.LastUpdated }

type CatoActivity struct {
	// Unique Cato ID for this activity
	ID string `json:"id"`
	// Unique Cato ID for the preceding resource (process or file) in the alert
	ParentResourceID string `json:"parentResourceId"`
	// Unique Cato ID for the resource (process or file) involved in the alert
	ResourceID string `json:"resourceId"`
}

func (CatoActivity) IsActivity()                      {}
func (this CatoActivity) GetID() string               { return this.ID }
func (this CatoActivity) GetResourceID() string       { return this.ResourceID }
func (this CatoActivity) GetParentResourceID() string { return this.ParentResourceID }

type CatoEndpoint struct {
	// Details for the threat detected by the EPP
	Alerts []*CatoEndpointAlert `json:"alerts"`
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// enum for the connection for this incident (ie. host, user)
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Details for the EPP device (ie. device name, OS, MAC address)
	Device *CatoEndpointDeviceDetails `json:"device,omitempty"`
	// enum that shows XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// ID for the Endpoint Protection story
	ID string `json:"id"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string `json:"indication"`
	// Timestamp for the last (most recent) incident signal related to this story
	LastSignal          string            `json:"lastSignal"`
	PredictedThreatType *string           `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum `json:"predictedVerdict,omitempty"`
	// enum for the Producer (specific XDR engine or service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string  `json:"producerName"`
	QueryName    *string `json:"queryName,omitempty"`
	// TRUE indicates that the story is currently being researched by Security Analysts
	Research           *bool               `json:"research,omitempty"`
	SimilarStoriesData []*SimilarStoryData `json:"similarStoriesData"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// Source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	Status *StoryStatusEnum `json:"status,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// The ticket for this story
	Ticket *string `json:"ticket,omitempty"`
	// Cato ID and name for the site
	User *UserRef `json:"user,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
}

func (CatoEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this CatoEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this CatoEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this CatoEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this CatoEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this CatoEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this CatoEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this CatoEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this CatoEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this CatoEndpoint) GetSource() *string                   { return this.Source }
func (this CatoEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this CatoEndpoint) GetTicket() *string                   { return this.Ticket }
func (this CatoEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this CatoEndpoint) GetResearch() *bool                   { return this.Research }
func (this CatoEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this CatoEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this CatoEndpoint) GetDescription() *string              { return this.Description }
func (this CatoEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this CatoEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this CatoEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this CatoEndpoint) GetUser() *UserRef                    { return this.User }
func (this CatoEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this CatoEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this CatoEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this CatoEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (CatoEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type CatoEndpointAlert struct {
	// Unique Cato IDs for the activities related to the alert
	Activities []*CatoActivity `json:"activities"`
	// Timestamp that the threat was detected and the alert generated
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// EPP profile that is assigned to this device
	EndpointProtectionProfile *string `json:"endpointProtectionProfile,omitempty"`
	// Enum for the EPP engine related to this story
	EngineType *CatoEndpointEngineType `json:"engineType,omitempty"`
	// Unique Cato ID for the Endpoint Protection story
	ID string `json:"id"`
	// MITRE ATT&CK® sub-technique for the threat
	MitreSubTechnique []*Mitre `json:"mitreSubTechnique"`
	// MITRE ATT&CK® technique for the threat
	MitreTechnique []*Mitre `json:"mitreTechnique"`
	// Data for the remediation status of the alert
	Resources []CatoResource `json:"resources"`
	// Enum for the remediation status of the EPP alert
	Status *RemediationStatusEnum `json:"status,omitempty"`
	// Name of threat detected on the device
	ThreatName *string `json:"threatName,omitempty"`
	// Title of the endpoint alert
	Title *string `json:"title,omitempty"`
}

func (CatoEndpointAlert) IsEndpointAlert()             {}
func (this CatoEndpointAlert) GetID() string           { return this.ID }
func (this CatoEndpointAlert) GetTitle() *string       { return this.Title }
func (this CatoEndpointAlert) GetDescription() *string { return this.Description }
func (this CatoEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this CatoEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCriticality() *int64 { return this.Criticality }

type CatoEndpointDeviceDetails struct {
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// Unique Cato ID for this story
	ID string `json:"id"`
	// Data for one or more users logged in to the device
	LoggedOnUsers []EndpointUser `json:"loggedOnUsers"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
	// OS data (ie. type, build, version)
	OsDetails *OsDetails `json:"osDetails,omitempty"`
}

func (CatoEndpointDeviceDetails) IsDeviceDetails()              {}
func (this CatoEndpointDeviceDetails) GetID() string            { return this.ID }
func (this CatoEndpointDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this CatoEndpointDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this CatoEndpointDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type CatoEndpointUser struct {
	// ID for the user
	ID string `json:"id"`
	// Username for the user whose activity generated the indication
	Name string `json:"name"`
}

func (CatoEndpointUser) IsEndpointUser()      {}
func (this CatoEndpointUser) GetID() string   { return this.ID }
func (this CatoEndpointUser) GetName() string { return this.Name }

type CatoFileResource struct {
	// Timestamp that the this file resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Enum for the detection status of this file resource
	DetectionStatus *DetectionStatusEnum `json:"detectionStatus,omitempty"`
	// Details of the file related to this resource
	FileDetails *FileDetails `json:"fileDetails,omitempty"`
	// Unique Cato ID for this file resource
	ID string `json:"id"`
	// Enum for the remediation status associated with this file resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
}

func (CatoFileResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoFileResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoFileResource) IsEndpointResource() {}

func (CatoFileResource) IsFileResource() {}

func (this CatoFileResource) GetFileDetails() *FileDetails             { return this.FileDetails }
func (this CatoFileResource) GetDetectionStatus() *DetectionStatusEnum { return this.DetectionStatus }

type CatoProcessResource struct {
	// Timestamp that the this resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Unique Cato ID for this resource
	ID string `json:"id"`
	// Details of the file related to this process
	ImageFile *FileDetails `json:"imageFile,omitempty"`
	// CLI command related to this process
	ProcessCommandLine *string `json:"processCommandLine,omitempty"`
	// ID for the process
	ProcessID int64 `json:"processId"`
	// Enum for the remediation status associated with this resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	// User account related to this process
	UserAccount EndpointUser `json:"userAccount,omitempty"`
}

func (CatoProcessResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoProcessResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoProcessResource) IsEndpointResource() {}

func (CatoProcessResource) IsProcessResource() {}

func (this CatoProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this CatoProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this CatoProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this CatoProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

type CellularInterface struct {
	// Represents the Access Point Name (e.g., uwap.orange.co.il). Configurable from Socket WebUI or SIM switch.
	Apn *string `json:"apn,omitempty"`
	// Determines how the APN is selected. Valid values are Auto or Manual (configurable in WebUI).
	ApnSelectionMethod *ApnMethod `json:"apnSelectionMethod,omitempty"`
	// Displays the reason for the modem disconnecting. Valid values are 0 (No reason provided) or 1 (The session timed out).
	DisconnectionReason *CellularDisconnectionReason `json:"disconnectionReason,omitempty"`
	// Unique identifier (20-digit number) for the modem.
	Iccid *string `json:"iccid,omitempty"`
	// Unique identifier (15-digit number) for a specific SIM.
	Imei *string `json:"imei,omitempty"`
	// Indicates if the cellular modem is currently connected to the internet.
	IsModemConnected bool `json:"isModemConnected"`
	// Indicates if the modem is currently suspended.
	IsModemSuspended bool `json:"isModemSuspended"`
	// Indicates whether roaming is enabled.
	IsRoamingAllowed bool `json:"isRoamingAllowed"`
	// Indicates whether a SIM is detected in the first slot.
	IsSimSlot1Detected bool `json:"isSimSlot1Detected"`
	// Indicates whether a SIM is detected in the second slot.
	IsSimSlot2Detected bool `json:"isSimSlot2Detected"`
	// Represents the current status of the modem. Valid values are Error, OK, or Unknown.
	ModemStatus *CellularModemStatus `json:"modemStatus,omitempty"`
	// 2G, 3G, or 4G
	NetworkType *CellularNetworkType `json:"networkType,omitempty"`
	// Displays the operator or carrier name, such as Verizon.
	OperatorName *string `json:"operatorName,omitempty"`
	// Represents the signal strength of the cellular connection, in units of calculation.
	SignalStrength *string `json:"signalStrength,omitempty"`
	// The phone number associated with the SIM.
	SimNumber *string `json:"simNumber,omitempty"`
	// Shows the currently active SIM slot; the other slot is in standby. Slot 1 is active by default.
	SimSlotID *int64 `json:"simSlotId,omitempty"`
}

// Audit metadata about the container
type ContainerAudit struct {
	// Indicates when the container was created
	CreatedAt string `json:"createdAt"`
	// Indicates who created the container
	CreatedBy string `json:"createdBy"`
	// Indicated when the container was last updated
	LastModifiedAt string `json:"lastModifiedAt"`
	// Indicates who was the last to update the container
	LastModifiedBy string `json:"lastModifiedBy"`
}

type ContainerMutations struct {
	Delete         *DeleteContainerPayload           `json:"delete"`
	Fqdn           *FqdnContainerMutations           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerMutations `json:"ipAddressRange"`
}

type ContainerQueries struct {
	Fqdn           *FqdnContainerQueries           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerQueries `json:"ipAddressRange"`
	List           *ContainerSearchPayload         `json:"list"`
}

// A group with members of a single type of entity (for example: IP, FQDN)
type ContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (ContainerRef) IsObjectRef() {}

// Object's unique identifier
func (this ContainerRef) GetID() string { return this.ID }

// Object's unique name
func (this ContainerRef) GetName() string { return this.Name }

// Add a container by ID or name
type ContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Filtering input to container search
type ContainerSearchInput struct {
	// Allows filtering container search by container ID or container name
	Refs []*ContainerRefInput `json:"refs"`
	// Allows filtering container search by specific container types
	Types []ContainerType `json:"types"`
}

// Container search result, including all containers that matched input criteria
type ContainerSearchPayload struct {
	// A list of matched containers
	Containers []Container `json:"containers"`
}

type CountryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CountryRef) IsObjectRef() {}

// Object's unique identifier
func (this CountryRef) GetID() string { return this.ID }

// Object's unique name
func (this CountryRef) GetName() string { return this.Name }

type CountryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Input for creating FQDN typed container from file
type CreateFqdnContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// Name for the container
	Name string `json:"name"`
	// Multipart file containing FQDNs with csv/newline delimiter
	UploadFile graphql.Upload `json:"uploadFile"`
}

// Payload of CreateFromFile operation on FQDN typed container
type CreateFqdnContainerFromFilePayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

// Input for creating IPAddressRange typed container from file
type CreateIPAddressRangeContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// Name for the container
	Name string `json:"name"`
	// Multipart file containing IPAddressRanges with csv/newline delimiter
	UploadFile graphql.Upload `json:"uploadFile"`
}

// Payload of CreateFromFile operation on IPAddressRange typed container
type CreateIPAddressRangeContainerFromFilePayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type CustomApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomApplicationRef) GetName() string { return this.Name }

type CustomApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type CustomCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomCategoryRef) GetName() string { return this.Name }

type CustomCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomService struct {
	Port      []scalars.Port `json:"port,omitempty"`
	PortRange *PortRange     `json:"portRange,omitempty"`
	Protocol  IPProtocol     `json:"protocol"`
}

// Add a Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomServiceInput struct {
	Port      []scalars.Port  `json:"port,omitempty"`
	PortRange *PortRangeInput `json:"portRange,omitempty"`
	Protocol  IPProtocol      `json:"protocol"`
}

type DataLakeLicense struct {
	Description *string `json:"description,omitempty"`
	// The version of the Data Processing Agreement (DPA) that your company signed with Cato.
	DpaVersion DpaVersion `json:"dpaVersion"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// Data retention period, in months, during which the account data may remain on the Cato Cloud. After this period the data will be permanently deleted.
	RetentionPeriod *int64 `json:"retentionPeriod,omitempty"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Total number of the Data Storage Units under this license. Each Data Storage Unit increases the allowed ingestion rate (events per hour and total events storage)
	Total int64 `json:"total"`
}

func (DataLakeLicense) IsLicense()                   {}
func (this DataLakeLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DataLakeLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DataLakeLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DataLakeLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DataLakeLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DataLakeLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DataLakeLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DataLakeLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DataLakeLicense) GetTotal() int64 { return this.Total }

type DateValue struct {
	Date *string `json:"date,omitempty"`
}

func (DateValue) IsValue() {}

// Identification of container for delete operation
type DeleteContainerInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

type DeleteContainerPayload struct {
	// The data of the container before it was deleted
	Container Container `json:"container"`
}

// DEM service license details
type DemLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License quantity
	Total int64 `json:"total"`
}

func (DemLicense) IsLicense()                   {}
func (this DemLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DemLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DemLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DemLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DemLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DemLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DemLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DemLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DemLicense) GetTotal() int64 { return this.Total }

// DEM Pro service license details
type DemProLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License quantity
	Total int64 `json:"total"`
}

func (DemProLicense) IsLicense()                   {}
func (this DemProLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DemProLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DemProLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DemProLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DemProLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DemProLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DemProLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DemProLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DemProLicense) GetTotal() int64 { return this.Total }

type DeviceProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DeviceProfileRef) IsObjectRef() {}

// Object's unique identifier
func (this DeviceProfileRef) GetID() string { return this.ID }

// Object's unique name
func (this DeviceProfileRef) GetName() string { return this.Name }

type DeviceProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DeviceSnapshot struct {
	// A boolean value that indicates if the site is connected to the Cato Cloud
	Connected *bool `json:"connected,omitempty"`
	// For connected devices (this somewhat overlaps to last duration)
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// Shows if this is the primary or secondary Socket in high availability mode
	HaRole *string `json:"haRole,omitempty"`
	// Unique internal Cato ID for the Socket
	ID *string `json:"id,omitempty"`
	// Unique identifier for the device
	Identifier *string `json:"identifier,omitempty"`
	// Snapshot data for outbound facing interfaces
	Interfaces []*InterfaceSnapshot `json:"interfaces,omitempty"`
	// Information of the link state of various interfaces in the devices. Unlike the `interfacess` field, it contains
	//    all links of the device, not just the outbound facing ones
	InterfacesLinkState []*InterfaceLinkState `json:"interfacesLinkState,omitempty"`
	// Device's internal IP in the account's routing table
	InternalIP *string `json:"internalIP,omitempty"`
	// The last time the device was seen
	LastConnected *string `json:"lastConnected,omitempty"`
	// The uptime of the last tunnel from this device (or current), in seconds
	LastDuration *int64 `json:"lastDuration,omitempty"`
	// The ID of the PoP that the Socket is connected to
	LastPopID *int64 `json:"lastPopID,omitempty"`
	// The PoP name that the Socket is connected to
	LastPopName *string `json:"lastPopName,omitempty"`
	// The time the mfa cookie (for sdp users) was created
	MfaCreationTime *int64 `json:"mfaCreationTime,omitempty"`
	// Shows the amount of time remaining before the MFA token expires
	MfaExpirationTime *int64 `json:"mfaExpirationTime,omitempty"`
	// Name of the device
	Name *string `json:"name,omitempty"`
	// Operating system of the Device.
	OsType *string `json:"osType,omitempty"`
	// Version of the Socket operating system
	OsVersion *string `json:"osVersion,omitempty"`
	// Data related to the most recent completed traffic flows
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
	// Shows the release group for the site
	ReleaseGroup *string `json:"releaseGroup,omitempty"`
	// Shows data related to the Socket, such as version and serial number
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// Shows the Socket model or vSocket type
	Type *string `json:"type,omitempty"`
	// Device version
	Version *string `json:"version,omitempty"`
	// Device major version
	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

type Dimension struct {
	FieldName AppStatsFieldName `json:"fieldName"`
}

type DimensionData struct {
	// Type of the dimension
	Label string `json:"label"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

type DimensionKey struct {
	// Dimension field
	FieldName string `json:"fieldName"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

// Data Loss Prevention (DLP) Service license details
type DlpLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (DlpLicense) IsLicense()                   {}
func (this DlpLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DlpLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DlpLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DlpLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DlpLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DlpLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DlpLicense) GetLastUpdated() *string { return this.LastUpdated }

// Input for searching FQDN typed container to download its content
type DownloadFqdnContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download FQDN typed container file
type DownloadFqdnContainerFilePayload struct {
	// Content of a file encoded in base64 format
	EncodedFile string `json:"encodedFile"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

// Input for searching IPAddressRange typed container to download its content
type DownloadIPAddressRangeContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download IPAddressRange typed container file
type DownloadIPAddressRangeContainerFilePayload struct {
	// Content of a file encoded in base64 format
	EncodedFile string `json:"encodedFile"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

// End Point Protection (EPP) license details
type EndpointProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The maximum number of users that can use this service
	Total int64 `json:"total"`
}

func (EndpointProtectionLicense) IsLicense()                   {}
func (this EndpointProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this EndpointProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this EndpointProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this EndpointProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this EndpointProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this EndpointProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this EndpointProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

func (EndpointProtectionLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this EndpointProtectionLicense) GetTotal() int64 { return this.Total }

type EngineTypePredicate struct {
	In    []StoryEngineTypeEnum `json:"in,omitempty"`
	NotIn []StoryEngineTypeEnum `json:"not_in,omitempty"`
}

type Entity struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

func (Entity) IsValue() {}

type EntityInfo struct {
	Description  string                 `json:"description"`
	Entity       *Entity                `json:"entity"`
	HelperFields map[string]interface{} `json:"helperFields"`
}

type EntityInput struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

type EntityLookupResult struct {
	Items []*EntityInfo `json:"items"`
	Total *int64        `json:"total,omitempty"`
}

type Event struct {
	Action                *string     `json:"action,omitempty"`
	AppID                 *string     `json:"appId,omitempty"`
	AppName               *string     `json:"appName,omitempty"`
	DNSProtectionCategory *string     `json:"dnsProtectionCategory,omitempty"`
	EventType             *string     `json:"eventType,omitempty"`
	RuleID                *string     `json:"ruleId,omitempty"`
	ScanResult            *ScanResult `json:"scanResult,omitempty"`
	Severity              *string     `json:"severity,omitempty"`
	SignatureID           *string     `json:"signatureId,omitempty"`
	ThreatName            *string     `json:"threatName,omitempty"`
	ThreatType            *string     `json:"threatType,omitempty"`
	VirusName             *string     `json:"virusName,omitempty"`
}

type EventFeedFieldFilterInput struct {
	FieldName EventFeedFilterFieldName `json:"fieldName"`
	// Use event_type and event_sub_type for events
	Operator EventFeedFilterOperator `json:"operator"`
	Values   []string                `json:"values,omitempty"`
}

type EventField struct {
	Name  EventFieldName `json:"name"`
	Value Value          `json:"value"`
}

type EventRecord struct {
	// fields in map format (see Map scalar)
	FieldsMap map[string]interface{} `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
	Time       *string    `json:"time,omitempty"`
}

type Events struct {
	From    *string                `json:"from,omitempty"`
	ID      *string                `json:"id,omitempty"`
	Records []*EventsRecord        `json:"records,omitempty"`
	To      *string                `json:"to,omitempty"`
	Total   *int64                 `json:"total,omitempty"`
	Totals  map[string]interface{} `json:"totals,omitempty"`
}

type EventsDimension struct {
	FieldName EventFieldName `json:"fieldName"`
}

type EventsFeedAccountRecords struct {
	ErrorString *string        `json:"errorString,omitempty"`
	ID          *string        `json:"id,omitempty"`
	Records     []*EventRecord `json:"records,omitempty"`
}

type EventsFeedData struct {
	Accounts     []*EventsFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                       `json:"fetchedCount"`
	Marker       *string                     `json:"marker,omitempty"`
}

type EventsFilter struct {
	FieldName EventFieldName `json:"fieldName"`
	Operator  FilterOperator `json:"operator"`
	Values    []string       `json:"values"`
}

type EventsMeasure struct {
	AggType   AggregationType `json:"aggType"`
	FieldName EventFieldName  `json:"fieldName"`
	Trend     *bool           `json:"trend,omitempty"`
}

type EventsRecord struct {
	Fields []*EventField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap       map[string]interface{} `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType             `json:"fieldsUnitTypes,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields    [][]string             `json:"flatFields,omitempty"`
	PrevTimeFrame map[string]interface{} `json:"prevTimeFrame,omitempty"`
	Trends        map[string]interface{} `json:"trends,omitempty"`
}

type EventsSort struct {
	FieldName EventFieldName `json:"fieldName"`
	Order     DirectionEnum  `json:"order"`
}

type EventsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type Extra struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

// FieldName for the different types of FieldName inputs
// Use the EventFieldName for events, and AuditFieldName for audit
type FieldNameInput struct {
	AuditFieldName *AuditFieldName `json:"AuditFieldName,omitempty"`
	EventFieldName *EventFieldName `json:"EventFieldName,omitempty"`
}

type FileDetails struct {
	Issuer    *string `json:"issuer,omitempty"`
	Md5       *string `json:"md5,omitempty"`
	Name      *string `json:"name,omitempty"`
	Path      *string `json:"path,omitempty"`
	Publisher *string `json:"publisher,omitempty"`
	Sha1      *string `json:"sha1,omitempty"`
	Sha256    *string `json:"sha256,omitempty"`
	Signer    *string `json:"signer,omitempty"`
	Size      *int64  `json:"size,omitempty"`
}

// Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRef struct {
	// Unique Floating Subnet ID
	ID string `json:"id"`
	// Name for the Floating Subnet
	Name string `json:"name"`
}

func (FloatingSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this FloatingSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this FloatingSubnetRef) GetName() string { return this.Name }

// Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// A group with members of FQDN type
type FqdnContainer struct {
	// Audit metadata about the container
	Audit *ContainerAudit `json:"audit"`
	// Description for the container
	Description *string `json:"description,omitempty"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
	// Number of items in the container
	Size int64 `json:"size"`
}

func (FqdnContainer) IsContainer() {}

// Unique container ID
func (this FqdnContainer) GetID() string { return this.ID }

// Name for the container
func (this FqdnContainer) GetName() string { return this.Name }

// Description for the container
func (this FqdnContainer) GetDescription() *string { return this.Description }

// Number of items in the container
func (this FqdnContainer) GetSize() int64 { return this.Size }

// Audit metadata about the container
func (this FqdnContainer) GetAudit() *ContainerAudit { return this.Audit }

// Input for adding values to existing FQDN typed container
type FqdnContainerAddValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of AddValues operation on FQDN typed container
type FqdnContainerAddValuesPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type FqdnContainerMutations struct {
	AddValues      *FqdnContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateFqdnContainerFromFilePayload `json:"createFromFile"`
	RemoveValues   *FqdnContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateFqdnContainerFromFilePayload `json:"updateFromFile"`
}

type FqdnContainerQueries struct {
	DownloadFile *DownloadFqdnContainerFilePayload `json:"downloadFile"`
	Search       *FqdnContainerSearchPayload       `json:"search"`
	SearchFqdn   *FqdnContainerSearchFqdnPayload   `json:"searchFqdn"`
}

// A group with members of FQDN type
type FqdnContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (FqdnContainerRef) IsIContainerRef() {}

// Unique container ID
func (this FqdnContainerRef) GetID() string { return this.ID }

// Name for the container
func (this FqdnContainerRef) GetName() string { return this.Name }

func (FqdnContainerRef) IsObjectRef() {}

// Object's unique identifier

// Object's unique name

type FqdnContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Input for removing values from existing FQDN typed container
type FqdnContainerRemoveValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of RemoveValues operation on FQDN typed container
type FqdnContainerRemoveValuesPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

// Input for searching FQDN typed containers that contain a specific FQDN
type FqdnContainerSearchFqdnInput struct {
	Fqdn string `json:"fqdn"`
}

// Payload of FQDN search query
type FqdnContainerSearchFqdnPayload struct {
	// List of containers with members of type FQDN
	Containers []*FqdnContainer `json:"containers"`
}

// Input for searching FQDN typed container
type FqdnContainerSearchInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

// Payload of FQDN container search
type FqdnContainerSearchPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type FreeTextFilterInput struct {
	Search string `json:"search"`
}

type Gaussian struct {
	Avg    *float64 `json:"avg,omitempty"`
	N      *float64 `json:"n,omitempty"`
	Ss     *float64 `json:"ss,omitempty"`
	Std    *float64 `json:"std,omitempty"`
	ZScore *float64 `json:"z_score,omitempty"`
}

type GetAdminPayload struct {
	CreationDate         string       `json:"creationDate"`
	Email                string       `json:"email"`
	FirstName            string       `json:"firstName"`
	ID                   string       `json:"id"`
	LastName             string       `json:"lastName"`
	ManagedRoles         []*AdminRole `json:"managedRoles,omitempty"`
	MfaEnabled           bool         `json:"mfaEnabled"`
	PasswordNeverExpires bool         `json:"passwordNeverExpires"`
	ResellerRoles        []*AdminRole `json:"resellerRoles,omitempty"`
}

type GlobalIPRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalIPRangeRef) IsObjectRef() {}

// Object's unique identifier
func (this GlobalIPRangeRef) GetID() string { return this.ID }

// Object's unique name
func (this GlobalIPRangeRef) GetName() string { return this.Name }

type GlobalIPRangeRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// License usage and allocation across all accounts
type GlobalLicenseAllocations struct {
	// Public IP addresses usage across the accounts
	PublicIps *PublicIpsLicenseAllocations `json:"publicIps,omitempty"`
	// ZTNA license allocation across the accounts
	ZtnaUsers *ZtnaUsersLicenseAllocations `json:"ztnaUsers,omitempty"`
}

type GroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GroupRef) IsObjectRef() {}

// Object's unique identifier
func (this GroupRef) GetID() string { return this.ID }

// Object's unique name
func (this GroupRef) GetName() string { return this.Name }

type GroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Basic Site Ha readiness information
type HaStatus struct {
	Keepalive       *HaSubStatus `json:"keepalive,omitempty"`
	Readiness       *HaReadiness `json:"readiness,omitempty"`
	SocketVersion   *HaSubStatus `json:"socketVersion,omitempty"`
	WanConnectivity *HaSubStatus `json:"wanConnectivity,omitempty"`
}

type HardwareManagementQueries struct {
	// Retrieve the account socket inventory
	SocketInventory *SocketInventoryPayload `json:"socketInventory"`
}

type HostRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (HostRef) IsObjectRef() {}

// Object's unique identifier
func (this HostRef) GetID() string { return this.ID }

// Object's unique name
func (this HostRef) GetName() string { return this.Name }

type HostRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A general structure to contain IP detailed information
type IPInfo struct {
	// Geolocation city
	City *string `json:"city,omitempty"`
	// Geolocation ISO country code
	CountryCode *string `json:"countryCode,omitempty"`
	// Geolocation country name
	CountryName *string `json:"countryName,omitempty"`
	// IP address of the link
	IP *string `json:"ip,omitempty"`
	// Geolocation latitude for the ISP
	Latitude *float64 `json:"latitude,omitempty"`
	// Geolocation longitude for the ISP
	Longitude *float64 `json:"longitude,omitempty"`
	// ISP Internet provider
	Provider *string `json:"provider,omitempty"`
	// Geolocation state
	State *string `json:"state,omitempty"`
}

// Basic IPSec configuration information
type IPSecInfo struct {
	// The source IP address for the IPsec tunnel in the Cato Cloud
	CatoIP *string `json:"catoIP,omitempty"`
	// Shows 1 for IKEv1 and 2 for IKEv2
	IkeVersion *int64 `json:"ikeVersion,omitempty"`
	// For HA configurations, when this boolean value is true, this the primary IPsec firewall or routing device
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// The destination IP address for the IPsec tunnel (in the site)
	RemoteIP *string `json:"remoteIP,omitempty"`
}

type IlmmContact struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type IlmmDetails struct {
	Contacts    []*IlmmContact   `json:"contacts,omitempty"`
	IspDetails  *IlmmIspDetails  `json:"ispDetails,omitempty"`
	LinkDetails *IlmmLinkDetails `json:"linkDetails,omitempty"`
}

type IlmmIspDetails struct {
	CountryCode  *string     `json:"countryCode,omitempty"`
	Description  *string     `json:"description,omitempty"`
	IspAccountID *string     `json:"ispAccountId,omitempty"`
	LoaFile      *IspLoaFile `json:"loaFile,omitempty"`
	Name         *string     `json:"name,omitempty"`
	SupportEmail *string     `json:"supportEmail,omitempty"`
	SupportPhone *string     `json:"supportPhone,omitempty"`
}

// Intelligent Last Mile Monitoring (ILMM) License details
type IlmmLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The total amount of ILMM licenses.
	Total int64 `json:"total"`
}

func (IlmmLicense) IsLicense()                   {}
func (this IlmmLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IlmmLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IlmmLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IlmmLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IlmmLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IlmmLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IlmmLicense) GetLastUpdated() *string { return this.LastUpdated }

func (IlmmLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this IlmmLicense) GetTotal() int64 { return this.Total }

type IlmmLinkDetails struct {
	ActiveLicense    *bool                 `json:"activeLicense,omitempty"`
	Comments         *string               `json:"comments,omitempty"`
	Description      *string               `json:"description,omitempty"`
	IspLinkID        *string               `json:"ispLinkId,omitempty"`
	LinkID           *string               `json:"linkId,omitempty"`
	OnboardingStatus *IlmmOnboardingStatus `json:"onboardingStatus,omitempty"`
}

type IncidentFlow struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referer                *string `json:"referer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

type IncidentTargetRep struct {
	AnalysisScore         *float64    `json:"analysisScore,omitempty"`
	Categories            *string     `json:"categories,omitempty"`
	CatoPopularity        *int64      `json:"catoPopularity,omitempty"`
	CountryOfRegistration *string     `json:"countryOfRegistration,omitempty"`
	CreationTime          *string     `json:"creationTime,omitempty"`
	Engines               *int64      `json:"engines,omitempty"`
	EventData             []*Event    `json:"eventData"`
	InfectionSource       *bool       `json:"infectionSource,omitempty"`
	Name                  *string     `json:"name,omitempty"`
	SearchHits            *string     `json:"searchHits,omitempty"`
	ThreatFeeds           *int64      `json:"threatFeeds,omitempty"`
	ThreatReference       *string     `json:"threatReference,omitempty"`
	Type                  *TargetType `json:"type,omitempty"`
}

type IncidentTimeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string       `json:"info,omitempty"`
	Key  *TimeseriesKey `json:"key,omitempty"`
	// Indicates the type of the timeseries
	Label string   `json:"label"`
	Sum   *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
}

type IntPredicate struct {
	Eq    *int64  `json:"eq,omitempty"`
	Gt    *int64  `json:"gt,omitempty"`
	Gte   *int64  `json:"gte,omitempty"`
	In    []int64 `json:"in,omitempty"`
	Lt    *int64  `json:"lt,omitempty"`
	Lte   *int64  `json:"lte,omitempty"`
	NotIn []int64 `json:"not_in,omitempty"`
}

// Basic Socket Interface configuration information
type InterfaceInfo struct {
	// The destination type configured to the Socket interface
	DestType *string `json:"destType,omitempty"`
	// Maximum allowed bandwidth for traffic on this port, from the Cato Cloud to the site
	DownstreamBandwidth *int64 `json:"downstreamBandwidth,omitempty"`
	// ID for the Socket port in the Socket WebUI Monitor tab
	ID string `json:"id"`
	// Name for the port in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Maximum allowed bandwidth on this port, for traffic from the site to the Cato Cloud
	UpstreamBandwidth *int64 `json:"upstreamBandwidth,omitempty"`
}

type InterfaceLinkState struct {
	// Shows the duplex mode for the link
	Duplex *string `json:"duplex,omitempty"`
	// The ID for the specific Socket port, for example LAN1 or LAN2
	ID *string `json:"id,omitempty"`
	// Shows the maximum bandwidth configured for the link
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// When this boolean value is true, then a cable is connected to the Socket port
	MediaIn *bool `json:"mediaIn,omitempty"`
	// When this boolean value is true, then the link for the port is up
	Up *bool `json:"up,omitempty"`
}

type InterfaceMetrics struct {
	// Time stamp annotation that shows a time increment for a GUI
	Annotations []*TimeAnnotation `json:"annotations,omitempty"`
	// Basic configuration information about the Socket interface . Applicable only for site
	InterfaceInfo *InterfaceInfo `json:"interfaceInfo,omitempty"`
	// Data related to IPsec sites, such as IKE version . Applicable only for site
	IpsecInfo *IPSecInfo `json:"ipsecInfo,omitempty"`
	// Traffic data for the link
	Metrics *Metrics `json:"metrics,omitempty"`
	// Link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// object that is a specific time duration
	Periods []*TimePeriod `json:"periods,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// Data related to the link IP address, such as country code
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version. Applicable only for site
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// For site metrics, timeseries info field will include: siteID, interfaceName, for last mile metrics it will also
	// include the destination last mile check
	Timeseries []*Timeseries `json:"timeseries,omitempty"`
}

type InterfaceSnapshot struct {
	// Information about cellular (LTE) interface
	CellularInterfaceInfo *CellularInterface `json:"cellularInterfaceInfo,omitempty"`
	// Shows if the WAN link is connected to the PoP
	Connected *bool `json:"connected,omitempty"`
	// Interface ID for the WAN link
	ID *string `json:"id,omitempty"`
	// data about the WAN link that is configured in the Socket Configuration window for the site
	Info *InterfaceInfo `json:"info,omitempty"`
	// WAN link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Interface Natural order for WAN link
	NaturalOrder *int64 `json:"naturalOrder,omitempty"`
	// Physical WAN port on the Socket
	PhysicalPort *int64 `json:"physicalPort,omitempty"`
	// The name of the PoP that the WAN link is connected to
	PopName *string `json:"popName,omitempty"`
	// The ID of the PoP that the WAN link was connected to before the current one
	PreviousPopID *int64 `json:"previousPopID,omitempty"`
	// The name of the PoP that the WAN link was connected to before the current one
	PreviousPopName *string `json:"previousPopName,omitempty"`
	// Reason that the tunnel required a new connection (for example, PoP or Socket restarted)
	TunnelConnectionReason *string `json:"tunnelConnectionReason,omitempty"`
	// IP address of the WAN ISP
	TunnelRemoteIP *string `json:"tunnelRemoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the WAN ISP
	TunnelRemoteIPInfo *IPInfo `json:"tunnelRemoteIPInfo,omitempty"`
	// Number of seconds that the tunnel is connected to a PoP
	TunnelUptime *int64  `json:"tunnelUptime,omitempty"`
	Type         *string `json:"type,omitempty"`
}

type InternetFirewallAddRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country"`
	Description string             `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	Enabled  bool              `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions"`
	Name       string                                `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeInput `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceInput `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Rule parameters and relevant position
type InternetFirewallAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *InternetFirewallAddRuleDataInput `json:"rule"`
}

type InternetFirewallContainer struct {
	FqdnContainer           []*FqdnContainerRef           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRef `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerUpdateInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer,omitempty"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer,omitempty"`
}

// Destination match criteria set
type InternetFirewallDestination struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Countries
	Country []*CountryRef `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
}

// Destination match criteria set
type InternetFirewallDestinationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Countries
	Country []*CountryRefInput `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
}

// Destination match criteria set
type InternetFirewallDestinationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput                `json:"application,omitempty"`
	Container   []*ContainerRefInput                  `json:"container,omitempty"`
	Containers  *InternetFirewallContainerUpdateInput `json:"containers,omitempty"`
	// Countries
	Country []*CountryRefInput `json:"country,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet,omitempty"`
}

type InternetFirewallPolicy struct {
	Audit    *PolicyAudit                   `json:"audit,omitempty"`
	Enabled  bool                           `json:"enabled"`
	Revision *PolicyRevision                `json:"revision,omitempty"`
	Rules    []*InternetFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload        `json:"sections"`
}

func (InternetFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this InternetFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this InternetFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this InternetFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this InternetFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this InternetFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type InternetFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type InternetFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Internet Firewall policy information provided in the API response
type InternetFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Policy *InternetFirewallPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (InternetFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this InternetFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this InternetFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this InternetFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Internet firewall Policy information returned to the caller in the API response.
type InternetFirewallPolicyMutations struct {
	// Add a new rule to the Internet Firewall policy.
	AddRule *InternetFirewallRuleMutationPayload `json:"addRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection *PolicySectionMutationPayload `json:"addSection"`
	// Create the policy revision. Create a new empty policy revision.
	CreatePolicyRevision *InternetFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	// Discard the policy revision. All changes in this discarded revision are discarded, and the revision is deleted.
	DiscardPolicyRevision *InternetFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the relative location of an existing rule within the Internet Firewall policy.
	MoveRule *InternetFirewallRuleMutationPayload `json:"moveRule"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection *PolicySectionMutationPayload `json:"moveSection"`
	// Publish the policy revision. A published revision becomes the active policy, and its content is merged with all unpublished revisions for other admins.
	PublishPolicyRevision *InternetFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	// Remove an existing rule from the Internet Firewall policy.
	RemoveRule *InternetFirewallRuleMutationPayload `json:"removeRule"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *InternetFirewallPolicyMutationPayload `json:"updatePolicy"`
	// Update an existing rule of the Internet Firewall policy.
	UpdateRule *InternetFirewallRuleMutationPayload `json:"updateRule"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
}

type InternetFirewallPolicyQueries struct {
	Policy    *InternetFirewallPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type InternetFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type InternetFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type InternetFirewallRule struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestination `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleException `json:"exceptions"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceType `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSource `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
}

func (InternetFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this InternetFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this InternetFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this InternetFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this InternetFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this InternetFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this InternetFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleException struct {
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestination `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceType `json:"service"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSource `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleExceptionInput struct {
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceTypeInput `json:"service"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSourceInput `json:"source"`
}

type InternetFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError       `json:"errors"`
	Rule   *InternetFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus         `json:"status"`
}

func (InternetFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this InternetFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this InternetFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this InternetFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Internet Firewall policy information for a specific revision
type InternetFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *InternetFirewallRule         `json:"rule"`
}

func (InternetFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this InternetFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this InternetFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this InternetFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Internet Firewall rule
type InternetFirewallSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule
type InternetFirewallSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule
type InternetFirewallSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type InternetFirewallUpdateRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action *InternetFirewallActionEnum `json:"action,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country,omitempty"`
	Description *string            `json:"description,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS,omitempty"`
	Enabled  *bool             `json:"enabled,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions,omitempty"`
	Name       *string                               `json:"name,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceUpdateInput `json:"source,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type InternetFirewallUpdateRuleInput struct {
	ID   string                               `json:"id"`
	Rule *InternetFirewallUpdateRuleDataInput `json:"rule"`
}

// Inclusive range of IPs
type IPAddressRange struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainer struct {
	// Audit metadata about the container
	Audit *ContainerAudit `json:"audit"`
	// Description for the container
	Description *string `json:"description,omitempty"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
	// Number of items in the container
	Size int64 `json:"size"`
}

func (IPAddressRangeContainer) IsContainer() {}

// Unique container ID
func (this IPAddressRangeContainer) GetID() string { return this.ID }

// Name for the container
func (this IPAddressRangeContainer) GetName() string { return this.Name }

// Description for the container
func (this IPAddressRangeContainer) GetDescription() *string { return this.Description }

// Number of items in the container
func (this IPAddressRangeContainer) GetSize() int64 { return this.Size }

// Audit metadata about the container
func (this IPAddressRangeContainer) GetAudit() *ContainerAudit { return this.Audit }

// Input for adding values to existing IPAddressRange typed container
type IPAddressRangeContainerAddValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerAddValuesPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type IPAddressRangeContainerMutations struct {
	AddValues      *IPAddressRangeContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateIPAddressRangeContainerFromFilePayload `json:"createFromFile"`
	RemoveValues   *IPAddressRangeContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateIPAddressRangeContainerFromFilePayload `json:"updateFromFile"`
}

type IPAddressRangeContainerQueries struct {
	DownloadFile         *DownloadIPAddressRangeContainerFilePayload         `json:"downloadFile"`
	Search               *IPAddressRangeContainerSearchPayload               `json:"search"`
	SearchIPAddressRange *IPAddressRangeContainerSearchIPAddressRangePayload `json:"searchIpAddressRange"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (IPAddressRangeContainerRef) IsIContainerRef() {}

// Unique container ID
func (this IPAddressRangeContainerRef) GetID() string { return this.ID }

// Name for the container
func (this IPAddressRangeContainerRef) GetName() string { return this.Name }

func (IPAddressRangeContainerRef) IsObjectRef() {}

// Object's unique identifier

// Object's unique name

type IPAddressRangeContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Input for removing values from existing IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

// Filtering input to IPAddressRange container search
type IPAddressRangeContainerSearchInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

// Input for searching IPAddressRange typed containers that contain a specific IPAddressRange
type IPAddressRangeContainerSearchIPAddressRangeInput struct {
	IPAddressRange *IPAddressRangeInput `json:"ipAddressRange"`
}

// Payload of IPAddressRange search query
type IPAddressRangeContainerSearchIPAddressRangePayload struct {
	// List of containers with members of type IPAddressRange
	Containers []*IPAddressRangeContainer `json:"containers"`
}

// Payload of IPAddressRange container search
type IPAddressRangeContainerSearchPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

// Inclusive range of IPs
type IPAddressRangeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
type IpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (IpsLicense) IsLicense()                   {}
func (this IpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IpsLicense) GetLastUpdated() *string { return this.LastUpdated }

type IpsecIkeV2MessageInput struct {
	// The SA tunnel encryption method. Note: For situations where GCM isn’t supported for the INIT phase, we recommend that you use the CBC algorithm for the INIT phase, and GCM for AUTH
	Cipher *IPSecCipher `json:"cipher,omitempty"`
	// The Diffie-Hellman Group. The first number is the DH-group number, and the second number is the corresponding prime modulus size in bits
	DhGroup *IPSecDHGroup `json:"dhGroup,omitempty"`
	// The algorithm used to verify the integrity and authenticity of IPsec packets
	Integrity *IPSecHash `json:"integrity,omitempty"`
	// The Pseudo-random function (PRF) used to derive the cryptographic keys used in the SA establishment process
	Prf *IPSecHash `json:"prf,omitempty"`
}

type IspLoaFile struct {
	FileHash   *string       `json:"fileHash,omitempty"`
	FileName   *string       `json:"fileName,omitempty"`
	UploadedAt *scalars.Time `json:"uploadedAt,omitempty"`
}

type LastMileBwInput struct {
	// The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
	Downstream *int64 `json:"downstream,omitempty"`
	// The maximum upstream bandwidth, in Mbps. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
	Upstream *int64 `json:"upstream,omitempty"`
}

// Public license API
type LicensingInfo struct {
	// License usage and allocation across the managed accounts
	GlobalLicenseAllocations *GlobalLicenseAllocations `json:"globalLicenseAllocations"`
	// License inventory
	Licenses []License `json:"licenses"`
}

type LicensingQueries struct {
	// BETA
	LicensingInfo *LicensingInfo `json:"licensingInfo,omitempty"`
}

type LinkQualityIssue struct {
	Current   *int64                    `json:"current,omitempty"`
	Direction *TrafficDirectionEnum     `json:"direction,omitempty"`
	IssueType *LinkQualityIssueTypeEnum `json:"issueType,omitempty"`
	Threshold *int64                    `json:"threshold,omitempty"`
}

type LookupFilterInput struct {
	Filter *LookupFilterType `json:"filter,omitempty"`
	Value  *string           `json:"value,omitempty"`
}

// Anti-Malware service license details (Legacy license, replaced by TP)
type MalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (MalwareProtectionLicense) IsLicense()                   {}
func (this MalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this MalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this MalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this MalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this MalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this MalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this MalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

// Managed XDR service license details
type ManagedXdrLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (ManagedXdrLicense) IsLicense()                   {}
func (this ManagedXdrLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ManagedXdrLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ManagedXdrLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ManagedXdrLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ManagedXdrLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ManagedXdrLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ManagedXdrLicense) GetLastUpdated() *string { return this.LastUpdated }

type Measure struct {
	AggType   AggregationType   `json:"aggType"`
	FieldName AppStatsFieldName `json:"fieldName"`
	Trend     *bool             `json:"trend,omitempty"`
}

type Metric struct {
	Name  string  `json:"name"`
	Value float64 `json:"value"`
}

type MetricDetails struct {
	Name  string `json:"name"`
	Units string `json:"units"`
}

type Metrics struct {
	// total downstream traffic (from the Cato Cloud to the site)
	BytesDownstream *float64 `json:"bytesDownstream,omitempty"`
	// total traffic for the site
	BytesTotal *float64 `json:"bytesTotal,omitempty"`
	// total upstream traffic (from the site to the Cato Cloud)
	BytesUpstream *float64 `json:"bytesUpstream,omitempty"`
	// total amount of time for the site data
	Duration *int64 `json:"duration,omitempty"`
	// The number of flows (connections) in the tunnel. Relevant only for per site Metrics, ignored in per-interface
	// metrics.
	FlowCount *float64 `json:"flowCount,omitempty"`
	// duration in seconds for a single metrics bucket
	Granularity *int64 `json:"granularity,omitempty"`
	// The number of hosts in the tunnel. Relevant only for per site Metrics, ignored in per-interface metrics.
	HostCount *float64 `json:"hostCount,omitempty"`
	// The configurable limit of the number of hosts in the tunnel. Relevant only for per site Metrics, ignored in
	// per-interface metrics.
	HostLimit *float64 `json:"hostLimit,omitempty"`
	// jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterDownstream *float64 `json:"jitterDownstream,omitempty"`
	// jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterUpstream *float64 `json:"jitterUpstream,omitempty"`
	// number of packets lost for downstream traffic
	LostDownstream *float64 `json:"lostDownstream,omitempty"`
	// percent of packet loss for downstream traffic
	LostDownstreamPcnt *float64 `json:"lostDownstreamPcnt,omitempty"`
	// number of packets lost for upstream traffic
	LostUpstream *float64 `json:"lostUpstream,omitempty"`
	// percent of packet loss for upstream traffic
	LostUpstreamPcnt *float64 `json:"lostUpstreamPcnt,omitempty"`
	// total packets discarded for downstream traffic
	PacketsDiscardedDownstream *float64 `json:"packetsDiscardedDownstream,omitempty"`
	// total packets discarded for upstream traffic
	PacketsDiscardedUpstream *float64 `json:"packetsDiscardedUpstream,omitempty"`
	// total downstream packets
	PacketsDownstream *float64 `json:"packetsDownstream,omitempty"`
	// total upstream packets
	PacketsUpstream *float64 `json:"packetsUpstream,omitempty"`
	// round-trip time from the site to the Cato Cloud
	Rtt *int64 `json:"rtt,omitempty"`
}

type MicrosoftActivity struct {
	Action                *string `json:"action,omitempty"`
	FirstActivityDateTime *string `json:"firstActivityDateTime,omitempty"`
	ID                    string  `json:"id"`
	LastActivityDateTime  *string `json:"lastActivityDateTime,omitempty"`
	ParentResourceID      string  `json:"parentResourceId"`
	ResourceID            string  `json:"resourceId"`
}

func (MicrosoftActivity) IsActivity()                      {}
func (this MicrosoftActivity) GetID() string               { return this.ID }
func (this MicrosoftActivity) GetResourceID() string       { return this.ResourceID }
func (this MicrosoftActivity) GetParentResourceID() string { return this.ParentResourceID }

type MicrosoftDefenderEndpointAlert struct {
	Activities            []*MicrosoftActivity        `json:"activities"`
	AlertWebURL           *string                     `json:"alertWebUrl,omitempty"`
	Category              *string                     `json:"category,omitempty"`
	Classification        *AlertClassificationEnum    `json:"classification,omitempty"`
	Comments              []string                    `json:"comments"`
	CreatedDateTime       *string                     `json:"createdDateTime,omitempty"`
	Criticality           *int64                      `json:"criticality,omitempty"`
	Description           *string                     `json:"description,omitempty"`
	DestinationIP         *string                     `json:"destinationIp,omitempty"`
	DestinationURL        *string                     `json:"destinationUrl,omitempty"`
	DetectionSource       *DetectionSourceEnum        `json:"detectionSource,omitempty"`
	Determination         *AlertDeterminationEnum     `json:"determination,omitempty"`
	FirstActivityDateTime *string                     `json:"firstActivityDateTime,omitempty"`
	ID                    string                      `json:"id"`
	LastActivityDateTime  *string                     `json:"lastActivityDateTime,omitempty"`
	LastUpdateDateTime    *string                     `json:"lastUpdateDateTime,omitempty"`
	LocalIP               *string                     `json:"localIp,omitempty"`
	MitreSubTechnique     []*Mitre                    `json:"mitreSubTechnique"`
	MitreTechnique        []*Mitre                    `json:"mitreTechnique"`
	OwnerName             *string                     `json:"ownerName,omitempty"`
	ProviderAlertID       *string                     `json:"providerAlertId,omitempty"`
	RecommendedActions    *string                     `json:"recommendedActions,omitempty"`
	ResolvedDateTime      *string                     `json:"resolvedDateTime,omitempty"`
	Resources             []MicrosoftEndpointResource `json:"resources"`
	Status                *MsAlertStatus              `json:"status,omitempty"`
	ThreatFamilyName      *string                     `json:"threatFamilyName,omitempty"`
	ThreatName            *string                     `json:"threatName,omitempty"`
	ThreatType            *string                     `json:"threatType,omitempty"`
	Title                 *string                     `json:"title,omitempty"`
}

func (MicrosoftDefenderEndpointAlert) IsEndpointAlert()             {}
func (this MicrosoftDefenderEndpointAlert) GetID() string           { return this.ID }
func (this MicrosoftDefenderEndpointAlert) GetTitle() *string       { return this.Title }
func (this MicrosoftDefenderEndpointAlert) GetDescription() *string { return this.Description }
func (this MicrosoftDefenderEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this MicrosoftDefenderEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftDefenderEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCriticality() *int64 { return this.Criticality }

type MicrosoftDeviceDetails struct {
	AvStatus          *DeviceAvStatusEnum     `json:"avStatus,omitempty"`
	AzureAdDeviceID   *string                 `json:"azureAdDeviceId,omitempty"`
	DeviceName        *string                 `json:"deviceName,omitempty"`
	FirstSeenDateTime *string                 `json:"firstSeenDateTime,omitempty"`
	HealthStatus      *DeviceHealthStatusEnum `json:"healthStatus,omitempty"`
	ID                string                  `json:"id"`
	IPInterfaces      []string                `json:"ipInterfaces"`
	LoggedOnUsers     []EndpointUser          `json:"loggedOnUsers"`
	OnboardingStatus  *OnboardingStatusEnum   `json:"onboardingStatus,omitempty"`
	OsDetails         *OsDetails              `json:"osDetails,omitempty"`
	RbacGroup         *RbacGroup              `json:"rbacGroup,omitempty"`
}

func (MicrosoftDeviceDetails) IsDeviceDetails()              {}
func (this MicrosoftDeviceDetails) GetID() string            { return this.ID }
func (this MicrosoftDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this MicrosoftDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this MicrosoftDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type MicrosoftEndpoint struct {
	Alerts              []*MicrosoftDefenderEndpointAlert `json:"alerts"`
	AnalystFeedback     *AnalystFeedback                  `json:"analystFeedback,omitempty"`
	ConnectionType      *ConnectionTypeEnum               `json:"connectionType,omitempty"`
	Criticality         *int64                            `json:"criticality,omitempty"`
	Description         *string                           `json:"description,omitempty"`
	Device              *MicrosoftDeviceDetails           `json:"device,omitempty"`
	EngineType          *StoryEngineTypeEnum              `json:"engineType,omitempty"`
	FirstSignal         string                            `json:"firstSignal"`
	ID                  string                            `json:"id"`
	Indication          string                            `json:"indication"`
	LastSignal          string                            `json:"lastSignal"`
	PredictedThreatType *string                           `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum                 `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum                 `json:"producer"`
	ProducerName        string                            `json:"producerName"`
	QueryName           *string                           `json:"queryName,omitempty"`
	Research            *bool                             `json:"research,omitempty"`
	SimilarStoriesData  []*SimilarStoryData               `json:"similarStoriesData"`
	Site                *SiteRef                          `json:"site,omitempty"`
	SiteName            *string                           `json:"siteName,omitempty"`
	Source              *string                           `json:"source,omitempty"`
	SourceIP            *string                           `json:"sourceIp,omitempty"`
	Status              *StoryStatusEnum                  `json:"status,omitempty"`
	StoryDuration       *int64                            `json:"storyDuration,omitempty"`
	Ticket              *string                           `json:"ticket,omitempty"`
	User                *UserRef                          `json:"user,omitempty"`
	Vendor              *VendorEnum                       `json:"vendor,omitempty"`
}

func (MicrosoftEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this MicrosoftEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this MicrosoftEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this MicrosoftEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this MicrosoftEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this MicrosoftEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this MicrosoftEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this MicrosoftEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this MicrosoftEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this MicrosoftEndpoint) GetSource() *string                   { return this.Source }
func (this MicrosoftEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this MicrosoftEndpoint) GetTicket() *string                   { return this.Ticket }
func (this MicrosoftEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this MicrosoftEndpoint) GetResearch() *bool                   { return this.Research }
func (this MicrosoftEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this MicrosoftEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this MicrosoftEndpoint) GetDescription() *string              { return this.Description }
func (this MicrosoftEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this MicrosoftEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this MicrosoftEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this MicrosoftEndpoint) GetUser() *UserRef                    { return this.User }
func (this MicrosoftEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this MicrosoftEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this MicrosoftEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this MicrosoftEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (MicrosoftEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type MicrosoftEndpointUser struct {
	AccountName   *string `json:"accountName,omitempty"`
	DomainName    *string `json:"domainName,omitempty"`
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	PrincipalName *string `json:"principalName,omitempty"`
	UserSid       *string `json:"userSid,omitempty"`
}

func (MicrosoftEndpointUser) IsEndpointUser()      {}
func (this MicrosoftEndpointUser) GetID() string   { return this.ID }
func (this MicrosoftEndpointUser) GetName() string { return this.Name }

type MicrosoftFileResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	DetectionStatus          *DetectionStatusEnum   `json:"detectionStatus,omitempty"`
	FileDetails              *FileDetails           `json:"fileDetails,omitempty"`
	ID                       string                 `json:"id"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftFileResource) IsEndpointResource()              {}
func (this MicrosoftFileResource) GetID() string               { return this.ID }
func (this MicrosoftFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftFileResource) IsFileResource() {}

func (this MicrosoftFileResource) GetFileDetails() *FileDetails { return this.FileDetails }
func (this MicrosoftFileResource) GetDetectionStatus() *DetectionStatusEnum {
	return this.DetectionStatus
}

func (MicrosoftFileResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftFileResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftFileResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

type MicrosoftProcessResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	ID                       string                 `json:"id"`
	ImageFile                *FileDetails           `json:"imageFile,omitempty"`
	ProcessCommandLine       *string                `json:"processCommandLine,omitempty"`
	ProcessID                int64                  `json:"processId"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	UserAccount              EndpointUser           `json:"userAccount,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftProcessResource) IsEndpointResource()              {}
func (this MicrosoftProcessResource) GetID() string               { return this.ID }
func (this MicrosoftProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftProcessResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftProcessResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftProcessResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftProcessResource) IsProcessResource() {}

func (this MicrosoftProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this MicrosoftProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this MicrosoftProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this MicrosoftProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

type MicrosoftRegistryResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	Hive                     *string                `json:"hive,omitempty"`
	ID                       string                 `json:"id"`
	Key                      *string                `json:"key,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Value                    *string                `json:"value,omitempty"`
	ValueName                *string                `json:"valueName,omitempty"`
	ValueType                *string                `json:"valueType,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftRegistryResource) IsEndpointResource()              {}
func (this MicrosoftRegistryResource) GetID() string               { return this.ID }
func (this MicrosoftRegistryResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftRegistryResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftRegistryResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftRegistryResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftRegistryResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftRegistryResource) IsRegistryResource() {}

func (this MicrosoftRegistryResource) GetHive() *string      { return this.Hive }
func (this MicrosoftRegistryResource) GetKey() *string       { return this.Key }
func (this MicrosoftRegistryResource) GetValue() *string     { return this.Value }
func (this MicrosoftRegistryResource) GetValueName() *string { return this.ValueName }
func (this MicrosoftRegistryResource) GetValueType() *string { return this.ValueType }

type Mitre struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type Mutation struct {
}

// NOC as a Service (NOCaaS) service license details
type NOCaaSLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (NOCaaSLicense) IsLicense()                   {}
func (this NOCaaSLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NOCaaSLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NOCaaSLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NOCaaSLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NOCaaSLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NOCaaSLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NOCaaSLicense) GetLastUpdated() *string { return this.LastUpdated }

type NetworkDhcpSettingsInput struct {
	DhcpType     DhcpType `json:"dhcpType"`
	IPRange      *string  `json:"ipRange,omitempty"`
	RelayGroupID *string  `json:"relayGroupId,omitempty"`
}

type NetworkInterfaceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (NetworkInterfaceRef) IsObjectRef() {}

// Object's unique identifier
func (this NetworkInterfaceRef) GetID() string { return this.ID }

// Object's unique name
func (this NetworkInterfaceRef) GetName() string { return this.Name }

type NetworkInterfaceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type NetworkTimelineEvent struct {
	Acknowledged         *bool                     `json:"acknowledged,omitempty"`
	BgpConnection        *BGPConnection            `json:"bgpConnection,omitempty"`
	Created              string                    `json:"created"`
	Description          *string                   `json:"description,omitempty"`
	DeviceConfigHaRole   *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	DeviceHaRoleState    *DeviceHaRoleStateEnum    `json:"deviceHaRoleState,omitempty"`
	EventIds             []string                  `json:"eventIds"`
	EventType            *NetworkXDREventTypeEnum  `json:"eventType,omitempty"`
	HostIP               *string                   `json:"hostIp,omitempty"`
	IncidentID           *string                   `json:"incidentId,omitempty"`
	Isp                  *string                   `json:"isp,omitempty"`
	LinkConfigBandwidth  *string                   `json:"linkConfigBandwidth,omitempty"`
	LinkConfigPrecedence *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID               *string                   `json:"linkId,omitempty"`
	LinkName             *string                   `json:"linkName,omitempty"`
	LinkQualityIssue     *LinkQualityIssue         `json:"linkQualityIssue,omitempty"`
	LinkStatus           *LinkStatusEnum           `json:"linkStatus,omitempty"`
	Muted                *bool                     `json:"muted,omitempty"`
	NetworkEventSource   *NetworkEventSourceEnum   `json:"networkEventSource,omitempty"`
	Pop                  *string                   `json:"pop,omitempty"`
	RuleName             *string                   `json:"ruleName,omitempty"`
	SocketSerialID       *string                   `json:"socketSerialId,omitempty"`
	TunnelResetCount     *int64                    `json:"tunnelResetCount,omitempty"`
	Validated            string                    `json:"validated"`
}

type NetworkXDRIncident struct {
	Acknowledged            *bool                     `json:"acknowledged,omitempty"`
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	BgpConnection           *BGPConnection            `json:"bgpConnection,omitempty"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceConfigHaRole      *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	HostIP                  *string                   `json:"hostIp,omitempty"`
	ID                      string                    `json:"id"`
	IlmmDetails             *IlmmDetails              `json:"ilmmDetails,omitempty"`
	Indication              string                    `json:"indication"`
	Isp                     *string                   `json:"isp,omitempty"`
	LastSignal              string                    `json:"lastSignal"`
	LicenseBandwidth        *string                   `json:"licenseBandwidth,omitempty"`
	LicenseRegion           *string                   `json:"licenseRegion,omitempty"`
	LinkConfigPrecedence    *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID                  *string                   `json:"linkId,omitempty"`
	LinkName                *string                   `json:"linkName,omitempty"`
	Muted                   *bool                     `json:"muted,omitempty"`
	NetworkIncidentTimeline []*NetworkTimelineEvent   `json:"networkIncidentTimeline"`
	Occurrences             *int64                    `json:"occurrences,omitempty"`
	Pop                     *string                   `json:"pop,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RuleName                *string                   `json:"ruleName,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteConfigLocation      *string                   `json:"siteConfigLocation,omitempty"`
	SiteConnectionType      *string                   `json:"siteConnectionType,omitempty"`
	SiteName                string                    `json:"siteName"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	StoryType               string                    `json:"storyType"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (NetworkXDRIncident) IsMergedIncident() {}

// Unique Cato ID for each story
func (this NetworkXDRIncident) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this NetworkXDRIncident) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this NetworkXDRIncident) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this NetworkXDRIncident) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this NetworkXDRIncident) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this NetworkXDRIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this NetworkXDRIncident) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this NetworkXDRIncident) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this NetworkXDRIncident) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this NetworkXDRIncident) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this NetworkXDRIncident) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this NetworkXDRIncident) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this NetworkXDRIncident) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this NetworkXDRIncident) GetSiteName() *string { return &this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this NetworkXDRIncident) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this NetworkXDRIncident) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this NetworkXDRIncident) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this NetworkXDRIncident) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this NetworkXDRIncident) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this NetworkXDRIncident) GetUser() *UserRef                      { return this.User }
func (this NetworkXDRIncident) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this NetworkXDRIncident) GetPredictedThreatType() *string        { return this.PredictedThreatType }

// NG Anti-Malware service license details (Legacy license, replaced by TP)
type NextGenMalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (NextGenMalwareProtectionLicense) IsLicense()                   {}
func (this NextGenMalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NextGenMalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NextGenMalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NextGenMalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NextGenMalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NextGenMalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NextGenMalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

type OsDetails struct {
	OsBuild   *int64  `json:"osBuild,omitempty"`
	OsType    string  `json:"osType"`
	OsVersion *string `json:"osVersion,omitempty"`
}

type PageInfo struct {
	Total int64 `json:"total"`
}

type Paging struct {
	// Based on the filter and sort parameters, the first story that is returned
	From int64 `json:"from"`
	// Based on the filter and sort parameters, the number of stories returned after the from. For example, the argument {from: 10, limit: 10} returns stories 10-20.
	Limit int64 `json:"limit"`
	// Total number of stories returned
	Total int64 `json:"total"`
}

type PagingInput struct {
	From  int64 `json:"from"`
	Limit int64 `json:"limit"`
}

type PartnerPooledBandwidthLicenseAccount struct {
	// Identifying data for the account
	Account *AccountRef `json:"account"`
	// Allocated bandwidth for this account
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
}

// Input for adding section info to a policy
type PolicyAddSectionInfoInput struct {
	Name string `json:"name"`
}

// Input for adding a section to a policy
type PolicyAddSectionInput struct {
	At      *PolicySectionPositionInput `json:"at"`
	Section *PolicyAddSectionInfoInput  `json:"section"`
}

type PolicyAudit struct {
	PublishedBy   string `json:"publishedBy"`
	PublishedTime string `json:"publishedTime"`
}

type PolicyCreateRevisionInput struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Returns data for a custom recurring time range that a rule is active
type PolicyCustomRecurring struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringInput struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringUpdateInput struct {
	Days []DayOfWeek   `json:"days,omitempty"`
	From *scalars.Time `json:"from,omitempty"`
	To   *scalars.Time `json:"to,omitempty"`
}

// Returns data for a custom one-time time range that a rule is active
type PolicyCustomTimeframe struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeUpdateInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Discards unpublished revision for the policy and reverts to the settings for the published policy.
type PolicyDiscardRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyElementAudit struct {
	// The admin, or the API-key, that performed the last update
	UpdatedBy string `json:"updatedBy"`
	// The last date and time the rule was updated
	UpdatedTime string `json:"updatedTime"`
}

// Move the rule to a different position in the policy
type PolicyMoveRuleInput struct {
	ID string                   `json:"id"`
	To *PolicyRulePositionInput `json:"to,omitempty"`
}

// Input for moving a section within a policy
type PolicyMoveSectionInput struct {
	ID string                      `json:"id"`
	To *PolicySectionPositionInput `json:"to,omitempty"`
}

// The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.
//
// ## Policy Errors
//
// ### `ConcurrentPolicyPublish`
// - **Error Message:** "Another policy is currently publishing"
//
// ### `PolicyRevisionMismatch`
// - **Error Message:** "Revision is not owned by the admin"
//
// ### `PolicyRevisionNotFound`
// - **Error Message:** "Revision was not found"
//
// ### `PolicyInvalidEntity`
// - **Error Message:** "Invalid entity"
//
// ### `DuplicateRuleName`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `DuplicateSectionName`
// - **Error Message:** "Section with the same name already exists"
//
// ### `PolicyFailure`
// - **Error Message:** "Can’t publish policy due to an internal error. Please try again in a few minutes"
//
// ## Rule Errors
//
// ### `ruleIsLocked`
// - **Error Message:** "Rule is locked by another revision"
//
// ### `ruleWasRemoved`
// - **Error Message:** "Rule was already removed"
//
// ### `ruleNotExist`
// - **Error Message:** "Rule does not exist"
//
// ### `ruleSectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `ruleSectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `rulePositionInvalid`
// - **Error Message:** "Rule position is invalid"
//
// ### `ruleNameIsEmpty`
// - **Error Message:** "Rule name can't be empty"
//
// ### `ruleNameAlreadyExists`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `ruleSystemModification`
// - **Error Message:** "Can't modify a system rule"
//
// ### `ruleSystemMove`
// - **Error Message:** "Can't add a rule above the system rules"
//
// ### `ruleHasInvalidEntity`
// - **Error Message:** "Rule has an invalid entity"
//
// ### `failedValidatingRule`
// - **Error Message:** "Something went wrong, couldn't validate rule"
//
// ## Section Errors
//
// ### `sectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `sectionSystemMove`
// - **Error Message:** "Section with system rules cannot be moved or removed"
//
// ### `sectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `sectionPositionInvalid`
// - **Error Message:** "Section position is invalid"
type PolicyMutationError struct {
	ErrorCode    *string `json:"errorCode,omitempty"`
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

type PolicyMutationRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

// Policies that can be configured with mutation APIs.
type PolicyMutations struct {
	InternetFirewall *InternetFirewallPolicyMutations `json:"internetFirewall,omitempty"`
	WanFirewall      *WanFirewallPolicyMutations      `json:"wanFirewall,omitempty"`
}

// Published revision is the active policy
// applied on the traffic.
// In addition, when a policy is published, revision changes become visible
// to other admins, and rules locked by the revision become unlocked
type PolicyPublishRevisionInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// policies which configuration can be read with query APIs.
type PolicyQueries struct {
	InternetFirewall *InternetFirewallPolicyQueries `json:"internetFirewall,omitempty"`
	WanFirewall      *WanFirewallPolicyQueries      `json:"wanFirewall,omitempty"`
}

// Input for removing a section from a policy
type PolicyRemoveSectionInput struct {
	ID string `json:"id"`
}

// Returns data about the policy revision, such as when the change was made, how many rules were changed, etc.
type PolicyRevision struct {
	Changes     int64  `json:"changes"`
	CreatedTime string `json:"createdTime"`
	Description string `json:"description"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	UpdatedTime string `json:"updatedTime"`
}

// Input for specifying a policy revision
type PolicyRevisionInput struct {
	ID   *string             `json:"id,omitempty"`
	Type *PolicyRevisionType `json:"type,omitempty"`
}

// Returns data for publishing the policy
type PolicyRevisionsPayload struct {
	Revision []*PolicyRevision `json:"revision"`
}

// Parameters required to define the rule position
type PolicyRulePositionInput struct {
	// Position relative to a policy, a section or another rule
	Position *PolicyRulePositionEnum `json:"position,omitempty"`
	// The identifier of the object (e.g. a rule, a section) relative to which the position of the added rule is defined
	Ref *string `json:"ref,omitempty"`
}

// Returns data for the alert settings for the rule
type PolicyRuleTrackingAlert struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRef `json:"mailingList"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRef `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRef `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertUpdateInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled *bool `json:"enabled,omitempty"`
	// Returns data for the alert frequency
	Frequency *PolicyRuleTrackingFrequencyEnum `json:"frequency,omitempty"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList,omitempty"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup,omitempty"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook,omitempty"`
}

// Returns data if an alert is sent for a rule
type PolicyRuleTrackingEvent struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventInput struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type PolicySchedule struct {
	ActiveOn        PolicyActiveOnEnum     `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurring `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframe `json:"customTimeframe,omitempty"`
}

type PolicyScheduleInput struct {
	ActiveOn        PolicyActiveOnEnum          `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurringInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeInput `json:"customTimeframe,omitempty"`
}

type PolicyScheduleUpdateInput struct {
	ActiveOn        *PolicyActiveOnEnum               `json:"activeOn,omitempty"`
	CustomRecurring *PolicyCustomRecurringUpdateInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeUpdateInput `json:"customTimeframe,omitempty"`
}

// Define settings for a policy section
type PolicySectionInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type PolicySectionMutationPayload struct {
	Errors  []*PolicyMutationError `json:"errors"`
	Section *PolicySectionPayload  `json:"section,omitempty"`
	Status  PolicyMutationStatus   `json:"status"`
}

type PolicySectionPayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Section    *PolicySectionInfo            `json:"section"`
}

type PolicySectionPositionInput struct {
	Position PolicySectionPositionEnum `json:"position"`
	Ref      *string                   `json:"ref,omitempty"`
}

type PolicyTracking struct {
	Alert *PolicyRuleTrackingAlert `json:"alert"`
	Event *PolicyRuleTrackingEvent `json:"event"`
}

type PolicyTrackingInput struct {
	Alert *PolicyRuleTrackingAlertInput `json:"alert"`
	Event *PolicyRuleTrackingEventInput `json:"event"`
}

type PolicyTrackingUpdateInput struct {
	Alert *PolicyRuleTrackingAlertUpdateInput `json:"alert,omitempty"`
	Event *PolicyRuleTrackingEventUpdateInput `json:"event,omitempty"`
}

type PolicyUpdateSectionInfoInput struct {
	Name *string `json:"name,omitempty"`
}

type PolicyUpdateSectionInput struct {
	ID      string                        `json:"id"`
	Section *PolicyUpdateSectionInfoInput `json:"section"`
}

type PooledBandwidthLicense struct {
	// Accounts that this license is assigned to (and the license usage within each account)
	Accounts []*PartnerPooledBandwidthLicenseAccount `json:"accounts"`
	// allocated bandwidth, in Mbps, for all the sites assigned to this license.
	AllocatedBandwidth int64   `json:"allocatedBandwidth"`
	Description        *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// Regional license group
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// Sites that this license is assigned to (and the license usage within each site)
	Sites []*PooledBandwidthLicenseSite `json:"sites"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Maximum available bandwidth, in Mbps, for all the sites under this license. This constitutes the bandwidth pool that is allocated to different sites.
	Total int64 `json:"total"`
}

func (PooledBandwidthLicense) IsLicense()                   {}
func (this PooledBandwidthLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PooledBandwidthLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PooledBandwidthLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PooledBandwidthLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PooledBandwidthLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PooledBandwidthLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PooledBandwidthLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PooledBandwidthLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PooledBandwidthLicense) GetTotal() int64 { return this.Total }

type PooledBandwidthLicenseSite struct {
	// Allocated bandwidth for this site
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
	// Identifying data for the site
	Site *SiteRef `json:"site"`
}

// Inclusive network port range
type PortRange struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Inclusive network port range
type PortRangeInput struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Public IP address license
type PublicIpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The number of public IPs available in the licenses
	Total int64 `json:"total"`
}

func (PublicIpsLicense) IsLicense()                   {}
func (this PublicIpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PublicIpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PublicIpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PublicIpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PublicIpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PublicIpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PublicIpsLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PublicIpsLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PublicIpsLicense) GetTotal() int64 { return this.Total }

// IP addresses license usage and allocation across all accounts
type PublicIpsLicenseAllocations struct {
	Allocated int64 `json:"allocated"`
	Available int64 `json:"available"`
	Total     int64 `json:"total"`
}

type Query struct {
}

type RBACRole struct {
	Description  *string `json:"description,omitempty"`
	ID           string  `json:"id"`
	IsPredefined bool    `json:"isPredefined"`
	Name         string  `json:"name"`
}

type RbacGroup struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// Remote Browser Isolation (RBI) service license details
type RbiLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (RbiLicense) IsLicense()                   {}
func (this RbiLicense) GetDescription() *string { return this.Description }

// License plan type
func (this RbiLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this RbiLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this RbiLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this RbiLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this RbiLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this RbiLicense) GetLastUpdated() *string { return this.LastUpdated }

type RecentConnection struct {
	// Serial number for the Device
	DeviceName *string `json:"deviceName,omitempty"`
	// The duration of the connection
	Duration *int64 `json:"duration,omitempty"`
	// Name for the port in the Cato Management Application
	InterfaceName *string `json:"interfaceName,omitempty"`
	// The last time this connection was detected (so lastConnected - duration is the start of the connection
	LastConnected *string `json:"lastConnected,omitempty"`
	// The name of the PoP that the traffic flow was connected to
	PopName *string `json:"popName,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the PoP that the traffic flow was connected to
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
}

type RemoveAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type RemoveSitePayload struct {
	SiteID string `json:"siteId"`
}

type RemoveStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// SaaS Security API service license details
type SaasSecurityAPILicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// license quantity
	Total int64 `json:"total"`
}

func (SaasSecurityAPILicense) IsLicense()                   {}
func (this SaasSecurityAPILicense) GetDescription() *string { return this.Description }

// License plan type
func (this SaasSecurityAPILicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SaasSecurityAPILicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SaasSecurityAPILicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SaasSecurityAPILicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SaasSecurityAPILicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SaasSecurityAPILicense) GetLastUpdated() *string { return this.LastUpdated }

func (SaasSecurityAPILicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SaasSecurityAPILicense) GetTotal() int64 { return this.Total }

type SanctionedAppsCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SanctionedAppsCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this SanctionedAppsCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this SanctionedAppsCategoryRef) GetName() string { return this.Name }

type SanctionedAppsCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ServiceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ServiceRef) IsObjectRef() {}

// Object's unique identifier
func (this ServiceRef) GetID() string { return this.ID }

// Object's unique name
func (this ServiceRef) GetName() string { return this.Name }

type ServiceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SimilarStoryData struct {
	Indication           *string  `json:"indication,omitempty"`
	SimilarityPercentage *float64 `json:"similarityPercentage,omitempty"`
	StoryID              *string  `json:"storyId,omitempty"`
	ThreatClassification *string  `json:"threatClassification,omitempty"`
	ThreatTypeName       *string  `json:"threatTypeName,omitempty"`
	Verdict              *string  `json:"verdict,omitempty"`
}

// Basic Site configuration information
type SiteInfo struct {
	// City of the physical site location
	CityName *string `json:"cityName,omitempty"`
	// The Connection Type field defines how the site connects to the Cato Cloud, such as X1500 Socket or AWS vSocket (array with nested fields)
	ConnType *ProtoType `json:"connType,omitempty"`
	// Code for the Country that is the physical location of the site
	CountryCode *string `json:"countryCode,omitempty"`
	// Country that is the physical location of the site
	CountryName *string `json:"countryName,omitempty"`
	// State of the country that is the physical site location
	CountryStateName *string `json:"countryStateName,omitempty"`
	// Timestamp for when the site was created
	CreationTime *string `json:"creationTime,omitempty"`
	// User defined description of the site
	Description *string `json:"description,omitempty"`
	// Basic configuration information about the Socket interface
	Interfaces []*InterfaceInfo `json:"interfaces,omitempty"`
	// data related to IPsec sites, such as IKE version
	Ipsec []*IPSecInfo `json:"ipsec,omitempty"`
	// When this boolean value is true, the site is enabled for high availability
	IsHa *bool `json:"isHA,omitempty"`
	// Name for the site
	Name *string `json:"name,omitempty"`
	// Geographical PoP region that the site is licensed to use
	Region *string `json:"region,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version (array with nested fields)
	Sockets []*SocketInfo `json:"sockets,omitempty"`
	// Site type in the Cato Management Application, such as branch office or datacenter
	Type *SiteType `json:"type,omitempty"`
}

// Site bandwidth license
type SiteLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// For the relevant license groups, indicates whether this is a global or regional license. For other regions, the value is set to ‘NA’ (not applicable).
	Regionality *Regionality `json:"regionality,omitempty"`
	// Identifying data for the site the license is assigned to
	Site *SiteRef `json:"site,omitempty"`
	// The license group.
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Maximum available bandwidth for the site, in Mbps
	Total int64 `json:"total"`
}

func (SiteLicense) IsLicense()                   {}
func (this SiteLicense) GetDescription() *string { return this.Description }

// License plan type
func (this SiteLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SiteLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SiteLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SiteLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SiteLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SiteLicense) GetLastUpdated() *string { return this.LastUpdated }

func (SiteLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SiteLicense) GetTotal() int64 { return this.Total }

type SiteMetrics struct {
	// Timeseries with the number of flows (connections) in the site. Applicable only for site
	FlowCount *Timeseries `json:"flowCount,omitempty"`
	// Timeseries with the number of hosts in the site. Applicable only for site
	HostCount *Timeseries `json:"hostCount,omitempty"`
	// Timeseries with the configurable limit of the number of hosts in the site. Applicable only for site
	HostLimit *Timeseries `json:"hostLimit,omitempty"`
	// Site ID
	ID *string `json:"id,omitempty"`
	// Shows general information about the site (array with nested fields). Applicable only for site
	Info *SiteInfo `json:"info,omitempty"`
	// Analytics that are returned for the links for a site
	Interfaces []*InterfaceMetrics `json:"interfaces,omitempty"`
	// Traffic metrics and data for sites
	Metrics *Metrics `json:"metrics,omitempty"`
	// Site names
	Name    *string `json:"name,omitempty"`
	Samples *int64  `json:"samples,omitempty"`
}

type SiteMutations struct {
	AddIpsecIkeV2Site                  *AddIpsecIkeV2SitePayload                  `json:"addIpsecIkeV2Site,omitempty"`
	AddIpsecIkeV2SiteTunnels           *AddIpsecIkeV2SiteTunnelsPayload           `json:"addIpsecIkeV2SiteTunnels,omitempty"`
	AddNetworkRange                    *AddNetworkRangePayload                    `json:"addNetworkRange,omitempty"`
	AddSocketSite                      *AddSocketSitePayload                      `json:"addSocketSite,omitempty"`
	AddStaticHost                      *AddStaticHostPayload                      `json:"addStaticHost,omitempty"`
	RemoveNetworkRange                 *RemoveNetworkRangePayload                 `json:"removeNetworkRange,omitempty"`
	RemoveSite                         *RemoveSitePayload                         `json:"removeSite,omitempty"`
	RemoveStaticHost                   *RemoveStaticHostPayload                   `json:"removeStaticHost,omitempty"`
	UpdateHa                           *UpdateHaPayload                           `json:"updateHa,omitempty"`
	UpdateIpsecIkeV2SiteGeneralDetails *UpdateIpsecIkeV2SiteGeneralDetailsPayload `json:"updateIpsecIkeV2SiteGeneralDetails,omitempty"`
	UpdateIpsecIkeV2SiteTunnels        *UpdateIpsecIkeV2SiteTunnelsPayload        `json:"updateIpsecIkeV2SiteTunnels,omitempty"`
	UpdateNetworkRange                 *UpdateNetworkRangePayload                 `json:"updateNetworkRange,omitempty"`
	UpdateSiteGeneralDetails           *UpdateSiteGeneralDetailsPayload           `json:"updateSiteGeneralDetails,omitempty"`
	UpdateSocketInterface              *UpdateSocketInterfacePayload              `json:"updateSocketInterface,omitempty"`
	UpdateStaticHost                   *UpdateStaticHostPayload                   `json:"updateStaticHost,omitempty"`
}

type SiteNetworkSubnetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteNetworkSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteNetworkSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteNetworkSubnetRef) GetName() string { return this.Name }

type SiteNetworkSubnetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteRef) GetName() string { return this.Name }

type SiteRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteSnapshot struct {
	// Alternative WAN connectivity status
	AltWanStatus *string `json:"altWanStatus,omitempty"`
	// For connected sites, since when are they connected
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// Data related to the Sockets for a site
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// Site HA readiness information
	HaStatus *HaStatus `json:"haStatus,omitempty"`
	// Number of hosts connected to a site
	HostCount *int64 `json:"hostCount,omitempty"`
	// site ID
	ID *string `json:"id,omitempty"`
	// General real-time information about the site
	Info *SiteInfo `json:"info,omitempty"`
	// Relevant when the site is disconnected - the last time the device was connected
	LastConnected *string `json:"lastConnected,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *OperationalStatus `json:"operationalStatus,omitempty"`
	// Name of the PoP that the site is connected to
	PopName *string `json:"popName,omitempty"`
	ProtoID *int64  `json:"protoId,omitempty"`
}

// Basic information about socket
type SocketInfo struct {
	// Unique ID for Socket
	ID *string `json:"id,omitempty"`
	// For HA configurations, when this boolean value is true, this the primary Socket
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// Shows Socket type
	Platform *SocketPlatform `json:"platform,omitempty"`
	// Serial number for the Socket
	Serial *string `json:"serial,omitempty"`
	// Software version number that is currently installed on the Socket
	Version *string `json:"version,omitempty"`
	// Timestamp when the Socket upgraded to the current hardware version
	VersionUpdateTime *string `json:"versionUpdateTime,omitempty"`
}

type SocketInterfaceAltWanInput struct {
	PrivateGatewayIP   string  `json:"privateGatewayIp"`
	PrivateInterfaceIP string  `json:"privateInterfaceIp"`
	PrivateNetwork     string  `json:"privateNetwork"`
	PrivateVlanTag     *int64  `json:"privateVlanTag,omitempty"`
	PublicGatewayIP    *string `json:"publicGatewayIp,omitempty"`
	PublicInterfaceIP  *string `json:"publicInterfaceIp,omitempty"`
	PublicNetwork      *string `json:"publicNetwork,omitempty"`
	PublicVlanTag      *int64  `json:"publicVlanTag,omitempty"`
}

type SocketInterfaceBandwidthInput struct {
	DownstreamBandwidth int64 `json:"downstreamBandwidth"`
	UpstreamBandwidth   int64 `json:"upstreamBandwidth"`
}

type SocketInterfaceLagInput struct {
	MinLinks int64 `json:"minLinks"`
}

type SocketInterfaceLanInput struct {
	LocalIP          string  `json:"localIp"`
	Subnet           string  `json:"subnet"`
	TranslatedSubnet *string `json:"translatedSubnet,omitempty"`
}

type SocketInterfaceOffCloudInput struct {
	Enabled          bool    `json:"enabled"`
	PublicIP         *string `json:"publicIp,omitempty"`
	PublicStaticPort *int64  `json:"publicStaticPort,omitempty"`
}

type SocketInterfaceVrrpInput struct {
	VrrpType *VrrpType `json:"vrrpType,omitempty"`
}

type SocketInterfaceWanInput struct {
	Precedence SocketInterfacePrecedenceEnum `json:"precedence"`
	Role       SocketInterfaceRole           `json:"role"`
}

type SocketInventoryFilterInput struct {
	// Will run contains operation for the provided text on the following fields serialNumber,socketMac,socketVersion,installedSite,
	// shippingCompany,trackingNumber,deliverySiteName,description with OR between them
	FreeText *FreeTextFilterInput `json:"freeText,omitempty"`
}

type SocketInventoryInput struct {
	Filter *SocketInventoryFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                `json:"paging,omitempty"`
	Sort   *SocketInventoryOrderInput  `json:"sort,omitempty"`
}

type SocketInventoryItem struct {
	// Socket account
	Account *AccountRef `json:"account"`
	// Available upgrade versions
	AvailableUpgradeVersions []string `json:"availableUpgradeVersions"`
	// Name of the delivery site
	DeliverySiteName *string `json:"deliverySiteName,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// ID
	ID string `json:"id"`
	// Is primary socket
	IsPrimary bool `json:"isPrimary"`
	// Registration status
	RegistrationStatus *SocketRegistrationStatus `json:"registrationStatus,omitempty"`
	// Serial number (unique)
	SerialNumber *string `json:"serialNumber,omitempty"`
	// Shipping company
	ShippingCompany *string `json:"shippingCompany,omitempty"`
	// Shipping date
	ShippingDate *string `json:"shippingDate,omitempty"`
	// Socket's site
	Site *SiteRef `json:"site,omitempty"`
	// Mac address
	SocketMac *string `json:"socketMac,omitempty"`
	// Socket Type
	SocketType *SocketPlatform `json:"socketType,omitempty"`
	// Socket version
	SocketVersion *string `json:"socketVersion,omitempty"`
	// Socket status (see SocketInventoryItemStatus)
	Status *SocketInventoryItemStatus `json:"status,omitempty"`
	// tracking number from the shipping company
	TrackingNumber *string `json:"trackingNumber,omitempty"`
	// tracking url from the shipping company
	TrackingURL *string `json:"trackingUrl,omitempty"`
	// Are automatic upgrade paused
	UpgradesPaused bool `json:"upgradesPaused"`
	// Upgrade status
	UpgradeStatus *SocketUpgradeStatus `json:"upgradeStatus,omitempty"`
}

type SocketInventoryOrderInput struct {
	DeliverySiteName *SortOrderInput `json:"deliverySiteName,omitempty"`
	Description      *SortOrderInput `json:"description,omitempty"`
	InstalledSite    *SortOrderInput `json:"installedSite,omitempty"`
	SerialNumber     *SortOrderInput `json:"serialNumber,omitempty"`
	ShippingCompany  *SortOrderInput `json:"shippingCompany,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	SocketType       *SortOrderInput `json:"socketType,omitempty"`
	// Default sort field
	Status *SortOrderInput `json:"status,omitempty"`
}

type SocketInventoryPayload struct {
	Items    []*SocketInventoryItem `json:"items"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type SortInput struct {
	Field *string         `json:"field,omitempty"`
	Order *DirectionInput `json:"order,omitempty"`
}

type SortOrderInput struct {
	Direction SortOrder `json:"direction"`
	Priority  int64     `json:"priority"`
}

type StoriesData struct {
	// Fields returned from the Story query
	Items []*Story `json:"items"`
	// Define the stories that are returned, similar to a page of stories in the Cato Management Application
	Paging *Paging `json:"paging"`
}

type Story struct {
	// ID for your Cato account
	AccountID int64 `json:"accountId"`
	// Name of the account in the Cato Management Application
	AccountName *string `json:"accountName,omitempty"`
	// Email address of the analyst working on the story
	AnalystEmail *string `json:"analystEmail,omitempty"`
	// Name of analyst working on the story
	AnalystName *string `json:"analystName,omitempty"`
	// Timestamp when the story was created
	CreatedAt string `json:"createdAt"`
	// Unique Cato ID for each story
	ID string `json:"id"`
	// Data related to the fields and incidents that were merged to create or update the story
	Incident MergedIncident `json:"incident"`
	// URL for the playbook in the Knowledge Base to help troubleshoot the story
	Playbook *string `json:"playbook,omitempty"`
	// Summary of the story
	Summary *string `json:"summary,omitempty"`
	// Data for the story timeline
	Timeline []*TimelineItem `json:"timeline"`
	// Timestamp when the story was most recently updated
	UpdatedAt string `json:"updatedAt"`
}

type StoryDrillDownFilter struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type StoryFilterInput struct {
	AccountID   *AccountIDPredicate     `json:"accountId,omitempty"`
	Criticality *IntPredicate           `json:"criticality,omitempty"`
	EngineType  *EngineTypePredicate    `json:"engineType,omitempty"`
	IncidentID  *StringPredicate        `json:"incidentId,omitempty"`
	Ioa         *StringPredicate        `json:"ioa,omitempty"`
	Muted       *BooleanPredicate       `json:"muted,omitempty"`
	Producer    *StoryProducerPredicate `json:"producer,omitempty"`
	QueryName   *StringPredicate        `json:"queryName,omitempty"`
	Severity    *StorySeverityPredicate `json:"severity,omitempty"`
	Source      *StringPredicate        `json:"source,omitempty"`
	SourceIP    *StringPredicate        `json:"sourceIp,omitempty"`
	Status      *StoryStatusPredicate   `json:"status,omitempty"`
	StoryID     *StoryIDPredicate       `json:"storyId,omitempty"`
	TimeFrame   *TimeFramePredicate     `json:"timeFrame"`
	Vendor      *VendorPredicate        `json:"vendor,omitempty"`
	Verdict     *StoryVerdictPredicate  `json:"verdict,omitempty"`
}

type StoryIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type StoryInput struct {
	Filter []*StoryFilterInput `json:"filter"`
	Paging *PagingInput        `json:"paging"`
	Sort   []*StorySortInput   `json:"sort,omitempty"`
}

type StoryProducerPredicate struct {
	In    []StoryProducerEnum `json:"in,omitempty"`
	NotIn []StoryProducerEnum `json:"not_in,omitempty"`
}

type StorySeverityPredicate struct {
	In    []SeverityEnum `json:"in,omitempty"`
	NotIn []SeverityEnum `json:"not_in,omitempty"`
}

type StorySortInput struct {
	FieldName StorySortFieldName `json:"fieldName"`
	Order     *SortDirectionEnum `json:"order,omitempty"`
}

type StoryStatusPredicate struct {
	In    []StoryStatusEnum `json:"in,omitempty"`
	NotIn []StoryStatusEnum `json:"not_in,omitempty"`
}

type StoryVerdictPredicate struct {
	In    []StoryVerdictEnum `json:"in,omitempty"`
	NotIn []StoryVerdictEnum `json:"not_in,omitempty"`
}

type StringPredicate struct {
	Contains *string   `json:"contains,omitempty"`
	In       []*string `json:"in,omitempty"`
	NotIn    []*string `json:"not_in,omitempty"`
}

type StringValue struct {
	String *string `json:"string,omitempty"`
}

func (StringValue) IsValue() {}

type SubDomain struct {
	AccountID   string `json:"accountId"`
	AccountName string `json:"accountName"`
	AccountType string `json:"accountType"`
	SubDomain   string `json:"subDomain"`
}

type SubscriptionGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionGroupRef) GetName() string { return this.Name }

type SubscriptionGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SubscriptionMailingListRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionMailingListRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionMailingListRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionMailingListRef) GetName() string { return this.Name }

type SubscriptionMailingListRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SubscriptionWebhookRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionWebhookRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionWebhookRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionWebhookRef) GetName() string { return this.Name }

type SubscriptionWebhookRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SystemGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SystemGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SystemGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SystemGroupRef) GetName() string { return this.Name }

type SystemGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type Threat struct {
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// Client Class for the traffic flow
	ClientClass []string `json:"clientClass"`
	// Enum for the connection for this incident (ie. site, host, user)
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// Traffic direction for the threat
	Direction *string `json:"direction,omitempty"`
	// XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Data for the Cato event for this story
	Events []*Event `json:"events,omitempty"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// Data about the traffic flow for the threat
	Flows []*IncidentFlow `json:"flows,omitempty"`
	// Cardinality of traffic flows for the threat
	FlowsCardinality *int64 `json:"flowsCardinality,omitempty"`
	// Unique Cato ID for this threat
	ID string `json:"id"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string `json:"indication"`
	// Timestamp for the first incident signal related to this story
	LastSignal string `json:"lastSignal"`
	// Username for the device
	LogonName *string `json:"logonName,omitempty"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
	// Mitre data for the story (ie. ID, name)
	Mitres []*Mitre `json:"mitres,omitempty"`
	// OS for device or host that is the threat target
	Os *string `json:"os,omitempty"`
	// Cato’s predicted threat type for the story
	PredictedThreatType *string `json:"predictedThreatType,omitempty"`
	// Enum for Cato’s predicted verdict of the story (ie. Malicious, Benign)
	PredictedVerdict *StoryVerdictEnum `json:"predictedVerdict,omitempty"`
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string `json:"producerName"`
	// Category for the indication ID related to the story
	QueryName *string `json:"queryName,omitempty"`
	// The value is TRUE when the story is currently being researched by Security Analysts
	Research *bool `json:"research,omitempty"`
	// The estimated risk level of the threat (ie. Malicious, High, Low)
	RiskLevel *RiskLevelEnum `json:"riskLevel,omitempty"`
	// Data for stories that are similar
	SimilarStoriesData []*SimilarStoryData `json:"similarStoriesData"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// The source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Cato ID for the site that is the source of the threat
	SrcSiteID *string `json:"srcSiteId,omitempty"`
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	Status *StoryStatusEnum `json:"status,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// Data about the target of the threat
	Targets []*IncidentTargetRep `json:"targets"`
	// The ticket an analyst created for this story
	Ticket *string `json:"ticket,omitempty"`
	// Timeseries data for the incident
	TimeSeries []*IncidentTimeseries `json:"timeSeries,omitempty"`
	// Cato ID and name for the user
	User *UserRef `json:"user,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
}

func (Threat) IsMergedIncident() {}

// Unique Cato ID for each story
func (this Threat) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this Threat) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this Threat) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this Threat) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this Threat) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this Threat) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this Threat) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this Threat) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this Threat) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this Threat) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this Threat) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this Threat) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this Threat) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this Threat) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this Threat) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this Threat) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this Threat) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this Threat) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this Threat) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this Threat) GetUser() *UserRef                      { return this.User }
func (this Threat) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this Threat) GetPredictedThreatType() *string        { return this.PredictedThreatType }

type ThreatPrevention struct {
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	ClientClass             []string                  `json:"clientClass"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceName              *string                   `json:"deviceName,omitempty"`
	Direction               *string                   `json:"direction,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	Events                  []*Event                  `json:"events,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	FlowsCardinality        *int64                    `json:"flowsCardinality,omitempty"`
	ID                      string                    `json:"id"`
	Indication              string                    `json:"indication"`
	LastSignal              string                    `json:"lastSignal"`
	LogonName               *string                   `json:"logonName,omitempty"`
	MacAddress              *string                   `json:"macAddress,omitempty"`
	Mitres                  []*Mitre                  `json:"mitres,omitempty"`
	Os                      *string                   `json:"os,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RiskLevel               *RiskLevelEnum            `json:"riskLevel,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteName                *string                   `json:"siteName,omitempty"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	SrcSiteID               *string                   `json:"srcSiteId,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	Targets                 []*IncidentTargetRep      `json:"targets"`
	ThreatPreventionsEvents []*ThreatPreventionEvents `json:"threatPreventionsEvents,omitempty"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	TimeSeries              []*IncidentTimeseries     `json:"timeSeries,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (ThreatPrevention) IsMergedIncident() {}

// Unique Cato ID for each story
func (this ThreatPrevention) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this ThreatPrevention) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this ThreatPrevention) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this ThreatPrevention) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this ThreatPrevention) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this ThreatPrevention) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this ThreatPrevention) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this ThreatPrevention) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this ThreatPrevention) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this ThreatPrevention) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this ThreatPrevention) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this ThreatPrevention) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this ThreatPrevention) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this ThreatPrevention) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this ThreatPrevention) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this ThreatPrevention) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this ThreatPrevention) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this ThreatPrevention) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this ThreatPrevention) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this ThreatPrevention) GetUser() *UserRef                      { return this.User }
func (this ThreatPrevention) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this ThreatPrevention) GetPredictedThreatType() *string        { return this.PredictedThreatType }

type ThreatPreventionEvents struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referrer               *string `json:"referrer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

// Threat Prevention (TP) license details
type ThreatPreventionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (ThreatPreventionLicense) IsLicense()                   {}
func (this ThreatPreventionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ThreatPreventionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ThreatPreventionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ThreatPreventionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ThreatPreventionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ThreatPreventionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ThreatPreventionLicense) GetLastUpdated() *string { return this.LastUpdated }

// An object for marking specific events in time.
type TimeAnnotation struct {
	// Description of the event
	Label string `json:"label"`
	// Brief description of the event
	ShortLabel string `json:"shortLabel"`
	// Timestamp of the event
	Time float64 `json:"time"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type AnnotationType `json:"type"`
}

type TimeFramePredicate struct {
	Time              string             `json:"time"`
	TimeFrameModifier *TimeFrameModifier `json:"timeFrameModifier,omitempty"`
}

// An object for marking durations!
type TimePeriod struct {
	// An tuple of two numbers representing  start time, end time in ms since epoch, start bucket index, end bucket index
	Duration []float64 `json:"duration"`
	// Label that describes the metrics
	Title string `json:"title"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type PeriodType `json:"type"`
}

type TimelineItem struct {
	// Additional information about this timeline item
	AdditionalInfo *string `json:"additionalInfo,omitempty"`
	// Data about the analyst for this timeline item (ie. name, email)
	AnalystInfo *AnalystInfo `json:"analystInfo,omitempty"`
	// Enum for the timeline category (ie. Information, Warning, Error)
	Category *TimelineItemCategoryEnum `json:"category,omitempty"`
	// Status of the timeline item
	Context string `json:"context"`
	// Timestamp the story was created
	CreatedAt string `json:"createdAt"`
	// Description for the story in the timeline
	Description string `json:"description"`
	// Description for the story in the timeline
	Descriptions []string `json:"descriptions"`
	// Enum for the type (ie. Diff, Action, Comment)
	Type TimelineTypeEnum `json:"type"`
}

type Timeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// List of dimension values for this timeseries
	Dimensions []*DimensionData `json:"dimensions,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string `json:"info,omitempty"`
	// Timeseries key: measure and dimension values
	Key *TimeseriesKey `json:"key,omitempty"`
	// Indicates the type of the timeseries
	Label string `json:"label"`
	// Summary of the metrics over the given time frame
	Sum *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
}

type TimeseriesKey struct {
	// List of dimension key-value pair for this timeseries key
	Dimensions []*DimensionKey `json:"dimensions,omitempty"`
	// Measure field
	MeasureFieldName string `json:"measureFieldName"`
}

type UpdateAccountRoleInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type UpdateAdminInput struct {
	FirstName            *string                 `json:"firstName,omitempty"`
	LastName             *string                 `json:"lastName,omitempty"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	PasswordNeverExpires *bool                   `json:"passwordNeverExpires,omitempty"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateAdminRoleInput struct {
	AllowedAccounts []string                `json:"allowedAccounts,omitempty"`
	AllowedEntities []*EntityInput          `json:"allowedEntities,omitempty"`
	Role            *UpdateAccountRoleInput `json:"role"`
}

// Input for updating FQDN typed container from file
type UpdateFqdnContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
	// Multipart file containing FQDNs with csv/newline delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on FQDN typed container
type UpdateFqdnContainerFromFilePayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type UpdateHaInput struct {
	PrimaryManagementIP   *string `json:"primaryManagementIp,omitempty"`
	SecondaryManagementIP *string `json:"secondaryManagementIp,omitempty"`
	Vrid                  *int64  `json:"vrid,omitempty"`
}

type UpdateHaPayload struct {
	SiteID string `json:"siteId"`
}

// Input for updating existing IPAddressRange typed container from file
type UpdateIPAddressRangeContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
	// Multipart file containing IPAddressRanges with csv/newline delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on IPAddressRange typed container
type UpdateIPAddressRangeContainerFromFilePayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsInput struct {
	// The auth message parameters.
	AuthMessage *IpsecIkeV2MessageInput `json:"authMessage,omitempty"`
	// Determines the protocol for establishing the Security Association (SA) Tunnel. Valid values are:
	// Responder-Only Mode: Cato Cloud only responds to incoming requests by the initiator (e.g. a Firewall device) to establish a security association.
	// Bidirectional Mode: Both Cato Cloud and the peer device on customer site can initiate the IPSec SA establishment.
	ConnectionMode *ConnectionMode `json:"connectionMode,omitempty"`
	// The authentication identification type used for SA authentication. When using “BIDIRECTIONAL”, it is set to “IPv4” by default. Other methods are available in Responder mode only.
	IdentificationType *IdentificationType `json:"identificationType,omitempty"`
	// The init message parameters
	InitMessage *IpsecIkeV2MessageInput `json:"initMessage,omitempty"`
	// The local IP ranges for the SAs
	NetworkRanges []*string `json:"networkRanges,omitempty"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload struct {
	// The local ID for the site
	LocalID *string `json:"localId,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*UpdateIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type UpdateIpsecIkeV2SiteTunnelPayload struct {
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *UpdateIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *UpdateIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsPayload struct {
	// The primary multi-tunnel
	Primary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// The secondary multi-tunnel
	Secondary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type UpdateIpsecIkeV2TunnelInput struct {
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk *string `json:"psk,omitempty"`
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
	// The ID of the tunnel
	TunnelID IPSecV2InterfaceID `json:"tunnelId"`
}

type UpdateIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The PoP location ID
	PopLocationID *string `json:"popLocationId,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string                        `json:"publicCatoIpId,omitempty"`
	Tunnels        []*UpdateIpsecIkeV2TunnelInput `json:"tunnels"`
}

type UpdateNetworkRangeInput struct {
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway *string `json:"gateway,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector    *bool       `json:"mdnsReflector,omitempty"`
	Name             *string     `json:"name,omitempty"`
	RangeType        *SubnetType `json:"rangeType,omitempty"`
	Subnet           *string     `json:"subnet,omitempty"`
	TranslatedSubnet *string     `json:"translatedSubnet,omitempty"`
	// Only relevant for VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
}

type UpdateNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type UpdateSiteGeneralDetailsInput struct {
	Description  *string                  `json:"description,omitempty"`
	Name         *string                  `json:"name,omitempty"`
	SiteLocation *UpdateSiteLocationInput `json:"siteLocation,omitempty"`
	SiteType     *SiteType                `json:"siteType,omitempty"`
}

type UpdateSiteGeneralDetailsPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateSiteLocationInput struct {
	Address     *string `json:"address,omitempty"`
	CityName    *string `json:"cityName,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    *string `json:"timezone,omitempty"`
}

type UpdateSocketInterfaceInput struct {
	// Only relevant for ALTERNATIVE, LAYER_2_WAN
	AltWan *SocketInterfaceAltWanInput `json:"altWan,omitempty"`
	// Only relevant for CATO, ALTERNATIVE, LAYER_2_WAN
	Bandwidth *SocketInterfaceBandwidthInput `json:"bandwidth,omitempty"`
	DestType  SocketInterfaceDestType        `json:"destType"`
	// Only relevant for LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lag *SocketInterfaceLagInput `json:"lag,omitempty"`
	// Only relevant for LAN, VRRP_AND_LAN, LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lan  *SocketInterfaceLanInput `json:"lan,omitempty"`
	Name *string                  `json:"name,omitempty"`
	// Only relevant for CATO
	OffCloud *SocketInterfaceOffCloudInput `json:"offCloud,omitempty"`
	// Only relevant for VRRP
	Vrrp *SocketInterfaceVrrpInput `json:"vrrp,omitempty"`
	// Only relevant for CATO
	Wan *SocketInterfaceWanInput `json:"wan,omitempty"`
}

type UpdateSocketInterfacePayload struct {
	SiteID            string                `json:"siteId"`
	SocketInterfaceID SocketInterfaceIDEnum `json:"socketInterfaceId"`
}

type UpdateStaticHostInput struct {
	IP         *string `json:"ip,omitempty"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type UpdateStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// Basic User configuration information
type UserInfo struct {
	// Additional authentication mechanism, currently MFA or NONE
	AuthMethod *string `json:"authMethod,omitempty"`
	// Timestamp when the VPN user was created in the account
	CreationTime *string `json:"creationTime,omitempty"`
	// Email address of the VPN user
	Email *string `json:"email,omitempty"`
	// Name of the VPN user
	Name *string `json:"name,omitempty"`
	// User creation mechanism, current supported REGULAR or LDAP
	Origin *string `json:"origin,omitempty"`
	// Phone number for the VPN user
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// Status of the Client as the type STRING
	Status *OperationalStatus `json:"status,omitempty"`
}

type UserRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UserRef) IsObjectRef() {}

// Object's unique identifier
func (this UserRef) GetID() string { return this.ID }

// Object's unique name
func (this UserRef) GetName() string { return this.Name }

type UserRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type UserSnapshot struct {
	// In this state the client does not create its own connection, but reuses
	// the Office's socket connection
	ConnectedInOffice *bool `json:"connectedInOffice,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// The host name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// Data related to the Client
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// VPN user ID
	ID *string `json:"id,omitempty"`
	// General information about the VPN user
	Info *UserInfo `json:"info,omitempty"`
	// IP address of the PoP that the Client is connected to
	InternalIP *string `json:"internalIP,omitempty"`
	// Last time the user was connected (relevant if not currently connected)
	LastConnected *string `json:"lastConnected,omitempty"`
	// User name from configuration, same as info.name
	Name *string `json:"name,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *OperationalStatus `json:"operationalStatus,omitempty"`
	// Operating system of the device the Client is running on
	OsType *string `json:"osType,omitempty"`
	// Version of the operating system for the device
	OsVersion *string `json:"osVersion,omitempty"`
	// ID of the PoP that the Client is connected to
	PopID *int64 `json:"popID,omitempty"`
	// Name of the PoP that the VPN user is connected to
	PopName *string `json:"popName,omitempty"`
	// Data related to the most recent completed VPN connections
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
	// IP address of the Client
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the Client
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// How long has the user been connected (in seconds)
	Uptime *int64 `json:"uptime,omitempty"`
	// VPN client version string
	Version *string `json:"version,omitempty"`
	// VPN client version number
	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

type UsersGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UsersGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this UsersGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this UsersGroupRef) GetName() string { return this.Name }

type UsersGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type VendorPredicate struct {
	In    []VendorEnum `json:"in,omitempty"`
	NotIn []VendorEnum `json:"not_in,omitempty"`
}

type WanFirewallAddRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationInput `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country"`
	Description string             `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem        `json:"deviceOS"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	Enabled   bool                     `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions"`
	Name       string                           `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceInput `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Rule parameters and relevant position
type WanFirewallAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *WanFirewallAddRuleDataInput `json:"rule"`
}

// Application match criteria set
type WanFirewallApplication struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
}

// Returns the settings for Destination of a Wan Firewall rule
type WanFirewallDestination struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule
type WanFirewallDestinationInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule
type WanFirewallDestinationUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type WanFirewallPolicy struct {
	Audit    *PolicyAudit              `json:"audit,omitempty"`
	Enabled  bool                      `json:"enabled"`
	Revision *PolicyRevision           `json:"revision,omitempty"`
	Rules    []*WanFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload   `json:"sections"`
}

func (WanFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this WanFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this WanFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this WanFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this WanFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this WanFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type WanFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Wan Firewall policy information provided in the API response
type WanFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *WanFirewallPolicy     `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this WanFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this WanFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Wan Firewall Policy information returned to the caller in the API response.
type WanFirewallPolicyMutations struct {
	// Add a new rule to the Wan Firewall policy.
	AddRule *WanFirewallRuleMutationPayload `json:"addRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection            *PolicySectionMutationPayload     `json:"addSection"`
	CreatePolicyRevision  *WanFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *WanFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the relative location of an existing rule within the Wan Firewall policy.
	MoveRule *WanFirewallRuleMutationPayload `json:"moveRule"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	PublishPolicyRevision *WanFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	// Remove an existing rule from the Wan Firewall policy.
	RemoveRule *WanFirewallRuleMutationPayload `json:"removeRule"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *WanFirewallPolicyMutationPayload `json:"updatePolicy"`
	// Update an existing rule of the Wan Firewall policy.
	UpdateRule *WanFirewallRuleMutationPayload `json:"updateRule"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
}

type WanFirewallPolicyQueries struct {
	Policy    *WanFirewallPolicy      `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanFirewallRule struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplication `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestination `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem        `json:"deviceOS"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleException `json:"exceptions"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceType `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSource `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
}

func (WanFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this WanFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this WanFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this WanFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this WanFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this WanFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this WanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleException struct {
	// Application matching criteria for the exception.
	Application *WanFirewallApplication `json:"application"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestination `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceType `json:"service"`
	// Source matching criteria for the exception.
	Source *WanFirewallSource `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleExceptionInput struct {
	// Application matching criteria for the exception.
	Application *WanFirewallApplicationInput `json:"application"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// Source matching criteria for the exception.
	Source *WanFirewallSourceInput `json:"source"`
}

type WanFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Rule   *WanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (WanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this WanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this WanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Wan Firewall policy information for a specific revision
type WanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *WanFirewallRule              `json:"rule"`
}

func (WanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this WanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this WanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this WanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Wan Firewall rule
type WanFirewallSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule
type WanFirewallSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule
type WanFirewallSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type WanFirewallUpdateRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action *WanFirewallActionEnum `json:"action,omitempty"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationUpdateInput `json:"application,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country,omitempty"`
	Description *string            `json:"description,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem         `json:"deviceOS,omitempty"`
	Direction *WanFirewallDirectionEnum `json:"direction,omitempty"`
	Enabled   *bool                     `json:"enabled,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions,omitempty"`
	Name       *string                          `json:"name,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceUpdateInput `json:"source,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type WanFirewallUpdateRuleInput struct {
	ID   string                          `json:"id"`
	Rule *WanFirewallUpdateRuleDataInput `json:"rule"`
}

type Xdr struct {
	// Define the paging, sort, and filter arguments to define the XDR stories that are returned in the query
	Stories *StoriesData `json:"stories,omitempty"`
	// Define either the story ID, or the incident ID and producer arguments, to query the specific XDR story
	Story *Story `json:"story,omitempty"`
}

// XDR Pro (extended detection and response) service license details
type XdrProLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The number of knowledge users that the XDR Pro service refers to
	Total int64 `json:"total"`
}

func (XdrProLicense) IsLicense()                   {}
func (this XdrProLicense) GetDescription() *string { return this.Description }

// License plan type
func (this XdrProLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this XdrProLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this XdrProLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this XdrProLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this XdrProLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this XdrProLicense) GetLastUpdated() *string { return this.LastUpdated }

func (XdrProLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this XdrProLicense) GetTotal() int64 { return this.Total }

// ZTNA remote users license
type ZtnaUsersLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The maximum amount of ZTNA users for the region.
	Total int64 `json:"total"`
	// Specify a license group that you are limiting the number of ZTNA users
	ZtnaUsersLicenseGroup ZtnaUsersLicenseGroup `json:"ztnaUsersLicenseGroup"`
}

func (ZtnaUsersLicense) IsLicense()                   {}
func (this ZtnaUsersLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ZtnaUsersLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ZtnaUsersLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ZtnaUsersLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ZtnaUsersLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ZtnaUsersLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ZtnaUsersLicense) GetLastUpdated() *string { return this.LastUpdated }

func (ZtnaUsersLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this ZtnaUsersLicense) GetTotal() int64 { return this.Total }

// Global ZTNA license usage and allocation across all accounts
type ZtnaUsersLicenseAllocations struct {
	// Total users allocated a ZTNA license
	Allocated int64 `json:"allocated"`
	// Available users not yet allocated a license
	Available int64 `json:"available"`
	// Total ZTNA licenses for users
	Total int64 `json:"total"`
}

type AccountType string

const (
	AccountTypeAll      AccountType = "ALL"
	AccountTypeRegular  AccountType = "REGULAR"
	AccountTypeReseller AccountType = "RESELLER"
	AccountTypeSystem   AccountType = "SYSTEM"
)

var AllAccountType = []AccountType{
	AccountTypeAll,
	AccountTypeRegular,
	AccountTypeReseller,
	AccountTypeSystem,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeAll, AccountTypeRegular, AccountTypeReseller, AccountTypeSystem:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggregationType string

const (
	AggregationTypeAny           AggregationType = "any"
	AggregationTypeAvg           AggregationType = "avg"
	AggregationTypeChanges       AggregationType = "changes"
	AggregationTypeCount         AggregationType = "count"
	AggregationTypeCountDistinct AggregationType = "count_distinct"
	AggregationTypeDistinct      AggregationType = "distinct"
	AggregationTypeMax           AggregationType = "max"
	AggregationTypeMin           AggregationType = "min"
	AggregationTypeSum           AggregationType = "sum"
	AggregationTypeUniqSet       AggregationType = "uniq_set"
)

var AllAggregationType = []AggregationType{
	AggregationTypeAny,
	AggregationTypeAvg,
	AggregationTypeChanges,
	AggregationTypeCount,
	AggregationTypeCountDistinct,
	AggregationTypeDistinct,
	AggregationTypeMax,
	AggregationTypeMin,
	AggregationTypeSum,
	AggregationTypeUniqSet,
}

func (e AggregationType) IsValid() bool {
	switch e {
	case AggregationTypeAny, AggregationTypeAvg, AggregationTypeChanges, AggregationTypeCount, AggregationTypeCountDistinct, AggregationTypeDistinct, AggregationTypeMax, AggregationTypeMin, AggregationTypeSum, AggregationTypeUniqSet:
		return true
	}
	return false
}

func (e AggregationType) String() string {
	return string(e)
}

func (e *AggregationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationType", str)
	}
	return nil
}

func (e AggregationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertClassificationEnum string

const (
	AlertClassificationEnumFalsePositive                 AlertClassificationEnum = "FALSE_POSITIVE"
	AlertClassificationEnumInformationalExpectedActivity AlertClassificationEnum = "INFORMATIONAL_EXPECTED_ACTIVITY"
	AlertClassificationEnumTruePositive                  AlertClassificationEnum = "TRUE_POSITIVE"
)

var AllAlertClassificationEnum = []AlertClassificationEnum{
	AlertClassificationEnumFalsePositive,
	AlertClassificationEnumInformationalExpectedActivity,
	AlertClassificationEnumTruePositive,
}

func (e AlertClassificationEnum) IsValid() bool {
	switch e {
	case AlertClassificationEnumFalsePositive, AlertClassificationEnumInformationalExpectedActivity, AlertClassificationEnumTruePositive:
		return true
	}
	return false
}

func (e AlertClassificationEnum) String() string {
	return string(e)
}

func (e *AlertClassificationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertClassificationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertClassificationEnum", str)
	}
	return nil
}

func (e AlertClassificationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertDeterminationEnum string

const (
	AlertDeterminationEnumApt                       AlertDeterminationEnum = "APT"
	AlertDeterminationEnumCompromisedAccount        AlertDeterminationEnum = "COMPROMISED_ACCOUNT"
	AlertDeterminationEnumConfirmedActivity         AlertDeterminationEnum = "CONFIRMED_ACTIVITY"
	AlertDeterminationEnumLineOfBusinessApplication AlertDeterminationEnum = "LINE_OF_BUSINESS_APPLICATION"
	AlertDeterminationEnumMaliciousUserActivity     AlertDeterminationEnum = "MALICIOUS_USER_ACTIVITY"
	AlertDeterminationEnumMalware                   AlertDeterminationEnum = "MALWARE"
	AlertDeterminationEnumMultiStagedAttack         AlertDeterminationEnum = "MULTI_STAGED_ATTACK"
	AlertDeterminationEnumNotEnoughDataToValidate   AlertDeterminationEnum = "NOT_ENOUGH_DATA_TO_VALIDATE"
	AlertDeterminationEnumNotMalicious              AlertDeterminationEnum = "NOT_MALICIOUS"
	AlertDeterminationEnumOther                     AlertDeterminationEnum = "OTHER"
	AlertDeterminationEnumPhishing                  AlertDeterminationEnum = "PHISHING"
	AlertDeterminationEnumSecurityPersonnel         AlertDeterminationEnum = "SECURITY_PERSONNEL"
	AlertDeterminationEnumSecurityTesting           AlertDeterminationEnum = "SECURITY_TESTING"
	AlertDeterminationEnumUnwantedSoftware          AlertDeterminationEnum = "UNWANTED_SOFTWARE"
)

var AllAlertDeterminationEnum = []AlertDeterminationEnum{
	AlertDeterminationEnumApt,
	AlertDeterminationEnumCompromisedAccount,
	AlertDeterminationEnumConfirmedActivity,
	AlertDeterminationEnumLineOfBusinessApplication,
	AlertDeterminationEnumMaliciousUserActivity,
	AlertDeterminationEnumMalware,
	AlertDeterminationEnumMultiStagedAttack,
	AlertDeterminationEnumNotEnoughDataToValidate,
	AlertDeterminationEnumNotMalicious,
	AlertDeterminationEnumOther,
	AlertDeterminationEnumPhishing,
	AlertDeterminationEnumSecurityPersonnel,
	AlertDeterminationEnumSecurityTesting,
	AlertDeterminationEnumUnwantedSoftware,
}

func (e AlertDeterminationEnum) IsValid() bool {
	switch e {
	case AlertDeterminationEnumApt, AlertDeterminationEnumCompromisedAccount, AlertDeterminationEnumConfirmedActivity, AlertDeterminationEnumLineOfBusinessApplication, AlertDeterminationEnumMaliciousUserActivity, AlertDeterminationEnumMalware, AlertDeterminationEnumMultiStagedAttack, AlertDeterminationEnumNotEnoughDataToValidate, AlertDeterminationEnumNotMalicious, AlertDeterminationEnumOther, AlertDeterminationEnumPhishing, AlertDeterminationEnumSecurityPersonnel, AlertDeterminationEnumSecurityTesting, AlertDeterminationEnumUnwantedSoftware:
		return true
	}
	return false
}

func (e AlertDeterminationEnum) String() string {
	return string(e)
}

func (e *AlertDeterminationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertDeterminationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertDeterminationEnum", str)
	}
	return nil
}

func (e AlertDeterminationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AnnotationType string

const (
	// Other events that are included in annotations
	AnnotationTypeGeneric AnnotationType = "generic"
	// The site connects to a different PoP
	AnnotationTypePopChange AnnotationType = "popChange"
	// The ISP IP address (remote IP) changed
	AnnotationTypeRemoteIPChange AnnotationType = "remoteIPChange"
	// Change for HA status role
	AnnotationTypeRoleChange AnnotationType = "roleChange"
)

var AllAnnotationType = []AnnotationType{
	AnnotationTypeGeneric,
	AnnotationTypePopChange,
	AnnotationTypeRemoteIPChange,
	AnnotationTypeRoleChange,
}

func (e AnnotationType) IsValid() bool {
	switch e {
	case AnnotationTypeGeneric, AnnotationTypePopChange, AnnotationTypeRemoteIPChange, AnnotationTypeRoleChange:
		return true
	}
	return false
}

func (e AnnotationType) String() string {
	return string(e)
}

func (e *AnnotationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnotationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnnotationType", str)
	}
	return nil
}

func (e AnnotationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApnMethod string

const (
	ApnMethodMethodAuto    ApnMethod = "METHOD_AUTO"
	ApnMethodMethodManual  ApnMethod = "METHOD_MANUAL"
	ApnMethodMethodUnknown ApnMethod = "METHOD_UNKNOWN"
)

var AllApnMethod = []ApnMethod{
	ApnMethodMethodAuto,
	ApnMethodMethodManual,
	ApnMethodMethodUnknown,
}

func (e ApnMethod) IsValid() bool {
	switch e {
	case ApnMethodMethodAuto, ApnMethodMethodManual, ApnMethodMethodUnknown:
		return true
	}
	return false
}

func (e ApnMethod) String() string {
	return string(e)
}

func (e *ApnMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApnMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApnMethod", str)
	}
	return nil
}

func (e ApnMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AppStatsFieldName string

const (
	// Active Directory name
	AppStatsFieldNameAdName AppStatsFieldName = "ad_name"
	// The application identifier
	AppStatsFieldNameApp AppStatsFieldName = "app"
	// The application name
	AppStatsFieldNameApplication AppStatsFieldName = "application"
	// Cato system category of the application
	AppStatsFieldNameCategory AppStatsFieldName = "category"
	// Application description
	AppStatsFieldNameDescription AppStatsFieldName = "description"
	// IP for destination host or Cato Client
	AppStatsFieldNameDestIP AppStatsFieldName = "dest_ip"
	// Destination is site or remote user
	AppStatsFieldNameDestIsSiteOrVpn AppStatsFieldName = "dest_is_site_or_vpn"
	// Destination site or remote user identifier
	AppStatsFieldNameDestSite AppStatsFieldName = "dest_site"
	// Destination Site or remote user identifier
	AppStatsFieldNameDestSiteID AppStatsFieldName = "dest_site_id"
	// Destination Site or remote user name
	AppStatsFieldNameDestSiteName AppStatsFieldName = "dest_site_name"
	// Name for device related to the traffic
	AppStatsFieldNameDeviceName    AppStatsFieldName = "device_name"
	AppStatsFieldNameDiscoveredApp AppStatsFieldName = "discovered_app"
	AppStatsFieldNameDomain        AppStatsFieldName = "domain"
	// data downloaded from cloud applications
	AppStatsFieldNameDownstream   AppStatsFieldName = "downstream"
	AppStatsFieldNameFlowsCreated AppStatsFieldName = "flows_created"
	// the country in which the registered application headquarteres is located
	AppStatsFieldNameHqLocation AppStatsFieldName = "hq_location"
	AppStatsFieldNameIP         AppStatsFieldName = "ip"
	// indicates whether the application is considered cloud app/SaaS app
	AppStatsFieldNameIsCloudApp AppStatsFieldName = "is_cloud_app"
	// new cloud application identifier
	AppStatsFieldNameNewApp    AppStatsFieldName = "new_app"
	AppStatsFieldNameRiskLevel AppStatsFieldName = "risk_level"
	// the application risk score assigned by Cato
	AppStatsFieldNameRiskScore AppStatsFieldName = "risk_score"
	// Is the application defined as sanctioned?
	AppStatsFieldNameSanctioned AppStatsFieldName = "sanctioned"
	// Country in which the source host is located
	AppStatsFieldNameSiteCountry AppStatsFieldName = "site_country"
	// State in which the source host is located
	AppStatsFieldNameSiteState AppStatsFieldName = "site_state"
	// Name for Socket interface
	AppStatsFieldNameSocketInterface AppStatsFieldName = "socket_interface"
	// IP for source host or Cato Client
	AppStatsFieldNameSrcIP AppStatsFieldName = "src_ip"
	// Source is site or remote user
	AppStatsFieldNameSrcIsSiteOrVpn AppStatsFieldName = "src_is_site_or_vpn"
	// Source site or remote user identifier
	AppStatsFieldNameSrcSiteID AppStatsFieldName = "src_site_id"
	// Source site or remote user name
	AppStatsFieldNameSrcSiteName AppStatsFieldName = "src_site_name"
	// Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnet AppStatsFieldName = "subnet"
	// the total sum of upstream and downstream data in bytes
	AppStatsFieldNameTraffic AppStatsFieldName = "traffic"
	// Traffic direction
	AppStatsFieldNameTrafficDirection AppStatsFieldName = "traffic_direction"
	// data uploaded to cloud applications
	AppStatsFieldNameUpstream AppStatsFieldName = "upstream"
	// User identifier
	AppStatsFieldNameUserID AppStatsFieldName = "user_id"
	// User name
	AppStatsFieldNameUserName  AppStatsFieldName = "user_name"
	AppStatsFieldNameVpnUserID AppStatsFieldName = "vpn_user_id"
)

var AllAppStatsFieldName = []AppStatsFieldName{
	AppStatsFieldNameAdName,
	AppStatsFieldNameApp,
	AppStatsFieldNameApplication,
	AppStatsFieldNameCategory,
	AppStatsFieldNameDescription,
	AppStatsFieldNameDestIP,
	AppStatsFieldNameDestIsSiteOrVpn,
	AppStatsFieldNameDestSite,
	AppStatsFieldNameDestSiteID,
	AppStatsFieldNameDestSiteName,
	AppStatsFieldNameDeviceName,
	AppStatsFieldNameDiscoveredApp,
	AppStatsFieldNameDomain,
	AppStatsFieldNameDownstream,
	AppStatsFieldNameFlowsCreated,
	AppStatsFieldNameHqLocation,
	AppStatsFieldNameIP,
	AppStatsFieldNameIsCloudApp,
	AppStatsFieldNameNewApp,
	AppStatsFieldNameRiskLevel,
	AppStatsFieldNameRiskScore,
	AppStatsFieldNameSanctioned,
	AppStatsFieldNameSiteCountry,
	AppStatsFieldNameSiteState,
	AppStatsFieldNameSocketInterface,
	AppStatsFieldNameSrcIP,
	AppStatsFieldNameSrcIsSiteOrVpn,
	AppStatsFieldNameSrcSiteID,
	AppStatsFieldNameSrcSiteName,
	AppStatsFieldNameSubnet,
	AppStatsFieldNameTraffic,
	AppStatsFieldNameTrafficDirection,
	AppStatsFieldNameUpstream,
	AppStatsFieldNameUserID,
	AppStatsFieldNameUserName,
	AppStatsFieldNameVpnUserID,
}

func (e AppStatsFieldName) IsValid() bool {
	switch e {
	case AppStatsFieldNameAdName, AppStatsFieldNameApp, AppStatsFieldNameApplication, AppStatsFieldNameCategory, AppStatsFieldNameDescription, AppStatsFieldNameDestIP, AppStatsFieldNameDestIsSiteOrVpn, AppStatsFieldNameDestSite, AppStatsFieldNameDestSiteID, AppStatsFieldNameDestSiteName, AppStatsFieldNameDeviceName, AppStatsFieldNameDiscoveredApp, AppStatsFieldNameDomain, AppStatsFieldNameDownstream, AppStatsFieldNameFlowsCreated, AppStatsFieldNameHqLocation, AppStatsFieldNameIP, AppStatsFieldNameIsCloudApp, AppStatsFieldNameNewApp, AppStatsFieldNameRiskLevel, AppStatsFieldNameRiskScore, AppStatsFieldNameSanctioned, AppStatsFieldNameSiteCountry, AppStatsFieldNameSiteState, AppStatsFieldNameSocketInterface, AppStatsFieldNameSrcIP, AppStatsFieldNameSrcIsSiteOrVpn, AppStatsFieldNameSrcSiteID, AppStatsFieldNameSrcSiteName, AppStatsFieldNameSubnet, AppStatsFieldNameTraffic, AppStatsFieldNameTrafficDirection, AppStatsFieldNameUpstream, AppStatsFieldNameUserID, AppStatsFieldNameUserName, AppStatsFieldNameVpnUserID:
		return true
	}
	return false
}

func (e AppStatsFieldName) String() string {
	return string(e)
}

func (e *AppStatsFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStatsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStatsFieldName", str)
	}
	return nil
}

func (e AppStatsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditFieldName string

const (
	// The name of the account on which the record was created
	AuditFieldNameAccount AuditFieldName = "account"
	// The id of the account on which the record was created
	AuditFieldNameAccountID AuditFieldName = "account_id"
	// The admin whose action generated the record
	AuditFieldNameAdmin AuditFieldName = "admin"
	// The ID of the admin whose action generated the record
	AuditFieldNameAdminID AuditFieldName = "admin_id"
	// The api key whose action generated the record
	AuditFieldNameAPIKey            AuditFieldName = "apiKey"
	AuditFieldNameAuditCreationType AuditFieldName = "audit_creation_type"
	// the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`
	AuditFieldNameChangeType AuditFieldName = "change_type"
	// Time the record was created
	AuditFieldNameCreationDate AuditFieldName = "creation_date"
	// Time the record was committed to storage
	AuditFieldNameInsertionDate AuditFieldName = "insertion_date"
	// The name of the object that was affected, e.g. 'My Site'
	AuditFieldNameModelName AuditFieldName = "model_name"
	// The type of object that was affected. e.g. Site, Socket, SocketInterface
	AuditFieldNameModelType AuditFieldName = "model_type"
	// Less granular than model_name, a general marker of the modified area: administration, configuration, security
	AuditFieldNameModule AuditFieldName = "module"
)

var AllAuditFieldName = []AuditFieldName{
	AuditFieldNameAccount,
	AuditFieldNameAccountID,
	AuditFieldNameAdmin,
	AuditFieldNameAdminID,
	AuditFieldNameAPIKey,
	AuditFieldNameAuditCreationType,
	AuditFieldNameChangeType,
	AuditFieldNameCreationDate,
	AuditFieldNameInsertionDate,
	AuditFieldNameModelName,
	AuditFieldNameModelType,
	AuditFieldNameModule,
}

func (e AuditFieldName) IsValid() bool {
	switch e {
	case AuditFieldNameAccount, AuditFieldNameAccountID, AuditFieldNameAdmin, AuditFieldNameAdminID, AuditFieldNameAPIKey, AuditFieldNameAuditCreationType, AuditFieldNameChangeType, AuditFieldNameCreationDate, AuditFieldNameInsertionDate, AuditFieldNameModelName, AuditFieldNameModelType, AuditFieldNameModule:
		return true
	}
	return false
}

func (e AuditFieldName) String() string {
	return string(e)
}

func (e *AuditFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditFieldName", str)
	}
	return nil
}

func (e AuditFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatoEndpointEngineType string

const (
	CatoEndpointEngineTypeAntiMalware CatoEndpointEngineType = "AntiMalware"
	CatoEndpointEngineTypeBehavioral  CatoEndpointEngineType = "Behavioral"
)

var AllCatoEndpointEngineType = []CatoEndpointEngineType{
	CatoEndpointEngineTypeAntiMalware,
	CatoEndpointEngineTypeBehavioral,
}

func (e CatoEndpointEngineType) IsValid() bool {
	switch e {
	case CatoEndpointEngineTypeAntiMalware, CatoEndpointEngineTypeBehavioral:
		return true
	}
	return false
}

func (e CatoEndpointEngineType) String() string {
	return string(e)
}

func (e *CatoEndpointEngineType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatoEndpointEngineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatoEndpointEngineType", str)
	}
	return nil
}

func (e CatoEndpointEngineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularDisconnectionReason string

const (
	CellularDisconnectionReasonReasonNone    CellularDisconnectionReason = "REASON_NONE"
	CellularDisconnectionReasonReasonTimeout CellularDisconnectionReason = "REASON_TIMEOUT"
)

var AllCellularDisconnectionReason = []CellularDisconnectionReason{
	CellularDisconnectionReasonReasonNone,
	CellularDisconnectionReasonReasonTimeout,
}

func (e CellularDisconnectionReason) IsValid() bool {
	switch e {
	case CellularDisconnectionReasonReasonNone, CellularDisconnectionReasonReasonTimeout:
		return true
	}
	return false
}

func (e CellularDisconnectionReason) String() string {
	return string(e)
}

func (e *CellularDisconnectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularDisconnectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularDisconnectionReason", str)
	}
	return nil
}

func (e CellularDisconnectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularModemStatus string

const (
	CellularModemStatusStatusError   CellularModemStatus = "STATUS_ERROR"
	CellularModemStatusStatusOk      CellularModemStatus = "STATUS_OK"
	CellularModemStatusStatusUnknown CellularModemStatus = "STATUS_UNKNOWN"
)

var AllCellularModemStatus = []CellularModemStatus{
	CellularModemStatusStatusError,
	CellularModemStatusStatusOk,
	CellularModemStatusStatusUnknown,
}

func (e CellularModemStatus) IsValid() bool {
	switch e {
	case CellularModemStatusStatusError, CellularModemStatusStatusOk, CellularModemStatusStatusUnknown:
		return true
	}
	return false
}

func (e CellularModemStatus) String() string {
	return string(e)
}

func (e *CellularModemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularModemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularModemStatus", str)
	}
	return nil
}

func (e CellularModemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularNetworkType string

const (
	CellularNetworkTypeType2g      CellularNetworkType = "TYPE_2G"
	CellularNetworkTypeType3g      CellularNetworkType = "TYPE_3G"
	CellularNetworkTypeType4g      CellularNetworkType = "TYPE_4G"
	CellularNetworkTypeTypeUnknown CellularNetworkType = "TYPE_UNKNOWN"
)

var AllCellularNetworkType = []CellularNetworkType{
	CellularNetworkTypeType2g,
	CellularNetworkTypeType3g,
	CellularNetworkTypeType4g,
	CellularNetworkTypeTypeUnknown,
}

func (e CellularNetworkType) IsValid() bool {
	switch e {
	case CellularNetworkTypeType2g, CellularNetworkTypeType3g, CellularNetworkTypeType4g, CellularNetworkTypeTypeUnknown:
		return true
	}
	return false
}

func (e CellularNetworkType) String() string {
	return string(e)
}

func (e *CellularNetworkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularNetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularNetworkType", str)
	}
	return nil
}

func (e CellularNetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionMode string

const (
	ConnectionModeBidirectional ConnectionMode = "BIDIRECTIONAL"
	ConnectionModeResponderOnly ConnectionMode = "RESPONDER_ONLY"
)

var AllConnectionMode = []ConnectionMode{
	ConnectionModeBidirectional,
	ConnectionModeResponderOnly,
}

func (e ConnectionMode) IsValid() bool {
	switch e {
	case ConnectionModeBidirectional, ConnectionModeResponderOnly:
		return true
	}
	return false
}

func (e ConnectionMode) String() string {
	return string(e)
}

func (e *ConnectionMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionMode", str)
	}
	return nil
}

func (e ConnectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionOriginEnum string

const (
	ConnectionOriginEnumAny    ConnectionOriginEnum = "ANY"
	ConnectionOriginEnumRemote ConnectionOriginEnum = "REMOTE"
	ConnectionOriginEnumSite   ConnectionOriginEnum = "SITE"
)

var AllConnectionOriginEnum = []ConnectionOriginEnum{
	ConnectionOriginEnumAny,
	ConnectionOriginEnumRemote,
	ConnectionOriginEnumSite,
}

func (e ConnectionOriginEnum) IsValid() bool {
	switch e {
	case ConnectionOriginEnumAny, ConnectionOriginEnumRemote, ConnectionOriginEnumSite:
		return true
	}
	return false
}

func (e ConnectionOriginEnum) String() string {
	return string(e)
}

func (e *ConnectionOriginEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionOriginEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionOriginEnum", str)
	}
	return nil
}

func (e ConnectionOriginEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionTypeEnum string

const (
	ConnectionTypeEnumHost ConnectionTypeEnum = "Host"
	ConnectionTypeEnumSite ConnectionTypeEnum = "Site"
	ConnectionTypeEnumUser ConnectionTypeEnum = "User"
)

var AllConnectionTypeEnum = []ConnectionTypeEnum{
	ConnectionTypeEnumHost,
	ConnectionTypeEnumSite,
	ConnectionTypeEnumUser,
}

func (e ConnectionTypeEnum) IsValid() bool {
	switch e {
	case ConnectionTypeEnumHost, ConnectionTypeEnumSite, ConnectionTypeEnumUser:
		return true
	}
	return false
}

func (e ConnectionTypeEnum) String() string {
	return string(e)
}

func (e *ConnectionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionTypeEnum", str)
	}
	return nil
}

func (e ConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectivityStatus string

const (
	// Connected to the Cato Cloud
	ConnectivityStatusConnected ConnectivityStatus = "connected"
	// Disconnected from the Cato Cloud
	ConnectivityStatusDisconnected ConnectivityStatus = "disconnected"
)

var AllConnectivityStatus = []ConnectivityStatus{
	ConnectivityStatusConnected,
	ConnectivityStatusDisconnected,
}

func (e ConnectivityStatus) IsValid() bool {
	switch e {
	case ConnectivityStatusConnected, ConnectivityStatusDisconnected:
		return true
	}
	return false
}

func (e ConnectivityStatus) String() string {
	return string(e)
}

func (e *ConnectivityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectivityStatus", str)
	}
	return nil
}

func (e ConnectivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContainerType string

const (
	ContainerTypeFqdn    ContainerType = "FQDN"
	ContainerTypeIPRange ContainerType = "IP_RANGE"
)

var AllContainerType = []ContainerType{
	ContainerTypeFqdn,
	ContainerTypeIPRange,
}

func (e ContainerType) IsValid() bool {
	switch e {
	case ContainerTypeFqdn, ContainerTypeIPRange:
		return true
	}
	return false
}

func (e ContainerType) String() string {
	return string(e)
}

func (e *ContainerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContainerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContainerType", str)
	}
	return nil
}

func (e ContainerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DayOfWeek string

const (
	DayOfWeekFriday    DayOfWeek = "FRIDAY"
	DayOfWeekMonday    DayOfWeek = "MONDAY"
	DayOfWeekSaturday  DayOfWeek = "SATURDAY"
	DayOfWeekSunday    DayOfWeek = "SUNDAY"
	DayOfWeekThursday  DayOfWeek = "THURSDAY"
	DayOfWeekTuesday   DayOfWeek = "TUESDAY"
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"
)

var AllDayOfWeek = []DayOfWeek{
	DayOfWeekFriday,
	DayOfWeekMonday,
	DayOfWeekSaturday,
	DayOfWeekSunday,
	DayOfWeekThursday,
	DayOfWeekTuesday,
	DayOfWeekWednesday,
}

func (e DayOfWeek) IsValid() bool {
	switch e {
	case DayOfWeekFriday, DayOfWeekMonday, DayOfWeekSaturday, DayOfWeekSunday, DayOfWeekThursday, DayOfWeekTuesday, DayOfWeekWednesday:
		return true
	}
	return false
}

func (e DayOfWeek) String() string {
	return string(e)
}

func (e *DayOfWeek) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DayOfWeek(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DayOfWeek", str)
	}
	return nil
}

func (e DayOfWeek) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DestinationType string

const (
	DestinationTypeFqdn DestinationType = "FQDN"
	DestinationTypeIPv4 DestinationType = "IPv4"
)

var AllDestinationType = []DestinationType{
	DestinationTypeFqdn,
	DestinationTypeIPv4,
}

func (e DestinationType) IsValid() bool {
	switch e {
	case DestinationTypeFqdn, DestinationTypeIPv4:
		return true
	}
	return false
}

func (e DestinationType) String() string {
	return string(e)
}

func (e *DestinationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DestinationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DestinationType", str)
	}
	return nil
}

func (e DestinationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionSourceEnum string

const (
	DetectionSourceEnumAntivirus                     DetectionSourceEnum = "ANTIVIRUS"
	DetectionSourceEnumAppGovernanceDetection        DetectionSourceEnum = "APP_GOVERNANCE_DETECTION"
	DetectionSourceEnumAppGovernancePolicy           DetectionSourceEnum = "APP_GOVERNANCE_POLICY"
	DetectionSourceEnumAutomatedInvestigation        DetectionSourceEnum = "AUTOMATED_INVESTIGATION"
	DetectionSourceEnumAzureAdIDEntityProtection     DetectionSourceEnum = "AZURE_AD_IDENTITY_PROTECTION"
	DetectionSourceEnumCloudAppSecurity              DetectionSourceEnum = "CLOUD_APP_SECURITY"
	DetectionSourceEnumCustomDetection               DetectionSourceEnum = "CUSTOM_DETECTION"
	DetectionSourceEnumCustomTi                      DetectionSourceEnum = "CUSTOM_TI"
	DetectionSourceEnumManual                        DetectionSourceEnum = "MANUAL"
	DetectionSourceEnumMicrosoftDataLossPrevention   DetectionSourceEnum = "MICROSOFT_DATA_LOSS_PREVENTION"
	DetectionSourceEnumMicrosoftDefenderForEndpoint  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_ENDPOINT"
	DetectionSourceEnumMicrosoftDefenderForIDEntity  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_IDENTITY"
	DetectionSourceEnumMicrosoftDefenderForOffice365 DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_OFFICE365"
	DetectionSourceEnumMicrosoftThreatExperts        DetectionSourceEnum = "MICROSOFT_THREAT_EXPERTS"
	DetectionSourceEnumMicrosoft365Defender          DetectionSourceEnum = "MICROSOFT365_DEFENDER"
	DetectionSourceEnumSmartScreen                   DetectionSourceEnum = "SMART_SCREEN"
)

var AllDetectionSourceEnum = []DetectionSourceEnum{
	DetectionSourceEnumAntivirus,
	DetectionSourceEnumAppGovernanceDetection,
	DetectionSourceEnumAppGovernancePolicy,
	DetectionSourceEnumAutomatedInvestigation,
	DetectionSourceEnumAzureAdIDEntityProtection,
	DetectionSourceEnumCloudAppSecurity,
	DetectionSourceEnumCustomDetection,
	DetectionSourceEnumCustomTi,
	DetectionSourceEnumManual,
	DetectionSourceEnumMicrosoftDataLossPrevention,
	DetectionSourceEnumMicrosoftDefenderForEndpoint,
	DetectionSourceEnumMicrosoftDefenderForIDEntity,
	DetectionSourceEnumMicrosoftDefenderForOffice365,
	DetectionSourceEnumMicrosoftThreatExperts,
	DetectionSourceEnumMicrosoft365Defender,
	DetectionSourceEnumSmartScreen,
}

func (e DetectionSourceEnum) IsValid() bool {
	switch e {
	case DetectionSourceEnumAntivirus, DetectionSourceEnumAppGovernanceDetection, DetectionSourceEnumAppGovernancePolicy, DetectionSourceEnumAutomatedInvestigation, DetectionSourceEnumAzureAdIDEntityProtection, DetectionSourceEnumCloudAppSecurity, DetectionSourceEnumCustomDetection, DetectionSourceEnumCustomTi, DetectionSourceEnumManual, DetectionSourceEnumMicrosoftDataLossPrevention, DetectionSourceEnumMicrosoftDefenderForEndpoint, DetectionSourceEnumMicrosoftDefenderForIDEntity, DetectionSourceEnumMicrosoftDefenderForOffice365, DetectionSourceEnumMicrosoftThreatExperts, DetectionSourceEnumMicrosoft365Defender, DetectionSourceEnumSmartScreen:
		return true
	}
	return false
}

func (e DetectionSourceEnum) String() string {
	return string(e)
}

func (e *DetectionSourceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionSourceEnum", str)
	}
	return nil
}

func (e DetectionSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionStatusEnum string

const (
	DetectionStatusEnumBlocked   DetectionStatusEnum = "BLOCKED"
	DetectionStatusEnumDetected  DetectionStatusEnum = "DETECTED"
	DetectionStatusEnumPrevented DetectionStatusEnum = "PREVENTED"
)

var AllDetectionStatusEnum = []DetectionStatusEnum{
	DetectionStatusEnumBlocked,
	DetectionStatusEnumDetected,
	DetectionStatusEnumPrevented,
}

func (e DetectionStatusEnum) IsValid() bool {
	switch e {
	case DetectionStatusEnumBlocked, DetectionStatusEnumDetected, DetectionStatusEnumPrevented:
		return true
	}
	return false
}

func (e DetectionStatusEnum) String() string {
	return string(e)
}

func (e *DetectionStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionStatusEnum", str)
	}
	return nil
}

func (e DetectionStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceAvStatusEnum string

const (
	DeviceAvStatusEnumDisabled     DeviceAvStatusEnum = "DISABLED"
	DeviceAvStatusEnumNotReporting DeviceAvStatusEnum = "NOT_REPORTING"
	DeviceAvStatusEnumNotUpdated   DeviceAvStatusEnum = "NOT_UPDATED"
	DeviceAvStatusEnumUpdated      DeviceAvStatusEnum = "UPDATED"
)

var AllDeviceAvStatusEnum = []DeviceAvStatusEnum{
	DeviceAvStatusEnumDisabled,
	DeviceAvStatusEnumNotReporting,
	DeviceAvStatusEnumNotUpdated,
	DeviceAvStatusEnumUpdated,
}

func (e DeviceAvStatusEnum) IsValid() bool {
	switch e {
	case DeviceAvStatusEnumDisabled, DeviceAvStatusEnumNotReporting, DeviceAvStatusEnumNotUpdated, DeviceAvStatusEnumUpdated:
		return true
	}
	return false
}

func (e DeviceAvStatusEnum) String() string {
	return string(e)
}

func (e *DeviceAvStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceAvStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceAvStatusEnum", str)
	}
	return nil
}

func (e DeviceAvStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceConfigHaRoleEnum string

const (
	DeviceConfigHaRoleEnumPrimary   DeviceConfigHaRoleEnum = "PRIMARY"
	DeviceConfigHaRoleEnumSecondary DeviceConfigHaRoleEnum = "SECONDARY"
)

var AllDeviceConfigHaRoleEnum = []DeviceConfigHaRoleEnum{
	DeviceConfigHaRoleEnumPrimary,
	DeviceConfigHaRoleEnumSecondary,
}

func (e DeviceConfigHaRoleEnum) IsValid() bool {
	switch e {
	case DeviceConfigHaRoleEnumPrimary, DeviceConfigHaRoleEnumSecondary:
		return true
	}
	return false
}

func (e DeviceConfigHaRoleEnum) String() string {
	return string(e)
}

func (e *DeviceConfigHaRoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfigHaRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfigHaRoleEnum", str)
	}
	return nil
}

func (e DeviceConfigHaRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHaRoleStateEnum string

const (
	DeviceHaRoleStateEnumBackup DeviceHaRoleStateEnum = "BACKUP"
	DeviceHaRoleStateEnumMaster DeviceHaRoleStateEnum = "MASTER"
)

var AllDeviceHaRoleStateEnum = []DeviceHaRoleStateEnum{
	DeviceHaRoleStateEnumBackup,
	DeviceHaRoleStateEnumMaster,
}

func (e DeviceHaRoleStateEnum) IsValid() bool {
	switch e {
	case DeviceHaRoleStateEnumBackup, DeviceHaRoleStateEnumMaster:
		return true
	}
	return false
}

func (e DeviceHaRoleStateEnum) String() string {
	return string(e)
}

func (e *DeviceHaRoleStateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHaRoleStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHaRoleStateEnum", str)
	}
	return nil
}

func (e DeviceHaRoleStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHealthStatusEnum string

const (
	DeviceHealthStatusEnumActive                            DeviceHealthStatusEnum = "ACTIVE"
	DeviceHealthStatusEnumImpairedCommunication             DeviceHealthStatusEnum = "IMPAIRED_COMMUNICATION"
	DeviceHealthStatusEnumInactive                          DeviceHealthStatusEnum = "INACTIVE"
	DeviceHealthStatusEnumNoSensorData                      DeviceHealthStatusEnum = "NO_SENSOR_DATA"
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication DeviceHealthStatusEnum = "NO_SENSOR_DATA_IMPAIRED_COMMUNICATION"
)

var AllDeviceHealthStatusEnum = []DeviceHealthStatusEnum{
	DeviceHealthStatusEnumActive,
	DeviceHealthStatusEnumImpairedCommunication,
	DeviceHealthStatusEnumInactive,
	DeviceHealthStatusEnumNoSensorData,
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication,
}

func (e DeviceHealthStatusEnum) IsValid() bool {
	switch e {
	case DeviceHealthStatusEnumActive, DeviceHealthStatusEnumImpairedCommunication, DeviceHealthStatusEnumInactive, DeviceHealthStatusEnumNoSensorData, DeviceHealthStatusEnumNoSensorDataImpairedCommunication:
		return true
	}
	return false
}

func (e DeviceHealthStatusEnum) String() string {
	return string(e)
}

func (e *DeviceHealthStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHealthStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHealthStatusEnum", str)
	}
	return nil
}

func (e DeviceHealthStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DhcpType string

const (
	DhcpTypeAccountDefault DhcpType = "ACCOUNT_DEFAULT"
	DhcpTypeDhcpDisabled   DhcpType = "DHCP_DISABLED"
	DhcpTypeDhcpRange      DhcpType = "DHCP_RANGE"
	DhcpTypeDhcpRelay      DhcpType = "DHCP_RELAY"
)

var AllDhcpType = []DhcpType{
	DhcpTypeAccountDefault,
	DhcpTypeDhcpDisabled,
	DhcpTypeDhcpRange,
	DhcpTypeDhcpRelay,
}

func (e DhcpType) IsValid() bool {
	switch e {
	case DhcpTypeAccountDefault, DhcpTypeDhcpDisabled, DhcpTypeDhcpRange, DhcpTypeDhcpRelay:
		return true
	}
	return false
}

func (e DhcpType) String() string {
	return string(e)
}

func (e *DhcpType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DhcpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DhcpType", str)
	}
	return nil
}

func (e DhcpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionEnum string

const (
	DirectionEnumAsc  DirectionEnum = "asc"
	DirectionEnumDesc DirectionEnum = "desc"
)

var AllDirectionEnum = []DirectionEnum{
	DirectionEnumAsc,
	DirectionEnumDesc,
}

func (e DirectionEnum) IsValid() bool {
	switch e {
	case DirectionEnumAsc, DirectionEnumDesc:
		return true
	}
	return false
}

func (e DirectionEnum) String() string {
	return string(e)
}

func (e *DirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionEnum", str)
	}
	return nil
}

func (e DirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionInput string

const (
	DirectionInputAsc  DirectionInput = "asc"
	DirectionInputDesc DirectionInput = "desc"
)

var AllDirectionInput = []DirectionInput{
	DirectionInputAsc,
	DirectionInputDesc,
}

func (e DirectionInput) IsValid() bool {
	switch e {
	case DirectionInputAsc, DirectionInputDesc:
		return true
	}
	return false
}

func (e DirectionInput) String() string {
	return string(e)
}

func (e *DirectionInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionInput", str)
	}
	return nil
}

func (e DirectionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The DPA agreement, based on your contract with Cato
type DpaVersion string

const (
	DpaVersionDpa2019_01 DpaVersion = "DPA_2019_01"
	DpaVersionDpa2021_01 DpaVersion = "DPA_2021_01"
	DpaVersionDpa2023_01 DpaVersion = "DPA_2023_01"
)

var AllDpaVersion = []DpaVersion{
	DpaVersionDpa2019_01,
	DpaVersionDpa2021_01,
	DpaVersionDpa2023_01,
}

func (e DpaVersion) IsValid() bool {
	switch e {
	case DpaVersionDpa2019_01, DpaVersionDpa2021_01, DpaVersionDpa2023_01:
		return true
	}
	return false
}

func (e DpaVersion) String() string {
	return string(e)
}

func (e *DpaVersion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DpaVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DpaVersion", str)
	}
	return nil
}

func (e DpaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on ElasticSearch. Between operators are applicable only to numeric fields
// Note that not operators are slower
type ElasticOperator string

const (
	ElasticOperatorBetween    ElasticOperator = "between"
	ElasticOperatorExists     ElasticOperator = "exists"
	ElasticOperatorIn         ElasticOperator = "in"
	ElasticOperatorIs         ElasticOperator = "is"
	ElasticOperatorIsNot      ElasticOperator = "is_not"
	ElasticOperatorNotBetween ElasticOperator = "not_between"
	ElasticOperatorNotExists  ElasticOperator = "not_exists"
	ElasticOperatorNotIn      ElasticOperator = "not_in"
)

var AllElasticOperator = []ElasticOperator{
	ElasticOperatorBetween,
	ElasticOperatorExists,
	ElasticOperatorIn,
	ElasticOperatorIs,
	ElasticOperatorIsNot,
	ElasticOperatorNotBetween,
	ElasticOperatorNotExists,
	ElasticOperatorNotIn,
}

func (e ElasticOperator) IsValid() bool {
	switch e {
	case ElasticOperatorBetween, ElasticOperatorExists, ElasticOperatorIn, ElasticOperatorIs, ElasticOperatorIsNot, ElasticOperatorNotBetween, ElasticOperatorNotExists, ElasticOperatorNotIn:
		return true
	}
	return false
}

func (e ElasticOperator) String() string {
	return string(e)
}

func (e *ElasticOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElasticOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElasticOperator", str)
	}
	return nil
}

func (e ElasticOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityType string

const (
	// A reference to a configured Account under reseller
	EntityTypeAccount EntityType = "account"
	// An account administrator (user in Cato Console)
	EntityTypeAdmin EntityType = "admin"
	// An external IP address in a specific PoP reserved for the account
	EntityTypeAllocatedIP EntityType = "allocatedIP"
	// Any entity (matches everything)
	EntityTypeAny EntityType = "any"
	// Pooled licenses available for use
	EntityTypeAvailablePooledUsage EntityType = "availablePooledUsage"
	// Site licenses available for use
	EntityTypeAvailableSiteUsage EntityType = "availableSiteUsage"
	// A settlement with over 1K population
	EntityTypeCity EntityType = "city"
	// Geographical and political entity recognized internationally
	EntityTypeCountry EntityType = "country"
	// Represents a state or territory within a country. It is a sub-division of the country
	EntityTypeCountryState EntityType = "countryState"
	// A reference to DHCP Relay Group within account
	EntityTypeDhcpRelayGroup    EntityType = "dhcpRelayGroup"
	EntityTypeGroupSubscription EntityType = "groupSubscription"
	// A reference to the configured Host within Site
	EntityTypeHost EntityType = "host"
	// A reference to LAN Firewall Rule within Site
	EntityTypeLanFirewall EntityType = "lanFirewall"
	// A reference to Local Routing Rule within Site
	EntityTypeLocalRouting            EntityType = "localRouting"
	EntityTypeLocation                EntityType = "location"
	EntityTypeMailingListSubscription EntityType = "mailingListSubscription"
	// A reference to the configured Network Interface within Site
	EntityTypeNetworkInterface EntityType = "networkInterface"
	// Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number
	EntityTypePortProtocol EntityType = "portProtocol"
	// l4 services for LAN firewall rules
	EntityTypeSimpleService EntityType = "simpleService"
	// A reference to a configured Site within Account
	EntityTypeSite EntityType = "site"
	// union of the globalRange and a Subnet
	EntityTypeSiteRange EntityType = "siteRange"
	// Time zone, which is a geographical region where clocks are set to the same time
	EntityTypeTimezone EntityType = "timezone"
	// A reference to the configured VPN User within Account
	EntityTypeVpnUser             EntityType = "vpnUser"
	EntityTypeWebhookSubscription EntityType = "webhookSubscription"
)

var AllEntityType = []EntityType{
	EntityTypeAccount,
	EntityTypeAdmin,
	EntityTypeAllocatedIP,
	EntityTypeAny,
	EntityTypeAvailablePooledUsage,
	EntityTypeAvailableSiteUsage,
	EntityTypeCity,
	EntityTypeCountry,
	EntityTypeCountryState,
	EntityTypeDhcpRelayGroup,
	EntityTypeGroupSubscription,
	EntityTypeHost,
	EntityTypeLanFirewall,
	EntityTypeLocalRouting,
	EntityTypeLocation,
	EntityTypeMailingListSubscription,
	EntityTypeNetworkInterface,
	EntityTypePortProtocol,
	EntityTypeSimpleService,
	EntityTypeSite,
	EntityTypeSiteRange,
	EntityTypeTimezone,
	EntityTypeVpnUser,
	EntityTypeWebhookSubscription,
}

func (e EntityType) IsValid() bool {
	switch e {
	case EntityTypeAccount, EntityTypeAdmin, EntityTypeAllocatedIP, EntityTypeAny, EntityTypeAvailablePooledUsage, EntityTypeAvailableSiteUsage, EntityTypeCity, EntityTypeCountry, EntityTypeCountryState, EntityTypeDhcpRelayGroup, EntityTypeGroupSubscription, EntityTypeHost, EntityTypeLanFirewall, EntityTypeLocalRouting, EntityTypeLocation, EntityTypeMailingListSubscription, EntityTypeNetworkInterface, EntityTypePortProtocol, EntityTypeSimpleService, EntityTypeSite, EntityTypeSiteRange, EntityTypeTimezone, EntityTypeVpnUser, EntityTypeWebhookSubscription:
		return true
	}
	return false
}

func (e EntityType) String() string {
	return string(e)
}

func (e *EntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityType", str)
	}
	return nil
}

func (e EntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFeedFilterFieldName string

const (
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventSubType EventFeedFilterFieldName = "event_sub_type"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventType EventFeedFilterFieldName = "event_type"
)

var AllEventFeedFilterFieldName = []EventFeedFilterFieldName{
	EventFeedFilterFieldNameEventSubType,
	EventFeedFilterFieldNameEventType,
}

func (e EventFeedFilterFieldName) IsValid() bool {
	switch e {
	case EventFeedFilterFieldNameEventSubType, EventFeedFilterFieldNameEventType:
		return true
	}
	return false
}

func (e EventFeedFilterFieldName) String() string {
	return string(e)
}

func (e *EventFeedFilterFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterFieldName", str)
	}
	return nil
}

func (e EventFeedFilterFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on Event Feed
type EventFeedFilterOperator string

const (
	EventFeedFilterOperatorIn    EventFeedFilterOperator = "in"
	EventFeedFilterOperatorIs    EventFeedFilterOperator = "is"
	EventFeedFilterOperatorIsNot EventFeedFilterOperator = "is_not"
	EventFeedFilterOperatorNotIn EventFeedFilterOperator = "not_in"
)

var AllEventFeedFilterOperator = []EventFeedFilterOperator{
	EventFeedFilterOperatorIn,
	EventFeedFilterOperatorIs,
	EventFeedFilterOperatorIsNot,
	EventFeedFilterOperatorNotIn,
}

func (e EventFeedFilterOperator) IsValid() bool {
	switch e {
	case EventFeedFilterOperatorIn, EventFeedFilterOperatorIs, EventFeedFilterOperatorIsNot, EventFeedFilterOperatorNotIn:
		return true
	}
	return false
}

func (e EventFeedFilterOperator) String() string {
	return string(e)
}

func (e *EventFeedFilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterOperator", str)
	}
	return nil
}

func (e EventFeedFilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFieldName string

const (
	// Identifies system access software or device
	EventFieldNameAccessMethod EventFieldName = "access_method"
	// Account ID
	EventFieldNameAccountID EventFieldName = "account_id"
	// Firewall, QoS or LAG action
	EventFieldNameAction EventFieldName = "action"
	// Active Directory name
	EventFieldNameAdName  EventFieldName = "ad_name"
	EventFieldNameAlertID EventFieldName = "alert_id"
	// Always-on Configuration
	EventFieldNameAlwaysOnConfiguration EventFieldName = "always_on_configuration"
	// Analyst Verdict
	EventFieldNameAnalystVerdict EventFieldName = "analyst_verdict"
	EventFieldNameAPIName        EventFieldName = "api_name"
	EventFieldNameAPIType        EventFieldName = "api_type"
	// Name of application activity
	EventFieldNameAppActivity EventFieldName = "app_activity"
	// SaaS user activities into categories.
	EventFieldNameAppActivityCategory EventFieldName = "app_activity_category"
	// Activity type
	EventFieldNameAppActivityType EventFieldName = "app_activity_type"
	// Related Apps
	EventFieldNameAppStack EventFieldName = "app_stack"
	// For Internet firewall, app for this event
	EventFieldNameApplication EventFieldName = "application"
	// Application ID of the flow
	EventFieldNameApplicationID EventFieldName = "application_id"
	// Application of the flow
	EventFieldNameApplicationName EventFieldName = "application_name"
	// Application risk score
	EventFieldNameApplicationRisk EventFieldName = "application_risk"
	// Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN
	EventFieldNameAuthMethod EventFieldName = "auth_method"
	// Examples: MFA or password
	EventFieldNameAuthenticationType EventFieldName = "authentication_type"
	// BGP ASN for Cato peer
	EventFieldNameBgpCatoAsn EventFieldName = "bgp_cato_asn"
	// BGP IP for Cato peer
	EventFieldNameBgpCatoIP EventFieldName = "bgp_cato_ip"
	// BGP disconnect error code
	EventFieldNameBgpErrorCode EventFieldName = "bgp_error_code"
	// BGP ASN for remote peer
	EventFieldNameBgpPeerAsn EventFieldName = "bgp_peer_asn"
	// Description from Cato Management Application for BGP peer
	EventFieldNameBgpPeerDescription EventFieldName = "bgp_peer_description"
	// BGP IP for remote peer
	EventFieldNameBgpPeerIP EventFieldName = "bgp_peer_ip"
	// CIDR for BGP route
	EventFieldNameBgpRouteCidr EventFieldName = "bgp_route_cidr"
	// BGP disconnect error message
	EventFieldNameBgpSuberrorCode EventFieldName = "bgp_suberror_code"
	// Always-On Bypass Duration In Seconds
	EventFieldNameBypassDurationSec EventFieldName = "bypass_duration_sec"
	// Always-On Bypass Method
	EventFieldNameBypassMethod EventFieldName = "bypass_method"
	// Always-On Bypass Reason
	EventFieldNameBypassReason EventFieldName = "bypass_reason"
	// Cato system category
	EventFieldNameCategories EventFieldName = "categories"
	// Cato App
	EventFieldNameCatoApp        EventFieldName = "cato_app"
	EventFieldNameClassification EventFieldName = "classification"
	// Expiration date for Client certificate
	EventFieldNameClientCertExpires EventFieldName = "client_cert_expires"
	// Name of Client certificate
	EventFieldNameClientCertName EventFieldName = "client_cert_name"
	// Type of process generating this traffic
	EventFieldNameClientClass EventFieldName = "client_class"
	// Socket or SDP Client version
	EventFieldNameClientVersion EventFieldName = "client_version"
	// Shows the display name of the target user involved in an activity
	EventFieldNameCollaboratorName EventFieldName = "collaborator_name"
	// For SaaS Security API, email addresses of the users that received the file
	EventFieldNameCollaborators EventFieldName = "collaborators"
	// Confidence Level
	EventFieldNameConfidenceLevel EventFieldName = "confidence_level"
	// For hosts configured with a static IP in the Cato Management Application, the host name
	EventFieldNameConfiguredHostName EventFieldName = "configured_host_name"
	// The algorithm that is used (CUBIC /NewReno / BBR)
	EventFieldNameCongestionAlgorithm EventFieldName = "congestion_algorithm"
	// Connect on boot Enabled/Disabled
	EventFieldNameConnectOnBoot EventFieldName = "connect_on_boot"
	// For SaaS Security API, name of the connector
	EventFieldNameConnectorName EventFieldName = "connector_name"
	// For SaaS Security API, status of the connector
	EventFieldNameConnectorStatus EventFieldName = "connector_status"
	// For SaaS Security API, SaaS app for the connector
	EventFieldNameConnectorType EventFieldName = "connector_type"
	// Criticality
	EventFieldNameCriticality EventFieldName = "criticality"
	// Unique Cato ID for the custom category
	EventFieldNameCustomCategories EventFieldName = "custom_categories"
	// Name for the custom category defined in the Cato Management Application
	EventFieldNameCustomCategory EventFieldName = "custom_category"
	// Custom category ID
	EventFieldNameCustomCategoryID EventFieldName = "custom_category_id"
	// Custom category name
	EventFieldNameCustomCategoryName EventFieldName = "custom_category_name"
	// For Internet traffic, country where the destination host is located
	EventFieldNameDestCountry EventFieldName = "dest_country"
	// For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)
	EventFieldNameDestCountryCode EventFieldName = "dest_country_code"
	// The unique identifier by the SaaS vendor for the target group in an activity.
	EventFieldNameDestGroupID EventFieldName = "dest_group_id"
	// Identifies the target group involved in an activity
	EventFieldNameDestGroupName EventFieldName = "dest_group_name"
	// For Internet traffic, destination host IP address
	EventFieldNameDestIP EventFieldName = "dest_ip"
	// For WAN traffic, destination is site or SDP user
	EventFieldNameDestIsSiteOrVpn EventFieldName = "dest_is_site_or_vpn"
	// For Internet traffic, destination host port
	EventFieldNameDestPort EventFieldName = "dest_port"
	// For WAN traffic, name of destination site or SDP user
	EventFieldNameDestSite EventFieldName = "dest_site"
	// Unique internal Cato ID for the destination site or remote user
	EventFieldNameDestSiteID EventFieldName = "dest_site_id"
	// For Internet traffic, destination host IP address
	EventFieldNameDestSiteName EventFieldName = "dest_site_name"
	// Device Categories
	EventFieldNameDeviceCategories EventFieldName = "device_categories"
	// Device Certificate Validated/Not Validated
	EventFieldNameDeviceCertificate EventFieldName = "device_certificate"
	// Unique Cato ID for devices
	EventFieldNameDeviceID EventFieldName = "device_id"
	// Device Manufacturer
	EventFieldNameDeviceManufacturer EventFieldName = "device_manufacturer"
	// Device Model
	EventFieldNameDeviceModel EventFieldName = "device_model"
	// Name for device related to the event
	EventFieldNameDeviceName EventFieldName = "device_name"
	// Device OS Type
	EventFieldNameDeviceOsType EventFieldName = "device_os_type"
	// Device posture profiles
	EventFieldNameDevicePostureProfile EventFieldName = "device_posture_profile"
	// Device posture profiles
	EventFieldNameDevicePostureProfiles EventFieldName = "device_posture_profiles"
	// Device Type
	EventFieldNameDeviceType EventFieldName = "device_type"
	// Host name of Domain Controller that created LDAP event
	EventFieldNameDirectoryHostName EventFieldName = "directory_host_name"
	// IP address of Domain Controller that created LDAP event
	EventFieldNameDirectoryIP EventFieldName = "directory_ip"
	// Result of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncResult EventFieldName = "directory_sync_result"
	// Type of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncType EventFieldName = "directory_sync_type"
	// DLP fail mode
	EventFieldNameDlpFailMode EventFieldName = "dlp_fail_mode"
	// DLP profiles related to the event
	EventFieldNameDlpProfiles EventFieldName = "dlp_profiles"
	// Data Classifiers
	EventFieldNameDlpScanTypes EventFieldName = "dlp_scan_types"
	// Cato’s DNS Protection type that matched the DNS request
	EventFieldNameDNSProtectionCategory EventFieldName = "dns_protection_category"
	// Domain queried in the DNS request
	EventFieldNameDNSQuery EventFieldName = "dns_query"
	// Domain name based on the SSL SNI, HTTP host name, or DNS name
	EventFieldNameDomainName EventFieldName = "domain_name"
	// Egress PoP Name
	EventFieldNameEgressPopName EventFieldName = "egress_pop_name"
	// Egress Site Name for backhauling traffic
	EventFieldNameEgressSiteName EventFieldName = "egress_site_name"
	// Email Subject
	EventFieldNameEmailSubject EventFieldName = "email_subject"
	// Count for events that are repeated multiple times during one minute
	EventFieldNameEventCount EventFieldName = "event_count"
	// Cato's description of the event
	EventFieldNameEventMessage EventFieldName = "event_message"
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventSubType EventFieldName = "event_sub_type"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventType     EventFieldName = "event_type"
	EventFieldNameFailureReason EventFieldName = "failure_reason"
	// File hash
	EventFieldNameFileHash EventFieldName = "file_hash"
	// File name
	EventFieldNameFileName EventFieldName = "file_name"
	// File size
	EventFieldNameFileSize EventFieldName = "file_size"
	// File type
	EventFieldNameFileType          EventFieldName = "file_type"
	EventFieldNameFinalObjectStatus EventFieldName = "final_object_status"
	// Amount of flows for a given incident
	EventFieldNameFlowsCardinality EventFieldName = "flows_cardinality"
	// Full path URL application activity
	EventFieldNameFullPathURL EventFieldName = "full_path_url"
	// IP address of host related to event
	EventFieldNameHostIP EventFieldName = "host_ip"
	// MAC address of host related to event
	EventFieldNameHostMac EventFieldName = "host_mac"
	// HTTP request method (ie. Get, Post)
	EventFieldNameHTTPRequestMethod EventFieldName = "http_request_method"
	// For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)
	EventFieldNameIncidentAggregation EventFieldName = "incident_aggregation"
	// Unique Cato ID that identifies this security incident
	EventFieldNameIncidentID EventFieldName = "incident_id"
	// Indication
	EventFieldNameIndication EventFieldName = "indication"
	// Indicator
	EventFieldNameIndicator EventFieldName = "indicator"
	// Cato Internal-use only
	EventFieldNameInternalID EventFieldName = "internalId"
	// Network protocol for this event
	EventFieldNameIPProtocol EventFieldName = "ip_protocol"
	// Classifies users based on their permissions.
	EventFieldNameIsAdmin EventFieldName = "is_admin"
	// Indicates whether an activity requires administrative permissions.
	EventFieldNameIsAdminActivity EventFieldName = "is_admin_activity"
	// Is Compliant
	EventFieldNameIsCompliant EventFieldName = "is_compliant"
	// Is Managed
	EventFieldNameIsManaged EventFieldName = "is_managed"
	// Is the app for this event defined as a sanctioned app? (True/False)
	EventFieldNameIsSanctionedApp EventFieldName = "is_sanctioned_app"
	// The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	EventFieldNameIspName EventFieldName = "ISP_name"
	// Name defined for the public API Key in the Cato Management Application
	EventFieldNameKeyName EventFieldName = "key_name"
	// Data that measures the congestion for a specific link
	EventFieldNameLinkHealthIsCongested EventFieldName = "link_health_is_congested"
	// Data that measures the jitter for a specific link
	EventFieldNameLinkHealthJitter EventFieldName = "link_health_jitter"
	// Data that measures the latency for a specific link
	EventFieldNameLinkHealthLatency EventFieldName = "link_health_latency"
	// Data that measures the packet loss for a specific link
	EventFieldNameLinkHealthPktLoss EventFieldName = "link_health_pkt_loss"
	// Link type – Cato, Alt. WAN or LAG
	EventFieldNameLinkType     EventFieldName = "link_type"
	EventFieldNameLoggedInUser EventFieldName = "logged_in_user"
	// Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)
	EventFieldNameLoginType EventFieldName = "login_type"
	// Matched DLP data types related to the event
	EventFieldNameMatchedDataTypes EventFieldName = "matched_data_types"
	// Mitre attack subtechniques
	EventFieldNameMitreAttackSubtechniques EventFieldName = "mitre_attack_subtechniques"
	// Mitre attack tactics
	EventFieldNameMitreAttackTactics EventFieldName = "mitre_attack_tactics"
	// Mitre attack techniques
	EventFieldNameMitreAttackTechniques EventFieldName = "mitre_attack_techniques"
	// Network Access
	EventFieldNameNetworkAccess EventFieldName = "network_access"
	// Matched network rule
	EventFieldNameNetworkRule EventFieldName = "network_rule"
	// For SaaS Security API, API Error of Apps Security Notification
	EventFieldNameNotificationAPIError EventFieldName = "notification_api_error"
	// For SaaS Security API, description of Apps Security Notification
	EventFieldNameNotificationDescription EventFieldName = "notification_description"
	EventFieldNameObjectID                EventFieldName = "object_id"
	EventFieldNameObjectName              EventFieldName = "object_name"
	EventFieldNameObjectType              EventFieldName = "object_type"
	// Office mode Enabled/Disabled
	EventFieldNameOfficeMode EventFieldName = "office_mode"
	// Host OS or tunnel device
	EventFieldNameOsType EventFieldName = "os_type"
	// OS version for the device (such as 14.3.0)
	EventFieldNameOsVersion       EventFieldName = "os_version"
	EventFieldNameOutOfBandAccess EventFieldName = "out_of_band_access"
	// For SaaS Security API, email address of the file owner
	EventFieldNameOwner EventFieldName = "owner"
	// Pac File Enabled/Disabled
	EventFieldNamePacFile EventFieldName = "pac_file"
	// For SaaS Security API, parent Microsoft 365 connector
	EventFieldNameParentConnectorName EventFieldName = "parent_connector_name"
	EventFieldNameParentPid           EventFieldName = "parent_pid"
	EventFieldNamePid                 EventFieldName = "pid"
	// Name of PoP location
	EventFieldNamePopName     EventFieldName = "pop_name"
	EventFieldNameProcessPath EventFieldName = "process_path"
	// Producer
	EventFieldNameProducer EventFieldName = "producer"
	// Prompt Page Selected Action
	EventFieldNamePromptAction EventFieldName = "prompt_action"
	// Used Public IP
	EventFieldNamePublicIP EventFieldName = "public_ip"
	// QoS Priority value
	EventFieldNameQosPriority EventFieldName = "qos_priority"
	// For QoS, the time that this QoS event started. The event is generated when the QoS event finishes
	EventFieldNameQosReportedTime      EventFieldName = "qos_reported_time"
	EventFieldNameQuarantineFolderPath EventFieldName = "quarantine_folder_path"
	// Raw Data
	EventFieldNameRawData            EventFieldName = "raw_data"
	EventFieldNameRecommendedActions EventFieldName = "recommended_actions"
	// The URL that links directly to the object involved in the activity
	EventFieldNameReferenceURL EventFieldName = "reference_url"
	// Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)
	EventFieldNameRegistrationCode EventFieldName = "registration_code"
	// (IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low – ie. adware Medium – ie. network scans High – ie. spyware or worms
	EventFieldNameRiskLevel EventFieldName = "risk_level"
	// Name of security rule related to the event
	EventFieldNameRule EventFieldName = "rule"
	// Unique Cato ID for the security rule related to the event
	EventFieldNameRuleID EventFieldName = "rule_id"
	// Rule name
	EventFieldNameRuleName EventFieldName = "rule_name"
	// Severity defined for the rule
	EventFieldNameSeverity EventFieldName = "severity"
	// Sharing Options for the file (such as SharePoint)
	EventFieldNameSharingScope EventFieldName = "sharing_scope"
	// Sign In Types
	EventFieldNameSignInEventTypes EventFieldName = "sign_in_event_types"
	// For IPS and SAM, ID of the IPS signature
	EventFieldNameSignatureID EventFieldName = "signature_id"
	// Name for Socket interface
	EventFieldNameSocketInterface EventFieldName = "socket_interface"
	// Socket interface ID
	EventFieldNameSocketInterfaceID EventFieldName = "socket_interface_id"
	// For Socket upgrades, new version number
	EventFieldNameSocketNewVersion EventFieldName = "socket_new_version"
	// For Socket upgrade, previous version number
	EventFieldNameSocketOldVersion EventFieldName = "socket_old_version"
	// Type of Socket reset (Hardware/Software)
	EventFieldNameSocketReset EventFieldName = "socket_reset"
	// For Socket HA events, indicates if the Socket is primary or secondary
	EventFieldNameSocketRole EventFieldName = "socket_role"
	// Socket version number
	EventFieldNameSocketVersion EventFieldName = "socket_version"
	// Split Tunnel Configuration
	EventFieldNameSplitTunnelConfiguration EventFieldName = "split_tunnel_configuration"
	// Country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountry EventFieldName = "src_country"
	// Country Code of country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountryCode EventFieldName = "src_country_code"
	// IP for host or Cato Client
	EventFieldNameSrcIP EventFieldName = "src_ip"
	// Source type: site or remote user
	EventFieldNameSrcIsSiteOrVpn EventFieldName = "src_is_site_or_vpn"
	// IP address provided by ISP to site or Client
	EventFieldNameSrcIspIP EventFieldName = "src_isp_ip"
	// Source or destination site or remote user ID.
	// This field can only be used in filter.
	EventFieldNameSrcOrDestSiteID EventFieldName = "src_or_dest_site_id"
	// Internal port number
	EventFieldNameSrcPort EventFieldName = "src_port"
	// Name of site or user initiating the connection
	EventFieldNameSrcSite EventFieldName = "src_site"
	// Unique internal Cato ID for the site or remote user
	EventFieldNameSrcSiteID EventFieldName = "src_site_id"
	// Source site or remote user
	EventFieldNameSrcSiteName EventFieldName = "src_site_name"
	// Static host
	EventFieldNameStaticHost EventFieldName = "static_host"
	EventFieldNameStatus     EventFieldName = "status"
	// Story Id
	EventFieldNameStoryID EventFieldName = "story_id"
	// Name of subnet as defined in Cato Management Application
	EventFieldNameSubnetName EventFieldName = "subnet_name"
	// Number of targets (servers) associated with this event
	EventFieldNameTargetsCardinality EventFieldName = "targets_cardinality"
	// Shows if traffic was TCP accelerated or not
	EventFieldNameTCPAcceleration EventFieldName = "tcp_acceleration"
	// Tenant Id
	EventFieldNameTenantID EventFieldName = "tenant_id"
	// Tenant Name
	EventFieldNameTenantName EventFieldName = "tenant_name"
	// For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked
	EventFieldNameThreatName EventFieldName = "threat_name"
	// Link to external malware reference
	EventFieldNameThreatReference EventFieldName = "threat_reference"
	// Type of malware event
	EventFieldNameThreatType EventFieldName = "threat_type"
	// Result of malware event (clean indicates a safe file)
	EventFieldNameThreatVerdict EventFieldName = "threat_verdict"
	// Time stamp of event (Linux epoch format)
	EventFieldNameTime  EventFieldName = "time"
	EventFieldNameTitle EventFieldName = "title"
	// TLS Certificate Error
	EventFieldNameTLSCertificateError EventFieldName = "tls_certificate_error"
	// TLS Error Description
	EventFieldNameTLSErrorDescription EventFieldName = "tls_error_description"
	// TLS Error Type
	EventFieldNameTLSErrorType EventFieldName = "tls_error_type"
	// Shows if traffic was TLS inspected or not
	EventFieldNameTLSInspection EventFieldName = "tls_inspection"
	// TLS Inspection rule name
	EventFieldNameTLSRuleName EventFieldName = "tls_rule_name"
	// TLS Version
	EventFieldNameTLSVersion EventFieldName = "tls_version"
	// Direction of network traffic for this event, values are inbound or outbound
	EventFieldNameTrafficDirection EventFieldName = "traffic_direction"
	// Trigger
	EventFieldNameTrigger EventFieldName = "trigger"
	// Trust Type
	EventFieldNameTrustType EventFieldName = "trust_type"
	// Trusted networks Enabled/Disabled
	EventFieldNameTrustedNetworks EventFieldName = "trusted_networks"
	// Tunnel Protocol TCP/UDP
	EventFieldNameTunnelIPProtocol EventFieldName = "tunnel_ip_protocol"
	// Protocol for the tunnel
	EventFieldNameTunnelProtocol EventFieldName = "tunnel_protocol"
	// Socket upgrade end time (Linux epoch format):
	EventFieldNameUpgradeEndTime EventFieldName = "upgrade_end_time"
	// Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)
	EventFieldNameUpgradeInitiatedBy EventFieldName = "upgrade_initiated_by"
	// Socket upgrade start time (Linux epoch format)
	EventFieldNameUpgradeStartTime EventFieldName = "upgrade_start_time"
	// URL associated with the event
	EventFieldNameURL EventFieldName = "url"
	// User Agent
	EventFieldNameUserAgent EventFieldName = "user_agent"
	// Method used to get identity with User Awareness (such as Identity Agent)
	EventFieldNameUserAwarenessMethod EventFieldName = "user_awareness_method"
	// User ID
	EventFieldNameUserID EventFieldName = "user_id"
	// User that generated the event
	EventFieldNameUserName EventFieldName = "user_name"
	// For Block/Prompt page, reference ID to report incorrect category
	EventFieldNameUserReferenceID EventFieldName = "user_reference_id"
	EventFieldNameVendor          EventFieldName = "vendor"
	// Shows the id of the target user involved in an activity
	EventFieldNameVendorCollaboratorID EventFieldName = "vendor_collaborator_id"
	// Vendor Device Id
	EventFieldNameVendorDeviceID EventFieldName = "vendor_device_id"
	// Vendor Device Name
	EventFieldNameVendorDeviceName EventFieldName = "vendor_device_name"
	// Vendor Event Id
	EventFieldNameVendorEventID EventFieldName = "vendor_event_id"
	EventFieldNameVendorUserID  EventFieldName = "vendor_user_id"
	// Unique Cato Visible ID for devices
	EventFieldNameVisibleDeviceID EventFieldName = "visible_device_id"
	// Lan access Allowed / Blocked
	EventFieldNameVpnLanAccess EventFieldName = "vpn_lan_access"
	// User’s email address
	EventFieldNameVpnUserEmail EventFieldName = "vpn_user_email"
	// For LDAP sync events, name of the AD domain
	EventFieldNameWindowsDomainName EventFieldName = "windows_domain_name"
	// XFF HTTP header indicates the original IP address for the connections
	EventFieldNameXff EventFieldName = "xff"
)

var AllEventFieldName = []EventFieldName{
	EventFieldNameAccessMethod,
	EventFieldNameAccountID,
	EventFieldNameAction,
	EventFieldNameAdName,
	EventFieldNameAlertID,
	EventFieldNameAlwaysOnConfiguration,
	EventFieldNameAnalystVerdict,
	EventFieldNameAPIName,
	EventFieldNameAPIType,
	EventFieldNameAppActivity,
	EventFieldNameAppActivityCategory,
	EventFieldNameAppActivityType,
	EventFieldNameAppStack,
	EventFieldNameApplication,
	EventFieldNameApplicationID,
	EventFieldNameApplicationName,
	EventFieldNameApplicationRisk,
	EventFieldNameAuthMethod,
	EventFieldNameAuthenticationType,
	EventFieldNameBgpCatoAsn,
	EventFieldNameBgpCatoIP,
	EventFieldNameBgpErrorCode,
	EventFieldNameBgpPeerAsn,
	EventFieldNameBgpPeerDescription,
	EventFieldNameBgpPeerIP,
	EventFieldNameBgpRouteCidr,
	EventFieldNameBgpSuberrorCode,
	EventFieldNameBypassDurationSec,
	EventFieldNameBypassMethod,
	EventFieldNameBypassReason,
	EventFieldNameCategories,
	EventFieldNameCatoApp,
	EventFieldNameClassification,
	EventFieldNameClientCertExpires,
	EventFieldNameClientCertName,
	EventFieldNameClientClass,
	EventFieldNameClientVersion,
	EventFieldNameCollaboratorName,
	EventFieldNameCollaborators,
	EventFieldNameConfidenceLevel,
	EventFieldNameConfiguredHostName,
	EventFieldNameCongestionAlgorithm,
	EventFieldNameConnectOnBoot,
	EventFieldNameConnectorName,
	EventFieldNameConnectorStatus,
	EventFieldNameConnectorType,
	EventFieldNameCriticality,
	EventFieldNameCustomCategories,
	EventFieldNameCustomCategory,
	EventFieldNameCustomCategoryID,
	EventFieldNameCustomCategoryName,
	EventFieldNameDestCountry,
	EventFieldNameDestCountryCode,
	EventFieldNameDestGroupID,
	EventFieldNameDestGroupName,
	EventFieldNameDestIP,
	EventFieldNameDestIsSiteOrVpn,
	EventFieldNameDestPort,
	EventFieldNameDestSite,
	EventFieldNameDestSiteID,
	EventFieldNameDestSiteName,
	EventFieldNameDeviceCategories,
	EventFieldNameDeviceCertificate,
	EventFieldNameDeviceID,
	EventFieldNameDeviceManufacturer,
	EventFieldNameDeviceModel,
	EventFieldNameDeviceName,
	EventFieldNameDeviceOsType,
	EventFieldNameDevicePostureProfile,
	EventFieldNameDevicePostureProfiles,
	EventFieldNameDeviceType,
	EventFieldNameDirectoryHostName,
	EventFieldNameDirectoryIP,
	EventFieldNameDirectorySyncResult,
	EventFieldNameDirectorySyncType,
	EventFieldNameDlpFailMode,
	EventFieldNameDlpProfiles,
	EventFieldNameDlpScanTypes,
	EventFieldNameDNSProtectionCategory,
	EventFieldNameDNSQuery,
	EventFieldNameDomainName,
	EventFieldNameEgressPopName,
	EventFieldNameEgressSiteName,
	EventFieldNameEmailSubject,
	EventFieldNameEventCount,
	EventFieldNameEventMessage,
	EventFieldNameEventSubType,
	EventFieldNameEventType,
	EventFieldNameFailureReason,
	EventFieldNameFileHash,
	EventFieldNameFileName,
	EventFieldNameFileSize,
	EventFieldNameFileType,
	EventFieldNameFinalObjectStatus,
	EventFieldNameFlowsCardinality,
	EventFieldNameFullPathURL,
	EventFieldNameHostIP,
	EventFieldNameHostMac,
	EventFieldNameHTTPRequestMethod,
	EventFieldNameIncidentAggregation,
	EventFieldNameIncidentID,
	EventFieldNameIndication,
	EventFieldNameIndicator,
	EventFieldNameInternalID,
	EventFieldNameIPProtocol,
	EventFieldNameIsAdmin,
	EventFieldNameIsAdminActivity,
	EventFieldNameIsCompliant,
	EventFieldNameIsManaged,
	EventFieldNameIsSanctionedApp,
	EventFieldNameIspName,
	EventFieldNameKeyName,
	EventFieldNameLinkHealthIsCongested,
	EventFieldNameLinkHealthJitter,
	EventFieldNameLinkHealthLatency,
	EventFieldNameLinkHealthPktLoss,
	EventFieldNameLinkType,
	EventFieldNameLoggedInUser,
	EventFieldNameLoginType,
	EventFieldNameMatchedDataTypes,
	EventFieldNameMitreAttackSubtechniques,
	EventFieldNameMitreAttackTactics,
	EventFieldNameMitreAttackTechniques,
	EventFieldNameNetworkAccess,
	EventFieldNameNetworkRule,
	EventFieldNameNotificationAPIError,
	EventFieldNameNotificationDescription,
	EventFieldNameObjectID,
	EventFieldNameObjectName,
	EventFieldNameObjectType,
	EventFieldNameOfficeMode,
	EventFieldNameOsType,
	EventFieldNameOsVersion,
	EventFieldNameOutOfBandAccess,
	EventFieldNameOwner,
	EventFieldNamePacFile,
	EventFieldNameParentConnectorName,
	EventFieldNameParentPid,
	EventFieldNamePid,
	EventFieldNamePopName,
	EventFieldNameProcessPath,
	EventFieldNameProducer,
	EventFieldNamePromptAction,
	EventFieldNamePublicIP,
	EventFieldNameQosPriority,
	EventFieldNameQosReportedTime,
	EventFieldNameQuarantineFolderPath,
	EventFieldNameRawData,
	EventFieldNameRecommendedActions,
	EventFieldNameReferenceURL,
	EventFieldNameRegistrationCode,
	EventFieldNameRiskLevel,
	EventFieldNameRule,
	EventFieldNameRuleID,
	EventFieldNameRuleName,
	EventFieldNameSeverity,
	EventFieldNameSharingScope,
	EventFieldNameSignInEventTypes,
	EventFieldNameSignatureID,
	EventFieldNameSocketInterface,
	EventFieldNameSocketInterfaceID,
	EventFieldNameSocketNewVersion,
	EventFieldNameSocketOldVersion,
	EventFieldNameSocketReset,
	EventFieldNameSocketRole,
	EventFieldNameSocketVersion,
	EventFieldNameSplitTunnelConfiguration,
	EventFieldNameSrcCountry,
	EventFieldNameSrcCountryCode,
	EventFieldNameSrcIP,
	EventFieldNameSrcIsSiteOrVpn,
	EventFieldNameSrcIspIP,
	EventFieldNameSrcOrDestSiteID,
	EventFieldNameSrcPort,
	EventFieldNameSrcSite,
	EventFieldNameSrcSiteID,
	EventFieldNameSrcSiteName,
	EventFieldNameStaticHost,
	EventFieldNameStatus,
	EventFieldNameStoryID,
	EventFieldNameSubnetName,
	EventFieldNameTargetsCardinality,
	EventFieldNameTCPAcceleration,
	EventFieldNameTenantID,
	EventFieldNameTenantName,
	EventFieldNameThreatName,
	EventFieldNameThreatReference,
	EventFieldNameThreatType,
	EventFieldNameThreatVerdict,
	EventFieldNameTime,
	EventFieldNameTitle,
	EventFieldNameTLSCertificateError,
	EventFieldNameTLSErrorDescription,
	EventFieldNameTLSErrorType,
	EventFieldNameTLSInspection,
	EventFieldNameTLSRuleName,
	EventFieldNameTLSVersion,
	EventFieldNameTrafficDirection,
	EventFieldNameTrigger,
	EventFieldNameTrustType,
	EventFieldNameTrustedNetworks,
	EventFieldNameTunnelIPProtocol,
	EventFieldNameTunnelProtocol,
	EventFieldNameUpgradeEndTime,
	EventFieldNameUpgradeInitiatedBy,
	EventFieldNameUpgradeStartTime,
	EventFieldNameURL,
	EventFieldNameUserAgent,
	EventFieldNameUserAwarenessMethod,
	EventFieldNameUserID,
	EventFieldNameUserName,
	EventFieldNameUserReferenceID,
	EventFieldNameVendor,
	EventFieldNameVendorCollaboratorID,
	EventFieldNameVendorDeviceID,
	EventFieldNameVendorDeviceName,
	EventFieldNameVendorEventID,
	EventFieldNameVendorUserID,
	EventFieldNameVisibleDeviceID,
	EventFieldNameVpnLanAccess,
	EventFieldNameVpnUserEmail,
	EventFieldNameWindowsDomainName,
	EventFieldNameXff,
}

func (e EventFieldName) IsValid() bool {
	switch e {
	case EventFieldNameAccessMethod, EventFieldNameAccountID, EventFieldNameAction, EventFieldNameAdName, EventFieldNameAlertID, EventFieldNameAlwaysOnConfiguration, EventFieldNameAnalystVerdict, EventFieldNameAPIName, EventFieldNameAPIType, EventFieldNameAppActivity, EventFieldNameAppActivityCategory, EventFieldNameAppActivityType, EventFieldNameAppStack, EventFieldNameApplication, EventFieldNameApplicationID, EventFieldNameApplicationName, EventFieldNameApplicationRisk, EventFieldNameAuthMethod, EventFieldNameAuthenticationType, EventFieldNameBgpCatoAsn, EventFieldNameBgpCatoIP, EventFieldNameBgpErrorCode, EventFieldNameBgpPeerAsn, EventFieldNameBgpPeerDescription, EventFieldNameBgpPeerIP, EventFieldNameBgpRouteCidr, EventFieldNameBgpSuberrorCode, EventFieldNameBypassDurationSec, EventFieldNameBypassMethod, EventFieldNameBypassReason, EventFieldNameCategories, EventFieldNameCatoApp, EventFieldNameClassification, EventFieldNameClientCertExpires, EventFieldNameClientCertName, EventFieldNameClientClass, EventFieldNameClientVersion, EventFieldNameCollaboratorName, EventFieldNameCollaborators, EventFieldNameConfidenceLevel, EventFieldNameConfiguredHostName, EventFieldNameCongestionAlgorithm, EventFieldNameConnectOnBoot, EventFieldNameConnectorName, EventFieldNameConnectorStatus, EventFieldNameConnectorType, EventFieldNameCriticality, EventFieldNameCustomCategories, EventFieldNameCustomCategory, EventFieldNameCustomCategoryID, EventFieldNameCustomCategoryName, EventFieldNameDestCountry, EventFieldNameDestCountryCode, EventFieldNameDestGroupID, EventFieldNameDestGroupName, EventFieldNameDestIP, EventFieldNameDestIsSiteOrVpn, EventFieldNameDestPort, EventFieldNameDestSite, EventFieldNameDestSiteID, EventFieldNameDestSiteName, EventFieldNameDeviceCategories, EventFieldNameDeviceCertificate, EventFieldNameDeviceID, EventFieldNameDeviceManufacturer, EventFieldNameDeviceModel, EventFieldNameDeviceName, EventFieldNameDeviceOsType, EventFieldNameDevicePostureProfile, EventFieldNameDevicePostureProfiles, EventFieldNameDeviceType, EventFieldNameDirectoryHostName, EventFieldNameDirectoryIP, EventFieldNameDirectorySyncResult, EventFieldNameDirectorySyncType, EventFieldNameDlpFailMode, EventFieldNameDlpProfiles, EventFieldNameDlpScanTypes, EventFieldNameDNSProtectionCategory, EventFieldNameDNSQuery, EventFieldNameDomainName, EventFieldNameEgressPopName, EventFieldNameEgressSiteName, EventFieldNameEmailSubject, EventFieldNameEventCount, EventFieldNameEventMessage, EventFieldNameEventSubType, EventFieldNameEventType, EventFieldNameFailureReason, EventFieldNameFileHash, EventFieldNameFileName, EventFieldNameFileSize, EventFieldNameFileType, EventFieldNameFinalObjectStatus, EventFieldNameFlowsCardinality, EventFieldNameFullPathURL, EventFieldNameHostIP, EventFieldNameHostMac, EventFieldNameHTTPRequestMethod, EventFieldNameIncidentAggregation, EventFieldNameIncidentID, EventFieldNameIndication, EventFieldNameIndicator, EventFieldNameInternalID, EventFieldNameIPProtocol, EventFieldNameIsAdmin, EventFieldNameIsAdminActivity, EventFieldNameIsCompliant, EventFieldNameIsManaged, EventFieldNameIsSanctionedApp, EventFieldNameIspName, EventFieldNameKeyName, EventFieldNameLinkHealthIsCongested, EventFieldNameLinkHealthJitter, EventFieldNameLinkHealthLatency, EventFieldNameLinkHealthPktLoss, EventFieldNameLinkType, EventFieldNameLoggedInUser, EventFieldNameLoginType, EventFieldNameMatchedDataTypes, EventFieldNameMitreAttackSubtechniques, EventFieldNameMitreAttackTactics, EventFieldNameMitreAttackTechniques, EventFieldNameNetworkAccess, EventFieldNameNetworkRule, EventFieldNameNotificationAPIError, EventFieldNameNotificationDescription, EventFieldNameObjectID, EventFieldNameObjectName, EventFieldNameObjectType, EventFieldNameOfficeMode, EventFieldNameOsType, EventFieldNameOsVersion, EventFieldNameOutOfBandAccess, EventFieldNameOwner, EventFieldNamePacFile, EventFieldNameParentConnectorName, EventFieldNameParentPid, EventFieldNamePid, EventFieldNamePopName, EventFieldNameProcessPath, EventFieldNameProducer, EventFieldNamePromptAction, EventFieldNamePublicIP, EventFieldNameQosPriority, EventFieldNameQosReportedTime, EventFieldNameQuarantineFolderPath, EventFieldNameRawData, EventFieldNameRecommendedActions, EventFieldNameReferenceURL, EventFieldNameRegistrationCode, EventFieldNameRiskLevel, EventFieldNameRule, EventFieldNameRuleID, EventFieldNameRuleName, EventFieldNameSeverity, EventFieldNameSharingScope, EventFieldNameSignInEventTypes, EventFieldNameSignatureID, EventFieldNameSocketInterface, EventFieldNameSocketInterfaceID, EventFieldNameSocketNewVersion, EventFieldNameSocketOldVersion, EventFieldNameSocketReset, EventFieldNameSocketRole, EventFieldNameSocketVersion, EventFieldNameSplitTunnelConfiguration, EventFieldNameSrcCountry, EventFieldNameSrcCountryCode, EventFieldNameSrcIP, EventFieldNameSrcIsSiteOrVpn, EventFieldNameSrcIspIP, EventFieldNameSrcOrDestSiteID, EventFieldNameSrcPort, EventFieldNameSrcSite, EventFieldNameSrcSiteID, EventFieldNameSrcSiteName, EventFieldNameStaticHost, EventFieldNameStatus, EventFieldNameStoryID, EventFieldNameSubnetName, EventFieldNameTargetsCardinality, EventFieldNameTCPAcceleration, EventFieldNameTenantID, EventFieldNameTenantName, EventFieldNameThreatName, EventFieldNameThreatReference, EventFieldNameThreatType, EventFieldNameThreatVerdict, EventFieldNameTime, EventFieldNameTitle, EventFieldNameTLSCertificateError, EventFieldNameTLSErrorDescription, EventFieldNameTLSErrorType, EventFieldNameTLSInspection, EventFieldNameTLSRuleName, EventFieldNameTLSVersion, EventFieldNameTrafficDirection, EventFieldNameTrigger, EventFieldNameTrustType, EventFieldNameTrustedNetworks, EventFieldNameTunnelIPProtocol, EventFieldNameTunnelProtocol, EventFieldNameUpgradeEndTime, EventFieldNameUpgradeInitiatedBy, EventFieldNameUpgradeStartTime, EventFieldNameURL, EventFieldNameUserAgent, EventFieldNameUserAwarenessMethod, EventFieldNameUserID, EventFieldNameUserName, EventFieldNameUserReferenceID, EventFieldNameVendor, EventFieldNameVendorCollaboratorID, EventFieldNameVendorDeviceID, EventFieldNameVendorDeviceName, EventFieldNameVendorEventID, EventFieldNameVendorUserID, EventFieldNameVisibleDeviceID, EventFieldNameVpnLanAccess, EventFieldNameVpnUserEmail, EventFieldNameWindowsDomainName, EventFieldNameXff:
		return true
	}
	return false
}

func (e EventFieldName) String() string {
	return string(e)
}

func (e *EventFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFieldName", str)
	}
	return nil
}

func (e EventFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterOperator string

const (
	FilterOperatorBetween    FilterOperator = "between"
	FilterOperatorExists     FilterOperator = "exists"
	FilterOperatorGt         FilterOperator = "gt"
	FilterOperatorGte        FilterOperator = "gte"
	FilterOperatorIn         FilterOperator = "in"
	FilterOperatorIs         FilterOperator = "is"
	FilterOperatorIsNot      FilterOperator = "is_not"
	FilterOperatorLt         FilterOperator = "lt"
	FilterOperatorLte        FilterOperator = "lte"
	FilterOperatorNotBetween FilterOperator = "not_between"
	FilterOperatorNotExists  FilterOperator = "not_exists"
	FilterOperatorNotIn      FilterOperator = "not_in"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorBetween,
	FilterOperatorExists,
	FilterOperatorGt,
	FilterOperatorGte,
	FilterOperatorIn,
	FilterOperatorIs,
	FilterOperatorIsNot,
	FilterOperatorLt,
	FilterOperatorLte,
	FilterOperatorNotBetween,
	FilterOperatorNotExists,
	FilterOperatorNotIn,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorBetween, FilterOperatorExists, FilterOperatorGt, FilterOperatorGte, FilterOperatorIn, FilterOperatorIs, FilterOperatorIsNot, FilterOperatorLt, FilterOperatorLte, FilterOperatorNotBetween, FilterOperatorNotExists, FilterOperatorNotIn:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaReadiness string

const (
	HaReadinessNotReady HaReadiness = "not_ready"
	HaReadinessReady    HaReadiness = "ready"
)

var AllHaReadiness = []HaReadiness{
	HaReadinessNotReady,
	HaReadinessReady,
}

func (e HaReadiness) IsValid() bool {
	switch e {
	case HaReadinessNotReady, HaReadinessReady:
		return true
	}
	return false
}

func (e HaReadiness) String() string {
	return string(e)
}

func (e *HaReadiness) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaReadiness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaReadiness", str)
	}
	return nil
}

func (e HaReadiness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaSubStatus string

const (
	HaSubStatusFail HaSubStatus = "fail"
	HaSubStatusOk   HaSubStatus = "ok"
)

var AllHaSubStatus = []HaSubStatus{
	HaSubStatusFail,
	HaSubStatusOk,
}

func (e HaSubStatus) IsValid() bool {
	switch e {
	case HaSubStatusFail, HaSubStatusOk:
		return true
	}
	return false
}

func (e HaSubStatus) String() string {
	return string(e)
}

func (e *HaSubStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaSubStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaSubStatus", str)
	}
	return nil
}

func (e HaSubStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecV2InterfaceID string

const (
	IPSecV2InterfaceIDPrimary1   IPSecV2InterfaceID = "PRIMARY1"
	IPSecV2InterfaceIDPrimary2   IPSecV2InterfaceID = "PRIMARY2"
	IPSecV2InterfaceIDPrimary3   IPSecV2InterfaceID = "PRIMARY3"
	IPSecV2InterfaceIDSecondary1 IPSecV2InterfaceID = "SECONDARY1"
	IPSecV2InterfaceIDSecondary2 IPSecV2InterfaceID = "SECONDARY2"
	IPSecV2InterfaceIDSecondary3 IPSecV2InterfaceID = "SECONDARY3"
)

var AllIPSecV2InterfaceID = []IPSecV2InterfaceID{
	IPSecV2InterfaceIDPrimary1,
	IPSecV2InterfaceIDPrimary2,
	IPSecV2InterfaceIDPrimary3,
	IPSecV2InterfaceIDSecondary1,
	IPSecV2InterfaceIDSecondary2,
	IPSecV2InterfaceIDSecondary3,
}

func (e IPSecV2InterfaceID) IsValid() bool {
	switch e {
	case IPSecV2InterfaceIDPrimary1, IPSecV2InterfaceIDPrimary2, IPSecV2InterfaceIDPrimary3, IPSecV2InterfaceIDSecondary1, IPSecV2InterfaceIDSecondary2, IPSecV2InterfaceIDSecondary3:
		return true
	}
	return false
}

func (e IPSecV2InterfaceID) String() string {
	return string(e)
}

func (e *IPSecV2InterfaceID) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2InterfaceID(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2InterfaceId", str)
	}
	return nil
}

func (e IPSecV2InterfaceID) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IdentificationType string

const (
	IdentificationTypeEmail IdentificationType = "EMAIL"
	IdentificationTypeFqdn  IdentificationType = "FQDN"
	IdentificationTypeIPV4  IdentificationType = "IPV4"
	IdentificationTypeKeyID IdentificationType = "KEY_ID"
)

var AllIdentificationType = []IdentificationType{
	IdentificationTypeEmail,
	IdentificationTypeFqdn,
	IdentificationTypeIPV4,
	IdentificationTypeKeyID,
}

func (e IdentificationType) IsValid() bool {
	switch e {
	case IdentificationTypeEmail, IdentificationTypeFqdn, IdentificationTypeIPV4, IdentificationTypeKeyID:
		return true
	}
	return false
}

func (e IdentificationType) String() string {
	return string(e)
}

func (e *IdentificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentificationType", str)
	}
	return nil
}

func (e IdentificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IlmmOnboardingStatus string

const (
	IlmmOnboardingStatusComplete IlmmOnboardingStatus = "COMPLETE"
	IlmmOnboardingStatusFailed   IlmmOnboardingStatus = "FAILED"
	IlmmOnboardingStatusMissing  IlmmOnboardingStatus = "MISSING"
	IlmmOnboardingStatusPending  IlmmOnboardingStatus = "PENDING"
)

var AllIlmmOnboardingStatus = []IlmmOnboardingStatus{
	IlmmOnboardingStatusComplete,
	IlmmOnboardingStatusFailed,
	IlmmOnboardingStatusMissing,
	IlmmOnboardingStatusPending,
}

func (e IlmmOnboardingStatus) IsValid() bool {
	switch e {
	case IlmmOnboardingStatusComplete, IlmmOnboardingStatusFailed, IlmmOnboardingStatusMissing, IlmmOnboardingStatusPending:
		return true
	}
	return false
}

func (e IlmmOnboardingStatus) String() string {
	return string(e)
}

func (e *IlmmOnboardingStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IlmmOnboardingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IlmmOnboardingStatus", str)
	}
	return nil
}

func (e IlmmOnboardingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The action applied by the Internet Firewall if the rule is matched
type InternetFirewallActionEnum string

const (
	// Allow the network traffic to pass through the firewall.
	InternetFirewallActionEnumAllow InternetFirewallActionEnum = "ALLOW"
	// Deny the network traffic from passing through the firewall.
	InternetFirewallActionEnumBlock InternetFirewallActionEnum = "BLOCK"
	// Requests user confirmation to allow or block network traffic.
	InternetFirewallActionEnumPrompt InternetFirewallActionEnum = "PROMPT"
	// Apply Remote Browser Isolation (RBI) to the network traffic
	InternetFirewallActionEnumRbi InternetFirewallActionEnum = "RBI"
)

var AllInternetFirewallActionEnum = []InternetFirewallActionEnum{
	InternetFirewallActionEnumAllow,
	InternetFirewallActionEnumBlock,
	InternetFirewallActionEnumPrompt,
	InternetFirewallActionEnumRbi,
}

func (e InternetFirewallActionEnum) IsValid() bool {
	switch e {
	case InternetFirewallActionEnumAllow, InternetFirewallActionEnumBlock, InternetFirewallActionEnumPrompt, InternetFirewallActionEnumRbi:
		return true
	}
	return false
}

func (e InternetFirewallActionEnum) String() string {
	return string(e)
}

func (e *InternetFirewallActionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternetFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternetFirewallActionEnum", str)
	}
	return nil
}

func (e InternetFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPProtocol string

const (
	IPProtocolAny  IPProtocol = "ANY"
	IPProtocolICMP IPProtocol = "ICMP"
	IPProtocolTCP  IPProtocol = "TCP"
	// TCP or UDP
	IPProtocolTCPUDP IPProtocol = "TCP_UDP"
	IPProtocolUDP    IPProtocol = "UDP"
)

var AllIPProtocol = []IPProtocol{
	IPProtocolAny,
	IPProtocolICMP,
	IPProtocolTCP,
	IPProtocolTCPUDP,
	IPProtocolUDP,
}

func (e IPProtocol) IsValid() bool {
	switch e {
	case IPProtocolAny, IPProtocolICMP, IPProtocolTCP, IPProtocolTCPUDP, IPProtocolUDP:
		return true
	}
	return false
}

func (e IPProtocol) String() string {
	return string(e)
}

func (e *IPProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpProtocol", str)
	}
	return nil
}

func (e IPProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecCipher string

const (
	IPSecCipherAesCbc128 IPSecCipher = "AES_CBC_128"
	IPSecCipherAesCbc256 IPSecCipher = "AES_CBC_256"
	IPSecCipherAesGcm128 IPSecCipher = "AES_GCM_128"
	IPSecCipherAesGcm256 IPSecCipher = "AES_GCM_256"
	IPSecCipherAutomatic IPSecCipher = "AUTOMATIC"
	IPSecCipherDes3Cbc   IPSecCipher = "DES3_CBC"
	IPSecCipherNone      IPSecCipher = "NONE"
)

var AllIPSecCipher = []IPSecCipher{
	IPSecCipherAesCbc128,
	IPSecCipherAesCbc256,
	IPSecCipherAesGcm128,
	IPSecCipherAesGcm256,
	IPSecCipherAutomatic,
	IPSecCipherDes3Cbc,
	IPSecCipherNone,
}

func (e IPSecCipher) IsValid() bool {
	switch e {
	case IPSecCipherAesCbc128, IPSecCipherAesCbc256, IPSecCipherAesGcm128, IPSecCipherAesGcm256, IPSecCipherAutomatic, IPSecCipherDes3Cbc, IPSecCipherNone:
		return true
	}
	return false
}

func (e IPSecCipher) String() string {
	return string(e)
}

func (e *IPSecCipher) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecCipher(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecCipher", str)
	}
	return nil
}

func (e IPSecCipher) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecDHGroup string

const (
	IPSecDHGroupAutomatic    IPSecDHGroup = "AUTOMATIC"
	IPSecDHGroupDh14Modp2048 IPSecDHGroup = "DH_14_MODP2048"
	IPSecDHGroupDh15Modp3072 IPSecDHGroup = "DH_15_MODP3072"
	IPSecDHGroupDh16Modp4096 IPSecDHGroup = "DH_16_MODP4096"
	IPSecDHGroupDh19Ecp256   IPSecDHGroup = "DH_19_ECP256"
	IPSecDHGroupDh2Modp1024  IPSecDHGroup = "DH_2_MODP1024"
	IPSecDHGroupDh20Ecp384   IPSecDHGroup = "DH_20_ECP384"
	IPSecDHGroupDh21Ecp521   IPSecDHGroup = "DH_21_ECP521"
	IPSecDHGroupDh5Modp1536  IPSecDHGroup = "DH_5_MODP1536"
	IPSecDHGroupNone         IPSecDHGroup = "NONE"
)

var AllIPSecDHGroup = []IPSecDHGroup{
	IPSecDHGroupAutomatic,
	IPSecDHGroupDh14Modp2048,
	IPSecDHGroupDh15Modp3072,
	IPSecDHGroupDh16Modp4096,
	IPSecDHGroupDh19Ecp256,
	IPSecDHGroupDh2Modp1024,
	IPSecDHGroupDh20Ecp384,
	IPSecDHGroupDh21Ecp521,
	IPSecDHGroupDh5Modp1536,
	IPSecDHGroupNone,
}

func (e IPSecDHGroup) IsValid() bool {
	switch e {
	case IPSecDHGroupAutomatic, IPSecDHGroupDh14Modp2048, IPSecDHGroupDh15Modp3072, IPSecDHGroupDh16Modp4096, IPSecDHGroupDh19Ecp256, IPSecDHGroupDh2Modp1024, IPSecDHGroupDh20Ecp384, IPSecDHGroupDh21Ecp521, IPSecDHGroupDh5Modp1536, IPSecDHGroupNone:
		return true
	}
	return false
}

func (e IPSecDHGroup) String() string {
	return string(e)
}

func (e *IPSecDHGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecDHGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecDHGroup", str)
	}
	return nil
}

func (e IPSecDHGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecHash string

const (
	IPSecHashAutomatic IPSecHash = "AUTOMATIC"
	IPSecHashMd5       IPSecHash = "MD5"
	IPSecHashNone      IPSecHash = "NONE"
	IPSecHashSha1      IPSecHash = "SHA1"
	IPSecHashSha256    IPSecHash = "SHA256"
	IPSecHashSha384    IPSecHash = "SHA384"
	IPSecHashSha512    IPSecHash = "SHA512"
)

var AllIPSecHash = []IPSecHash{
	IPSecHashAutomatic,
	IPSecHashMd5,
	IPSecHashNone,
	IPSecHashSha1,
	IPSecHashSha256,
	IPSecHashSha384,
	IPSecHashSha512,
}

func (e IPSecHash) IsValid() bool {
	switch e {
	case IPSecHashAutomatic, IPSecHashMd5, IPSecHashNone, IPSecHashSha1, IPSecHashSha256, IPSecHashSha384, IPSecHashSha512:
		return true
	}
	return false
}

func (e IPSecHash) String() string {
	return string(e)
}

func (e *IPSecHash) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecHash(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecHash", str)
	}
	return nil
}

func (e IPSecHash) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for license plan type (site license, service license, etc...)
type LicensePlan string

const (
	LicensePlanCommercial LicensePlan = "COMMERCIAL"
	LicensePlanTrial      LicensePlan = "TRIAL"
)

var AllLicensePlan = []LicensePlan{
	LicensePlanCommercial,
	LicensePlanTrial,
}

func (e LicensePlan) IsValid() bool {
	switch e {
	case LicensePlanCommercial, LicensePlanTrial:
		return true
	}
	return false
}

func (e LicensePlan) String() string {
	return string(e)
}

func (e *LicensePlan) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicensePlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicensePlan", str)
	}
	return nil
}

func (e LicensePlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LicenseSku string

const (
	// Cato Anti Malware (legacy) service SKU
	LicenseSkuCatoAntiMalware LicenseSku = "CATO_ANTI_MALWARE"
	// Cato Anti Malware Next Generation (legacy) service SKU
	LicenseSkuCatoAntiMalwareNg LicenseSku = "CATO_ANTI_MALWARE_NG"
	// Cato CASB service SKU
	LicenseSkuCatoCasb LicenseSku = "CATO_CASB"
	// Cato datalake Group SKU
	LicenseSkuCatoDatalake LicenseSku = "CATO_DATALAKE"
	// 12 months data retention SKU
	LicenseSkuCatoDatalake12m LicenseSku = "CATO_DATALAKE_12M"
	// 3 months data retention SKU
	LicenseSkuCatoDatalake3m LicenseSku = "CATO_DATALAKE_3M"
	// 6 months data retention SKU
	LicenseSkuCatoDatalake6m LicenseSku = "CATO_DATALAKE_6M"
	// Cato DEM service SKU
	LicenseSkuCatoDem LicenseSku = "CATO_DEM"
	// Cato DEM Pro service SKU
	LicenseSkuCatoDemPro LicenseSku = "CATO_DEM_PRO"
	// Cato DLP service SKU
	LicenseSkuCatoDlp LicenseSku = "CATO_DLP"
	// Cato EPP service SKU
	LicenseSkuCatoEpp LicenseSku = "CATO_EPP"
	// Cato ILMM service SKU
	LicenseSkuCatoIlmm LicenseSku = "CATO_ILMM"
	// Public IPs SKU
	LicenseSkuCatoIPAdd LicenseSku = "CATO_IP_ADD"
	// Cato IPS (legacy) service SKU
	LicenseSkuCatoIPS LicenseSku = "CATO_IPS"
	// Cato MDR (XDR Pro) service SKU
	LicenseSkuCatoMdr LicenseSku = "CATO_MDR"
	// Cato NOCaaS service SKU
	LicenseSkuCatoNocaasHf LicenseSku = "CATO_NOCAAS_HF"
	// Site pooled bandwidth SASE SKU
	LicenseSkuCatoPb LicenseSku = "CATO_PB"
	// Site pooled bandwidth SSE SKU
	LicenseSkuCatoPbSse LicenseSku = "CATO_PB_SSE"
	// Cato Remote Browser Isolation (RBI) service SKU
	LicenseSkuCatoRbi LicenseSku = "CATO_RBI"
	// Cato SAAS Group SKU
	LicenseSkuCatoSaas            LicenseSku = "CATO_SAAS"
	LicenseSkuCatoSaasSecurityAPI LicenseSku = "CATO_SAAS_SECURITY_API"
	// Cato SAAS Security API with more than two Applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIAllApps LicenseSku = "CATO_SAAS_SECURITY_API_ALL_APPS"
	// Cato SAAS Security API with one application integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIOneApp LicenseSku = "CATO_SAAS_SECURITY_API_ONE_APP"
	// Cato SAAS Security API with two applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPITwoApps LicenseSku = "CATO_SAAS_SECURITY_API_TWO_APPS"
	// Site bandwidth SASE SKU
	LicenseSkuCatoSite LicenseSku = "CATO_SITE"
	// Site bandwidth SSE SKU
	LicenseSkuCatoSseSite LicenseSku = "CATO_SSE_SITE"
	// Cato Threat Prevention (legacy) service SKU
	LicenseSkuCatoThreatPrevention LicenseSku = "CATO_THREAT_PREVENTION"
	// Cato XDR service SKU
	LicenseSkuCatoXdrPro LicenseSku = "CATO_XDR_PRO"
	// ZTNA remote users SKU
	LicenseSkuCatoZtnaUsers LicenseSku = "CATO_ZTNA_USERS"
	// ZTNA remote users SKU
	LicenseSkuMobileUsers LicenseSku = "MOBILE_USERS"
)

var AllLicenseSku = []LicenseSku{
	LicenseSkuCatoAntiMalware,
	LicenseSkuCatoAntiMalwareNg,
	LicenseSkuCatoCasb,
	LicenseSkuCatoDatalake,
	LicenseSkuCatoDatalake12m,
	LicenseSkuCatoDatalake3m,
	LicenseSkuCatoDatalake6m,
	LicenseSkuCatoDem,
	LicenseSkuCatoDemPro,
	LicenseSkuCatoDlp,
	LicenseSkuCatoEpp,
	LicenseSkuCatoIlmm,
	LicenseSkuCatoIPAdd,
	LicenseSkuCatoIPS,
	LicenseSkuCatoMdr,
	LicenseSkuCatoNocaasHf,
	LicenseSkuCatoPb,
	LicenseSkuCatoPbSse,
	LicenseSkuCatoRbi,
	LicenseSkuCatoSaas,
	LicenseSkuCatoSaasSecurityAPI,
	LicenseSkuCatoSaasSecurityAPIAllApps,
	LicenseSkuCatoSaasSecurityAPIOneApp,
	LicenseSkuCatoSaasSecurityAPITwoApps,
	LicenseSkuCatoSite,
	LicenseSkuCatoSseSite,
	LicenseSkuCatoThreatPrevention,
	LicenseSkuCatoXdrPro,
	LicenseSkuCatoZtnaUsers,
	LicenseSkuMobileUsers,
}

func (e LicenseSku) IsValid() bool {
	switch e {
	case LicenseSkuCatoAntiMalware, LicenseSkuCatoAntiMalwareNg, LicenseSkuCatoCasb, LicenseSkuCatoDatalake, LicenseSkuCatoDatalake12m, LicenseSkuCatoDatalake3m, LicenseSkuCatoDatalake6m, LicenseSkuCatoDem, LicenseSkuCatoDemPro, LicenseSkuCatoDlp, LicenseSkuCatoEpp, LicenseSkuCatoIlmm, LicenseSkuCatoIPAdd, LicenseSkuCatoIPS, LicenseSkuCatoMdr, LicenseSkuCatoNocaasHf, LicenseSkuCatoPb, LicenseSkuCatoPbSse, LicenseSkuCatoRbi, LicenseSkuCatoSaas, LicenseSkuCatoSaasSecurityAPI, LicenseSkuCatoSaasSecurityAPIAllApps, LicenseSkuCatoSaasSecurityAPIOneApp, LicenseSkuCatoSaasSecurityAPITwoApps, LicenseSkuCatoSite, LicenseSkuCatoSseSite, LicenseSkuCatoThreatPrevention, LicenseSkuCatoXdrPro, LicenseSkuCatoZtnaUsers, LicenseSkuMobileUsers:
		return true
	}
	return false
}

func (e LicenseSku) String() string {
	return string(e)
}

func (e *LicenseSku) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseSku(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseSku", str)
	}
	return nil
}

func (e LicenseSku) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for account plan status – the current license status within the license lifecycle
type LicenseStatus string

const (
	// A license that is currently active
	LicenseStatusActive LicenseStatus = "ACTIVE"
	// An expired license is no longer active
	LicenseStatusDisabled LicenseStatus = "DISABLED"
	// A license in a grace period
	LicenseStatusLocked LicenseStatus = "LOCKED"
	// An existing license with a future start date that is not currently active
	LicenseStatusScheduled LicenseStatus = "SCHEDULED"
	// A license that is active before its start date, for partners and customers to verify the relevant configurations
	LicenseStatusStaging LicenseStatus = "STAGING"
)

var AllLicenseStatus = []LicenseStatus{
	LicenseStatusActive,
	LicenseStatusDisabled,
	LicenseStatusLocked,
	LicenseStatusScheduled,
	LicenseStatusStaging,
}

func (e LicenseStatus) IsValid() bool {
	switch e {
	case LicenseStatusActive, LicenseStatusDisabled, LicenseStatusLocked, LicenseStatusScheduled, LicenseStatusStaging:
		return true
	}
	return false
}

func (e LicenseStatus) String() string {
	return string(e)
}

func (e *LicenseStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseStatus", str)
	}
	return nil
}

func (e LicenseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkConfigPrecedenceEnum string

const (
	LinkConfigPrecedenceEnumActive     LinkConfigPrecedenceEnum = "ACTIVE"
	LinkConfigPrecedenceEnumLastResort LinkConfigPrecedenceEnum = "LAST_RESORT"
	LinkConfigPrecedenceEnumPassive    LinkConfigPrecedenceEnum = "PASSIVE"
)

var AllLinkConfigPrecedenceEnum = []LinkConfigPrecedenceEnum{
	LinkConfigPrecedenceEnumActive,
	LinkConfigPrecedenceEnumLastResort,
	LinkConfigPrecedenceEnumPassive,
}

func (e LinkConfigPrecedenceEnum) IsValid() bool {
	switch e {
	case LinkConfigPrecedenceEnumActive, LinkConfigPrecedenceEnumLastResort, LinkConfigPrecedenceEnumPassive:
		return true
	}
	return false
}

func (e LinkConfigPrecedenceEnum) String() string {
	return string(e)
}

func (e *LinkConfigPrecedenceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkConfigPrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkConfigPrecedenceEnum", str)
	}
	return nil
}

func (e LinkConfigPrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkQualityIssueTypeEnum string

const (
	LinkQualityIssueTypeEnumCongestion LinkQualityIssueTypeEnum = "CONGESTION"
	LinkQualityIssueTypeEnumDistance   LinkQualityIssueTypeEnum = "DISTANCE"
	LinkQualityIssueTypeEnumJitter     LinkQualityIssueTypeEnum = "JITTER"
	LinkQualityIssueTypeEnumPacketLoss LinkQualityIssueTypeEnum = "PACKET_LOSS"
)

var AllLinkQualityIssueTypeEnum = []LinkQualityIssueTypeEnum{
	LinkQualityIssueTypeEnumCongestion,
	LinkQualityIssueTypeEnumDistance,
	LinkQualityIssueTypeEnumJitter,
	LinkQualityIssueTypeEnumPacketLoss,
}

func (e LinkQualityIssueTypeEnum) IsValid() bool {
	switch e {
	case LinkQualityIssueTypeEnumCongestion, LinkQualityIssueTypeEnumDistance, LinkQualityIssueTypeEnumJitter, LinkQualityIssueTypeEnumPacketLoss:
		return true
	}
	return false
}

func (e LinkQualityIssueTypeEnum) String() string {
	return string(e)
}

func (e *LinkQualityIssueTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkQualityIssueTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkQualityIssueTypeEnum", str)
	}
	return nil
}

func (e LinkQualityIssueTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkStatusEnum string

const (
	LinkStatusEnumActive  LinkStatusEnum = "ACTIVE"
	LinkStatusEnumPassive LinkStatusEnum = "PASSIVE"
)

var AllLinkStatusEnum = []LinkStatusEnum{
	LinkStatusEnumActive,
	LinkStatusEnumPassive,
}

func (e LinkStatusEnum) IsValid() bool {
	switch e {
	case LinkStatusEnumActive, LinkStatusEnumPassive:
		return true
	}
	return false
}

func (e LinkStatusEnum) String() string {
	return string(e)
}

func (e *LinkStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkStatusEnum", str)
	}
	return nil
}

func (e LinkStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LookupFilterType string

const (
	// Custom filter for country, used by city and state entityLookup
	LookupFilterTypeCountry LookupFilterType = "country"
	// Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByAltWan LookupFilterType = "filterByAltWan"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByBackhaulingGw LookupFilterType = "filterByBackhaulingGW"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
	// "SOCKET_X1500",
	// "SOCKET_X1600",
	// "SOCKET_X1700",
	// "VSOCKET_VGX_ESX",
	// "VSOCKET_VGX_AWS"
	// "VSOCKET_VGX_AZURE"
	// "SOCKET_X1600_LTE",
	LookupFilterTypeFilterByConnectionType LookupFilterType = "filterByConnectionType"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
	// "SOCKET",
	// "IPSEC",
	// "vSOCKET",
	// "PHYSICAL_SOCKET"
	LookupFilterTypeFilterByConnectionTypeFamily LookupFilterType = "filterByConnectionTypeFamily"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByOffCloudTransportEnabled LookupFilterType = "filterByOffCloudTransportEnabled"
	// Custom filter for state used by city entityLookup
	LookupFilterTypeState LookupFilterType = "state"
)

var AllLookupFilterType = []LookupFilterType{
	LookupFilterTypeCountry,
	LookupFilterTypeFilterByAltWan,
	LookupFilterTypeFilterByBackhaulingGw,
	LookupFilterTypeFilterByConnectionType,
	LookupFilterTypeFilterByConnectionTypeFamily,
	LookupFilterTypeFilterByOffCloudTransportEnabled,
	LookupFilterTypeState,
}

func (e LookupFilterType) IsValid() bool {
	switch e {
	case LookupFilterTypeCountry, LookupFilterTypeFilterByAltWan, LookupFilterTypeFilterByBackhaulingGw, LookupFilterTypeFilterByConnectionType, LookupFilterTypeFilterByConnectionTypeFamily, LookupFilterTypeFilterByOffCloudTransportEnabled, LookupFilterTypeState:
		return true
	}
	return false
}

func (e LookupFilterType) String() string {
	return string(e)
}

func (e *LookupFilterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LookupFilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LookupFilterType", str)
	}
	return nil
}

func (e LookupFilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsAlertStatus string

const (
	MsAlertStatusInProgress MsAlertStatus = "IN_PROGRESS"
	MsAlertStatusNew        MsAlertStatus = "NEW"
	MsAlertStatusResolved   MsAlertStatus = "RESOLVED"
)

var AllMsAlertStatus = []MsAlertStatus{
	MsAlertStatusInProgress,
	MsAlertStatusNew,
	MsAlertStatusResolved,
}

func (e MsAlertStatus) IsValid() bool {
	switch e {
	case MsAlertStatusInProgress, MsAlertStatusNew, MsAlertStatusResolved:
		return true
	}
	return false
}

func (e MsAlertStatus) String() string {
	return string(e)
}

func (e *MsAlertStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsAlertStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsAlertStatus", str)
	}
	return nil
}

func (e MsAlertStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsResourceVerdictEnum string

const (
	MsResourceVerdictEnumBenign        MsResourceVerdictEnum = "Benign"
	MsResourceVerdictEnumInformational MsResourceVerdictEnum = "Informational"
	MsResourceVerdictEnumMalicious     MsResourceVerdictEnum = "Malicious"
	MsResourceVerdictEnumSuspicious    MsResourceVerdictEnum = "Suspicious"
)

var AllMsResourceVerdictEnum = []MsResourceVerdictEnum{
	MsResourceVerdictEnumBenign,
	MsResourceVerdictEnumInformational,
	MsResourceVerdictEnumMalicious,
	MsResourceVerdictEnumSuspicious,
}

func (e MsResourceVerdictEnum) IsValid() bool {
	switch e {
	case MsResourceVerdictEnumBenign, MsResourceVerdictEnumInformational, MsResourceVerdictEnumMalicious, MsResourceVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e MsResourceVerdictEnum) String() string {
	return string(e)
}

func (e *MsResourceVerdictEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsResourceVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsResourceVerdictEnum", str)
	}
	return nil
}

func (e MsResourceVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkEventSourceEnum string

const (
	NetworkEventSourceEnumBgpSession NetworkEventSourceEnum = "BGP_SESSION"
	NetworkEventSourceEnumDevice     NetworkEventSourceEnum = "DEVICE"
	NetworkEventSourceEnumHost       NetworkEventSourceEnum = "HOST"
	NetworkEventSourceEnumIsp        NetworkEventSourceEnum = "ISP"
	NetworkEventSourceEnumLink       NetworkEventSourceEnum = "LINK"
	NetworkEventSourceEnumPop        NetworkEventSourceEnum = "POP"
	NetworkEventSourceEnumSite       NetworkEventSourceEnum = "SITE"
)

var AllNetworkEventSourceEnum = []NetworkEventSourceEnum{
	NetworkEventSourceEnumBgpSession,
	NetworkEventSourceEnumDevice,
	NetworkEventSourceEnumHost,
	NetworkEventSourceEnumIsp,
	NetworkEventSourceEnumLink,
	NetworkEventSourceEnumPop,
	NetworkEventSourceEnumSite,
}

func (e NetworkEventSourceEnum) IsValid() bool {
	switch e {
	case NetworkEventSourceEnumBgpSession, NetworkEventSourceEnumDevice, NetworkEventSourceEnumHost, NetworkEventSourceEnumIsp, NetworkEventSourceEnumLink, NetworkEventSourceEnumPop, NetworkEventSourceEnumSite:
		return true
	}
	return false
}

func (e NetworkEventSourceEnum) String() string {
	return string(e)
}

func (e *NetworkEventSourceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkEventSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkEventSourceEnum", str)
	}
	return nil
}

func (e NetworkEventSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkXDREventTypeEnum string

const (
	NetworkXDREventTypeEnumDegraded NetworkXDREventTypeEnum = "DEGRADED"
	NetworkXDREventTypeEnumInsight  NetworkXDREventTypeEnum = "INSIGHT"
	NetworkXDREventTypeEnumResolved NetworkXDREventTypeEnum = "RESOLVED"
)

var AllNetworkXDREventTypeEnum = []NetworkXDREventTypeEnum{
	NetworkXDREventTypeEnumDegraded,
	NetworkXDREventTypeEnumInsight,
	NetworkXDREventTypeEnumResolved,
}

func (e NetworkXDREventTypeEnum) IsValid() bool {
	switch e {
	case NetworkXDREventTypeEnumDegraded, NetworkXDREventTypeEnumInsight, NetworkXDREventTypeEnumResolved:
		return true
	}
	return false
}

func (e NetworkXDREventTypeEnum) String() string {
	return string(e)
}

func (e *NetworkXDREventTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkXDREventTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkXDREventTypeEnum", str)
	}
	return nil
}

func (e NetworkXDREventTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObjectRefBy string

const (
	ObjectRefByID   ObjectRefBy = "ID"
	ObjectRefByName ObjectRefBy = "NAME"
)

var AllObjectRefBy = []ObjectRefBy{
	ObjectRefByID,
	ObjectRefByName,
}

func (e ObjectRefBy) IsValid() bool {
	switch e {
	case ObjectRefByID, ObjectRefByName:
		return true
	}
	return false
}

func (e ObjectRefBy) String() string {
	return string(e)
}

func (e *ObjectRefBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectRefBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectRefBy", str)
	}
	return nil
}

func (e ObjectRefBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OnboardingStatusEnum string

const (
	OnboardingStatusEnumCanBeOnboarded   OnboardingStatusEnum = "CAN_BE_ONBOARDED"
	OnboardingStatusEnumInsufficientInfo OnboardingStatusEnum = "INSUFFICIENT_INFO"
	OnboardingStatusEnumOnboarded        OnboardingStatusEnum = "ONBOARDED"
)

var AllOnboardingStatusEnum = []OnboardingStatusEnum{
	OnboardingStatusEnumCanBeOnboarded,
	OnboardingStatusEnumInsufficientInfo,
	OnboardingStatusEnumOnboarded,
}

func (e OnboardingStatusEnum) IsValid() bool {
	switch e {
	case OnboardingStatusEnumCanBeOnboarded, OnboardingStatusEnumInsufficientInfo, OnboardingStatusEnumOnboarded:
		return true
	}
	return false
}

func (e OnboardingStatusEnum) String() string {
	return string(e)
}

func (e *OnboardingStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingStatusEnum", str)
	}
	return nil
}

func (e OnboardingStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystem string

const (
	OperatingSystemAndroid  OperatingSystem = "ANDROID"
	OperatingSystemEmbedded OperatingSystem = "EMBEDDED"
	OperatingSystemIos      OperatingSystem = "IOS"
	OperatingSystemLinux    OperatingSystem = "LINUX"
	OperatingSystemMacos    OperatingSystem = "MACOS"
	OperatingSystemWindows  OperatingSystem = "WINDOWS"
)

var AllOperatingSystem = []OperatingSystem{
	OperatingSystemAndroid,
	OperatingSystemEmbedded,
	OperatingSystemIos,
	OperatingSystemLinux,
	OperatingSystemMacos,
	OperatingSystemWindows,
}

func (e OperatingSystem) IsValid() bool {
	switch e {
	case OperatingSystemAndroid, OperatingSystemEmbedded, OperatingSystemIos, OperatingSystemLinux, OperatingSystemMacos, OperatingSystemWindows:
		return true
	}
	return false
}

func (e OperatingSystem) String() string {
	return string(e)
}

func (e *OperatingSystem) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystem", str)
	}
	return nil
}

func (e OperatingSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationalStatus string

const (
	// Passing traffic
	OperationalStatusActive OperationalStatus = "active"
	// Disabled in the Cato Management Application
	OperationalStatusDisabled OperationalStatus = "disabled"
	// License has expired for this site and you can't configure it
	OperationalStatusLocked OperationalStatus = "locked"
	// After you create the site before it is connected to the Cato Cloud
	OperationalStatusNew OperationalStatus = "new"
	// For VPN users only
	OperationalStatusPendingCodeGeneration OperationalStatus = "pending_code_generation"
	// For VPN users only
	OperationalStatusPendingMfaConfiguration OperationalStatus = "pending_mfa_configuration"
	// For VPN users only
	OperationalStatusPendingUserConfiguration OperationalStatus = "pending_user_configuration"
)

var AllOperationalStatus = []OperationalStatus{
	OperationalStatusActive,
	OperationalStatusDisabled,
	OperationalStatusLocked,
	OperationalStatusNew,
	OperationalStatusPendingCodeGeneration,
	OperationalStatusPendingMfaConfiguration,
	OperationalStatusPendingUserConfiguration,
}

func (e OperationalStatus) IsValid() bool {
	switch e {
	case OperationalStatusActive, OperationalStatusDisabled, OperationalStatusLocked, OperationalStatusNew, OperationalStatusPendingCodeGeneration, OperationalStatusPendingMfaConfiguration, OperationalStatusPendingUserConfiguration:
		return true
	}
	return false
}

func (e OperationalStatus) String() string {
	return string(e)
}

func (e *OperationalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationalStatus", str)
	}
	return nil
}

func (e OperationalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PeriodType string

const (
	// traffic was seen
	PeriodTypeActive PeriodType = "active"
	// some packets were discarded after queue timeout
	PeriodTypeCongested PeriodType = "congested"
	// unspecified period type
	PeriodTypeGeneric PeriodType = "generic"
	// multiple last mile destinations measured large latency (greater than 500ms)
	PeriodTypeLastmileLatency PeriodType = "lastmileLatency"
	// multiple last mile destinations measured packet loss
	PeriodTypeLastmilePacketLoss PeriodType = "lastmilePacketLoss"
	// missing data
	PeriodTypeMissingData PeriodType = "missingData"
	// some packets were queued
	PeriodTypeOverlowed PeriodType = "overlowed"
	// packet loss connectivity issue
	PeriodTypePacketLoss PeriodType = "packetLoss"
	// interface in standby mode
	PeriodTypePassiveLink PeriodType = "passiveLink"
	// period connected to specific pop instance
	PeriodTypePop PeriodType = "pop"
)

var AllPeriodType = []PeriodType{
	PeriodTypeActive,
	PeriodTypeCongested,
	PeriodTypeGeneric,
	PeriodTypeLastmileLatency,
	PeriodTypeLastmilePacketLoss,
	PeriodTypeMissingData,
	PeriodTypeOverlowed,
	PeriodTypePacketLoss,
	PeriodTypePassiveLink,
	PeriodTypePop,
}

func (e PeriodType) IsValid() bool {
	switch e {
	case PeriodTypeActive, PeriodTypeCongested, PeriodTypeGeneric, PeriodTypeLastmileLatency, PeriodTypeLastmilePacketLoss, PeriodTypeMissingData, PeriodTypeOverlowed, PeriodTypePacketLoss, PeriodTypePassiveLink, PeriodTypePop:
		return true
	}
	return false
}

func (e PeriodType) String() string {
	return string(e)
}

func (e *PeriodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeriodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeriodType", str)
	}
	return nil
}

func (e PeriodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of time range a rule is active
type PolicyActiveOnEnum string

const (
	PolicyActiveOnEnumAlways          PolicyActiveOnEnum = "ALWAYS"
	PolicyActiveOnEnumCustomRecurring PolicyActiveOnEnum = "CUSTOM_RECURRING"
	PolicyActiveOnEnumCustomTimeframe PolicyActiveOnEnum = "CUSTOM_TIMEFRAME"
	PolicyActiveOnEnumWorkingHours    PolicyActiveOnEnum = "WORKING_HOURS"
)

var AllPolicyActiveOnEnum = []PolicyActiveOnEnum{
	PolicyActiveOnEnumAlways,
	PolicyActiveOnEnumCustomRecurring,
	PolicyActiveOnEnumCustomTimeframe,
	PolicyActiveOnEnumWorkingHours,
}

func (e PolicyActiveOnEnum) IsValid() bool {
	switch e {
	case PolicyActiveOnEnumAlways, PolicyActiveOnEnumCustomRecurring, PolicyActiveOnEnumCustomTimeframe, PolicyActiveOnEnumWorkingHours:
		return true
	}
	return false
}

func (e PolicyActiveOnEnum) String() string {
	return string(e)
}

func (e *PolicyActiveOnEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyActiveOnEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyActiveOnEnum", str)
	}
	return nil
}

func (e PolicyActiveOnEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Attributes describing the rule state or type
type PolicyElementPropertiesEnum string

const (
	// New (added) rule
	PolicyElementPropertiesEnumAdded PolicyElementPropertiesEnum = "ADDED"
	// An object can not be moved, or referenced when moving other objects.
	// However its properties and content can be modified.
	PolicyElementPropertiesEnumAnchored PolicyElementPropertiesEnum = "ANCHORED"
	// A rule locked for changes by other admins
	PolicyElementPropertiesEnumLocked PolicyElementPropertiesEnum = "LOCKED"
	// A rule moved to a different position
	PolicyElementPropertiesEnumMoved PolicyElementPropertiesEnum = "MOVED"
	// Removed (deleted) rule
	PolicyElementPropertiesEnumRemoved PolicyElementPropertiesEnum = "REMOVED"
	// A pre-defined (system) rule that cannot be modified or removed
	PolicyElementPropertiesEnumSystem PolicyElementPropertiesEnum = "SYSTEM"
	// Updated (modified) existing rule
	PolicyElementPropertiesEnumUpdated PolicyElementPropertiesEnum = "UPDATED"
)

var AllPolicyElementPropertiesEnum = []PolicyElementPropertiesEnum{
	PolicyElementPropertiesEnumAdded,
	PolicyElementPropertiesEnumAnchored,
	PolicyElementPropertiesEnumLocked,
	PolicyElementPropertiesEnumMoved,
	PolicyElementPropertiesEnumRemoved,
	PolicyElementPropertiesEnumSystem,
	PolicyElementPropertiesEnumUpdated,
}

func (e PolicyElementPropertiesEnum) IsValid() bool {
	switch e {
	case PolicyElementPropertiesEnumAdded, PolicyElementPropertiesEnumAnchored, PolicyElementPropertiesEnumLocked, PolicyElementPropertiesEnumMoved, PolicyElementPropertiesEnumRemoved, PolicyElementPropertiesEnumSystem, PolicyElementPropertiesEnumUpdated:
		return true
	}
	return false
}

func (e PolicyElementPropertiesEnum) String() string {
	return string(e)
}

func (e *PolicyElementPropertiesEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyElementPropertiesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyElementPropertiesEnum", str)
	}
	return nil
}

func (e PolicyElementPropertiesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the status of a policy mutation
type PolicyMutationStatus string

const (
	PolicyMutationStatusFailure PolicyMutationStatus = "FAILURE"
	PolicyMutationStatusSuccess PolicyMutationStatus = "SUCCESS"
)

var AllPolicyMutationStatus = []PolicyMutationStatus{
	PolicyMutationStatusFailure,
	PolicyMutationStatusSuccess,
}

func (e PolicyMutationStatus) IsValid() bool {
	switch e {
	case PolicyMutationStatusFailure, PolicyMutationStatusSuccess:
		return true
	}
	return false
}

func (e PolicyMutationStatus) String() string {
	return string(e)
}

func (e *PolicyMutationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyMutationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyMutationStatus", str)
	}
	return nil
}

func (e PolicyMutationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of a policy revision
type PolicyRevisionType string

const (
	PolicyRevisionTypePrivate PolicyRevisionType = "PRIVATE"
	PolicyRevisionTypePublic  PolicyRevisionType = "PUBLIC"
)

var AllPolicyRevisionType = []PolicyRevisionType{
	PolicyRevisionTypePrivate,
	PolicyRevisionTypePublic,
}

func (e PolicyRevisionType) IsValid() bool {
	switch e {
	case PolicyRevisionTypePrivate, PolicyRevisionTypePublic:
		return true
	}
	return false
}

func (e PolicyRevisionType) String() string {
	return string(e)
}

func (e *PolicyRevisionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRevisionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRevisionType", str)
	}
	return nil
}

func (e PolicyRevisionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the position of a rule within a policy
type PolicyRulePositionEnum string

const (
	// The rule position is after the pre-existing specified rule
	PolicyRulePositionEnumAfterRule PolicyRulePositionEnum = "AFTER_RULE"
	// The rule position is before the pre-existing specified rule
	PolicyRulePositionEnumBeforeRule PolicyRulePositionEnum = "BEFORE_RULE"
	// The rule position is immediately after the system rules (first non-system rule)
	PolicyRulePositionEnumFirstInPolicy PolicyRulePositionEnum = "FIRST_IN_POLICY"
	// The rule position is first in the specified section
	PolicyRulePositionEnumFirstInSection PolicyRulePositionEnum = "FIRST_IN_SECTION"
	// The rule position is last in the policy
	PolicyRulePositionEnumLastInPolicy PolicyRulePositionEnum = "LAST_IN_POLICY"
	// The rule position is last in the specified section
	PolicyRulePositionEnumLastInSection PolicyRulePositionEnum = "LAST_IN_SECTION"
)

var AllPolicyRulePositionEnum = []PolicyRulePositionEnum{
	PolicyRulePositionEnumAfterRule,
	PolicyRulePositionEnumBeforeRule,
	PolicyRulePositionEnumFirstInPolicy,
	PolicyRulePositionEnumFirstInSection,
	PolicyRulePositionEnumLastInPolicy,
	PolicyRulePositionEnumLastInSection,
}

func (e PolicyRulePositionEnum) IsValid() bool {
	switch e {
	case PolicyRulePositionEnumAfterRule, PolicyRulePositionEnumBeforeRule, PolicyRulePositionEnumFirstInPolicy, PolicyRulePositionEnumFirstInSection, PolicyRulePositionEnumLastInPolicy, PolicyRulePositionEnumLastInSection:
		return true
	}
	return false
}

func (e PolicyRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicyRulePositionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRulePositionEnum", str)
	}
	return nil
}

func (e PolicyRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the frequency of an alert event for a rule
type PolicyRuleTrackingFrequencyEnum string

const (
	PolicyRuleTrackingFrequencyEnumDaily     PolicyRuleTrackingFrequencyEnum = "DAILY"
	PolicyRuleTrackingFrequencyEnumHourly    PolicyRuleTrackingFrequencyEnum = "HOURLY"
	PolicyRuleTrackingFrequencyEnumImmediate PolicyRuleTrackingFrequencyEnum = "IMMEDIATE"
	PolicyRuleTrackingFrequencyEnumWeekly    PolicyRuleTrackingFrequencyEnum = "WEEKLY"
)

var AllPolicyRuleTrackingFrequencyEnum = []PolicyRuleTrackingFrequencyEnum{
	PolicyRuleTrackingFrequencyEnumDaily,
	PolicyRuleTrackingFrequencyEnumHourly,
	PolicyRuleTrackingFrequencyEnumImmediate,
	PolicyRuleTrackingFrequencyEnumWeekly,
}

func (e PolicyRuleTrackingFrequencyEnum) IsValid() bool {
	switch e {
	case PolicyRuleTrackingFrequencyEnumDaily, PolicyRuleTrackingFrequencyEnumHourly, PolicyRuleTrackingFrequencyEnumImmediate, PolicyRuleTrackingFrequencyEnumWeekly:
		return true
	}
	return false
}

func (e PolicyRuleTrackingFrequencyEnum) String() string {
	return string(e)
}

func (e *PolicyRuleTrackingFrequencyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRuleTrackingFrequencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRuleTrackingFrequencyEnum", str)
	}
	return nil
}

func (e PolicyRuleTrackingFrequencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicySectionPositionEnum string

const (
	PolicySectionPositionEnumAfterSection  PolicySectionPositionEnum = "AFTER_SECTION"
	PolicySectionPositionEnumBeforeSection PolicySectionPositionEnum = "BEFORE_SECTION"
	PolicySectionPositionEnumLastInPolicy  PolicySectionPositionEnum = "LAST_IN_POLICY"
)

var AllPolicySectionPositionEnum = []PolicySectionPositionEnum{
	PolicySectionPositionEnumAfterSection,
	PolicySectionPositionEnumBeforeSection,
	PolicySectionPositionEnumLastInPolicy,
}

func (e PolicySectionPositionEnum) IsValid() bool {
	switch e {
	case PolicySectionPositionEnumAfterSection, PolicySectionPositionEnumBeforeSection, PolicySectionPositionEnumLastInPolicy:
		return true
	}
	return false
}

func (e PolicySectionPositionEnum) String() string {
	return string(e)
}

func (e *PolicySectionPositionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySectionPositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySectionPositionEnum", str)
	}
	return nil
}

func (e PolicySectionPositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the state of a policy
type PolicyToggleState string

const (
	PolicyToggleStateDisabled PolicyToggleState = "DISABLED"
	PolicyToggleStateEnabled  PolicyToggleState = "ENABLED"
)

var AllPolicyToggleState = []PolicyToggleState{
	PolicyToggleStateDisabled,
	PolicyToggleStateEnabled,
}

func (e PolicyToggleState) IsValid() bool {
	switch e {
	case PolicyToggleStateDisabled, PolicyToggleStateEnabled:
		return true
	}
	return false
}

func (e PolicyToggleState) String() string {
	return string(e)
}

func (e *PolicyToggleState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyToggleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyToggleState", str)
	}
	return nil
}

func (e PolicyToggleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProtoType string

const (
	ProtoTypeCrossConnect   ProtoType = "CROSS_CONNECT"
	ProtoTypeIpsecClient    ProtoType = "IPSEC_CLIENT"
	ProtoTypeIpsecHost      ProtoType = "IPSEC_HOST"
	ProtoTypeIpsecV2        ProtoType = "IPSEC_V2"
	ProtoTypeSocketAws1500  ProtoType = "SOCKET_AWS1500"
	ProtoTypeSocketAz1500   ProtoType = "SOCKET_AZ1500"
	ProtoTypeSocketEsx1500  ProtoType = "SOCKET_ESX1500"
	ProtoTypeSocketX1500    ProtoType = "SOCKET_X1500"
	ProtoTypeSocketX1600    ProtoType = "SOCKET_X1600"
	ProtoTypeSocketX1600Lte ProtoType = "SOCKET_X1600_LTE"
	ProtoTypeSocketX1700    ProtoType = "SOCKET_X1700"
	ProtoTypeVsocketVgx     ProtoType = "VSOCKET_VGX"
)

var AllProtoType = []ProtoType{
	ProtoTypeCrossConnect,
	ProtoTypeIpsecClient,
	ProtoTypeIpsecHost,
	ProtoTypeIpsecV2,
	ProtoTypeSocketAws1500,
	ProtoTypeSocketAz1500,
	ProtoTypeSocketEsx1500,
	ProtoTypeSocketX1500,
	ProtoTypeSocketX1600,
	ProtoTypeSocketX1600Lte,
	ProtoTypeSocketX1700,
	ProtoTypeVsocketVgx,
}

func (e ProtoType) IsValid() bool {
	switch e {
	case ProtoTypeCrossConnect, ProtoTypeIpsecClient, ProtoTypeIpsecHost, ProtoTypeIpsecV2, ProtoTypeSocketAws1500, ProtoTypeSocketAz1500, ProtoTypeSocketEsx1500, ProtoTypeSocketX1500, ProtoTypeSocketX1600, ProtoTypeSocketX1600Lte, ProtoTypeSocketX1700, ProtoTypeVsocketVgx:
		return true
	}
	return false
}

func (e ProtoType) String() string {
	return string(e)
}

func (e *ProtoType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtoType", str)
	}
	return nil
}

func (e ProtoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
type Regionality string

const (
	// Global traffic going outside of the region
	RegionalityGlobal Regionality = "GLOBAL"
	// Site traffic within the region
	RegionalityRegional Regionality = "REGIONAL"
)

var AllRegionality = []Regionality{
	RegionalityGlobal,
	RegionalityRegional,
}

func (e Regionality) IsValid() bool {
	switch e {
	case RegionalityGlobal, RegionalityRegional:
		return true
	}
	return false
}

func (e Regionality) String() string {
	return string(e)
}

func (e *Regionality) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Regionality(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Regionality", str)
	}
	return nil
}

func (e Regionality) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RemediationStatusEnum string

const (
	RemediationStatusEnumBlocked           RemediationStatusEnum = "BLOCKED"
	RemediationStatusEnumClean             RemediationStatusEnum = "CLEAN"
	RemediationStatusEnumDeleted           RemediationStatusEnum = "DELETED"
	RemediationStatusEnumDeletedReboot     RemediationStatusEnum = "DELETED_REBOOT"
	RemediationStatusEnumDisabled          RemediationStatusEnum = "DISABLED"
	RemediationStatusEnumDisinfectFailed   RemediationStatusEnum = "DISINFECT_FAILED"
	RemediationStatusEnumDisinfected       RemediationStatusEnum = "DISINFECTED"
	RemediationStatusEnumInfected          RemediationStatusEnum = "INFECTED"
	RemediationStatusEnumMoved             RemediationStatusEnum = "MOVED"
	RemediationStatusEnumMovedReboot       RemediationStatusEnum = "MOVED_REBOOT"
	RemediationStatusEnumNotFound          RemediationStatusEnum = "NOT_FOUND"
	RemediationStatusEnumNotStarted        RemediationStatusEnum = "NOT_STARTED"
	RemediationStatusEnumPasswordProtected RemediationStatusEnum = "PASSWORD_PROTECTED"
	RemediationStatusEnumPrevented         RemediationStatusEnum = "PREVENTED"
	RemediationStatusEnumRebootRequired    RemediationStatusEnum = "REBOOT_REQUIRED"
	RemediationStatusEnumRemediated        RemediationStatusEnum = "REMEDIATED"
	RemediationStatusEnumScanFailed        RemediationStatusEnum = "SCAN_FAILED"
	RemediationStatusEnumSuccess           RemediationStatusEnum = "SUCCESS"
	RemediationStatusEnumSuspicious        RemediationStatusEnum = "SUSPICIOUS"
	RemediationStatusEnumUnknown           RemediationStatusEnum = "UNKNOWN"
)

var AllRemediationStatusEnum = []RemediationStatusEnum{
	RemediationStatusEnumBlocked,
	RemediationStatusEnumClean,
	RemediationStatusEnumDeleted,
	RemediationStatusEnumDeletedReboot,
	RemediationStatusEnumDisabled,
	RemediationStatusEnumDisinfectFailed,
	RemediationStatusEnumDisinfected,
	RemediationStatusEnumInfected,
	RemediationStatusEnumMoved,
	RemediationStatusEnumMovedReboot,
	RemediationStatusEnumNotFound,
	RemediationStatusEnumNotStarted,
	RemediationStatusEnumPasswordProtected,
	RemediationStatusEnumPrevented,
	RemediationStatusEnumRebootRequired,
	RemediationStatusEnumRemediated,
	RemediationStatusEnumScanFailed,
	RemediationStatusEnumSuccess,
	RemediationStatusEnumSuspicious,
	RemediationStatusEnumUnknown,
}

func (e RemediationStatusEnum) IsValid() bool {
	switch e {
	case RemediationStatusEnumBlocked, RemediationStatusEnumClean, RemediationStatusEnumDeleted, RemediationStatusEnumDeletedReboot, RemediationStatusEnumDisabled, RemediationStatusEnumDisinfectFailed, RemediationStatusEnumDisinfected, RemediationStatusEnumInfected, RemediationStatusEnumMoved, RemediationStatusEnumMovedReboot, RemediationStatusEnumNotFound, RemediationStatusEnumNotStarted, RemediationStatusEnumPasswordProtected, RemediationStatusEnumPrevented, RemediationStatusEnumRebootRequired, RemediationStatusEnumRemediated, RemediationStatusEnumScanFailed, RemediationStatusEnumSuccess, RemediationStatusEnumSuspicious, RemediationStatusEnumUnknown:
		return true
	}
	return false
}

func (e RemediationStatusEnum) String() string {
	return string(e)
}

func (e *RemediationStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationStatusEnum", str)
	}
	return nil
}

func (e RemediationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResourceRoleEnum string

const (
	ResourceRoleEnumAdded             ResourceRoleEnum = "ADDED"
	ResourceRoleEnumAttacked          ResourceRoleEnum = "ATTACKED"
	ResourceRoleEnumAttacker          ResourceRoleEnum = "ATTACKER"
	ResourceRoleEnumCommandAndControl ResourceRoleEnum = "COMMAND_AND_CONTROL"
	ResourceRoleEnumCompromised       ResourceRoleEnum = "COMPROMISED"
	ResourceRoleEnumContextual        ResourceRoleEnum = "CONTEXTUAL"
	ResourceRoleEnumCreated           ResourceRoleEnum = "CREATED"
	ResourceRoleEnumDestination       ResourceRoleEnum = "DESTINATION"
	ResourceRoleEnumEdited            ResourceRoleEnum = "EDITED"
	ResourceRoleEnumLoaded            ResourceRoleEnum = "LOADED"
	ResourceRoleEnumPolicyViolator    ResourceRoleEnum = "POLICY_VIOLATOR"
	ResourceRoleEnumScanned           ResourceRoleEnum = "SCANNED"
	ResourceRoleEnumSource            ResourceRoleEnum = "SOURCE"
	ResourceRoleEnumSuspicious        ResourceRoleEnum = "SUSPICIOUS"
)

var AllResourceRoleEnum = []ResourceRoleEnum{
	ResourceRoleEnumAdded,
	ResourceRoleEnumAttacked,
	ResourceRoleEnumAttacker,
	ResourceRoleEnumCommandAndControl,
	ResourceRoleEnumCompromised,
	ResourceRoleEnumContextual,
	ResourceRoleEnumCreated,
	ResourceRoleEnumDestination,
	ResourceRoleEnumEdited,
	ResourceRoleEnumLoaded,
	ResourceRoleEnumPolicyViolator,
	ResourceRoleEnumScanned,
	ResourceRoleEnumSource,
	ResourceRoleEnumSuspicious,
}

func (e ResourceRoleEnum) IsValid() bool {
	switch e {
	case ResourceRoleEnumAdded, ResourceRoleEnumAttacked, ResourceRoleEnumAttacker, ResourceRoleEnumCommandAndControl, ResourceRoleEnumCompromised, ResourceRoleEnumContextual, ResourceRoleEnumCreated, ResourceRoleEnumDestination, ResourceRoleEnumEdited, ResourceRoleEnumLoaded, ResourceRoleEnumPolicyViolator, ResourceRoleEnumScanned, ResourceRoleEnumSource, ResourceRoleEnumSuspicious:
		return true
	}
	return false
}

func (e ResourceRoleEnum) String() string {
	return string(e)
}

func (e *ResourceRoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRoleEnum", str)
	}
	return nil
}

func (e ResourceRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RiskLevelEnum string

const (
	RiskLevelEnumBenign       RiskLevelEnum = "Benign"
	RiskLevelEnumHigh         RiskLevelEnum = "High"
	RiskLevelEnumInconclusive RiskLevelEnum = "Inconclusive"
	RiskLevelEnumLow          RiskLevelEnum = "Low"
	RiskLevelEnumMalicious    RiskLevelEnum = "Malicious"
	RiskLevelEnumMedium       RiskLevelEnum = "Medium"
	RiskLevelEnumNan          RiskLevelEnum = "nan"
)

var AllRiskLevelEnum = []RiskLevelEnum{
	RiskLevelEnumBenign,
	RiskLevelEnumHigh,
	RiskLevelEnumInconclusive,
	RiskLevelEnumLow,
	RiskLevelEnumMalicious,
	RiskLevelEnumMedium,
	RiskLevelEnumNan,
}

func (e RiskLevelEnum) IsValid() bool {
	switch e {
	case RiskLevelEnumBenign, RiskLevelEnumHigh, RiskLevelEnumInconclusive, RiskLevelEnumLow, RiskLevelEnumMalicious, RiskLevelEnumMedium, RiskLevelEnumNan:
		return true
	}
	return false
}

func (e RiskLevelEnum) String() string {
	return string(e)
}

func (e *RiskLevelEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskLevelEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskLevelEnum", str)
	}
	return nil
}

func (e RiskLevelEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScanResult string

const (
	ScanResultBypassByContentRule ScanResult = "BYPASS_BY_CONTENT_RULE"
	ScanResultBypassByOther       ScanResult = "BYPASS_BY_OTHER"
	ScanResultBypassByType        ScanResult = "BYPASS_BY_TYPE"
	ScanResultCancelled           ScanResult = "CANCELLED"
	ScanResultClean               ScanResult = "CLEAN"
	ScanResultEncrypted           ScanResult = "ENCRYPTED"
	ScanResultVirusFound          ScanResult = "VIRUS_FOUND"
)

var AllScanResult = []ScanResult{
	ScanResultBypassByContentRule,
	ScanResultBypassByOther,
	ScanResultBypassByType,
	ScanResultCancelled,
	ScanResultClean,
	ScanResultEncrypted,
	ScanResultVirusFound,
}

func (e ScanResult) IsValid() bool {
	switch e {
	case ScanResultBypassByContentRule, ScanResultBypassByOther, ScanResultBypassByType, ScanResultCancelled, ScanResultClean, ScanResultEncrypted, ScanResultVirusFound:
		return true
	}
	return false
}

func (e ScanResult) String() string {
	return string(e)
}

func (e *ScanResult) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanResult", str)
	}
	return nil
}

func (e ScanResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SeverityEnum string

const (
	SeverityEnumHigh   SeverityEnum = "High"
	SeverityEnumLow    SeverityEnum = "Low"
	SeverityEnumMedium SeverityEnum = "Medium"
)

var AllSeverityEnum = []SeverityEnum{
	SeverityEnumHigh,
	SeverityEnumLow,
	SeverityEnumMedium,
}

func (e SeverityEnum) IsValid() bool {
	switch e {
	case SeverityEnumHigh, SeverityEnumLow, SeverityEnumMedium:
		return true
	}
	return false
}

func (e SeverityEnum) String() string {
	return string(e)
}

func (e *SeverityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SeverityEnum", str)
	}
	return nil
}

func (e SeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteConnectionTypeEnum string

const (
	SiteConnectionTypeEnumSocketAws1500  SiteConnectionTypeEnum = "SOCKET_AWS1500"
	SiteConnectionTypeEnumSocketAz1500   SiteConnectionTypeEnum = "SOCKET_AZ1500"
	SiteConnectionTypeEnumSocketEsx1500  SiteConnectionTypeEnum = "SOCKET_ESX1500"
	SiteConnectionTypeEnumSocketX1500    SiteConnectionTypeEnum = "SOCKET_X1500"
	SiteConnectionTypeEnumSocketX1600    SiteConnectionTypeEnum = "SOCKET_X1600"
	SiteConnectionTypeEnumSocketX1600Lte SiteConnectionTypeEnum = "SOCKET_X1600_LTE"
	SiteConnectionTypeEnumSocketX1700    SiteConnectionTypeEnum = "SOCKET_X1700"
)

var AllSiteConnectionTypeEnum = []SiteConnectionTypeEnum{
	SiteConnectionTypeEnumSocketAws1500,
	SiteConnectionTypeEnumSocketAz1500,
	SiteConnectionTypeEnumSocketEsx1500,
	SiteConnectionTypeEnumSocketX1500,
	SiteConnectionTypeEnumSocketX1600,
	SiteConnectionTypeEnumSocketX1600Lte,
	SiteConnectionTypeEnumSocketX1700,
}

func (e SiteConnectionTypeEnum) IsValid() bool {
	switch e {
	case SiteConnectionTypeEnumSocketAws1500, SiteConnectionTypeEnumSocketAz1500, SiteConnectionTypeEnumSocketEsx1500, SiteConnectionTypeEnumSocketX1500, SiteConnectionTypeEnumSocketX1600, SiteConnectionTypeEnumSocketX1600Lte, SiteConnectionTypeEnumSocketX1700:
		return true
	}
	return false
}

func (e SiteConnectionTypeEnum) String() string {
	return string(e)
}

func (e *SiteConnectionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteConnectionTypeEnum", str)
	}
	return nil
}

func (e SiteConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseGroup string

const (
	// legacy license group
	SiteLicenseGroupAfrica SiteLicenseGroup = "AFRICA"
	// legacy license group
	SiteLicenseGroupAnz SiteLicenseGroup = "ANZ"
	// legacy license group
	SiteLicenseGroupApj SiteLicenseGroup = "APJ"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupChina SiteLicenseGroup = "CHINA"
	// legacy license group
	SiteLicenseGroupDubai SiteLicenseGroup = "DUBAI"
	// legacy license group
	SiteLicenseGroupEurope SiteLicenseGroup = "EUROPE"
	SiteLicenseGroupGroup1 SiteLicenseGroup = "GROUP_1"
	SiteLicenseGroupGroup2 SiteLicenseGroup = "GROUP_2"
	// legacy license group
	SiteLicenseGroupLatam SiteLicenseGroup = "LATAM"
	// legacy license group
	SiteLicenseGroupMiddleEast SiteLicenseGroup = "MIDDLE_EAST"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupMorocco SiteLicenseGroup = "MOROCCO"
	// legacy license group
	SiteLicenseGroupNam SiteLicenseGroup = "NAM"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupVietnam SiteLicenseGroup = "VIETNAM"
)

var AllSiteLicenseGroup = []SiteLicenseGroup{
	SiteLicenseGroupAfrica,
	SiteLicenseGroupAnz,
	SiteLicenseGroupApj,
	SiteLicenseGroupChina,
	SiteLicenseGroupDubai,
	SiteLicenseGroupEurope,
	SiteLicenseGroupGroup1,
	SiteLicenseGroupGroup2,
	SiteLicenseGroupLatam,
	SiteLicenseGroupMiddleEast,
	SiteLicenseGroupMorocco,
	SiteLicenseGroupNam,
	SiteLicenseGroupVietnam,
}

func (e SiteLicenseGroup) IsValid() bool {
	switch e {
	case SiteLicenseGroupAfrica, SiteLicenseGroupAnz, SiteLicenseGroupApj, SiteLicenseGroupChina, SiteLicenseGroupDubai, SiteLicenseGroupEurope, SiteLicenseGroupGroup1, SiteLicenseGroupGroup2, SiteLicenseGroupLatam, SiteLicenseGroupMiddleEast, SiteLicenseGroupMorocco, SiteLicenseGroupNam, SiteLicenseGroupVietnam:
		return true
	}
	return false
}

func (e SiteLicenseGroup) String() string {
	return string(e)
}

func (e *SiteLicenseGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseGroup", str)
	}
	return nil
}

func (e SiteLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseType string

const (
	SiteLicenseTypeSase SiteLicenseType = "SASE"
	SiteLicenseTypeSse  SiteLicenseType = "SSE"
)

var AllSiteLicenseType = []SiteLicenseType{
	SiteLicenseTypeSase,
	SiteLicenseTypeSse,
}

func (e SiteLicenseType) IsValid() bool {
	switch e {
	case SiteLicenseTypeSase, SiteLicenseTypeSse:
		return true
	}
	return false
}

func (e SiteLicenseType) String() string {
	return string(e)
}

func (e *SiteLicenseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseType", str)
	}
	return nil
}

func (e SiteLicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteType string

const (
	SiteTypeBranch       SiteType = "BRANCH"
	SiteTypeCloudDc      SiteType = "CLOUD_DC"
	SiteTypeDatacenter   SiteType = "DATACENTER"
	SiteTypeHeadquarters SiteType = "HEADQUARTERS"
)

var AllSiteType = []SiteType{
	SiteTypeBranch,
	SiteTypeCloudDc,
	SiteTypeDatacenter,
	SiteTypeHeadquarters,
}

func (e SiteType) IsValid() bool {
	switch e {
	case SiteTypeBranch, SiteTypeCloudDc, SiteTypeDatacenter, SiteTypeHeadquarters:
		return true
	}
	return false
}

func (e SiteType) String() string {
	return string(e)
}

func (e *SiteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteType", str)
	}
	return nil
}

func (e SiteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceDestType string

const (
	SocketInterfaceDestTypeAlternative         SocketInterfaceDestType = "ALTERNATIVE"
	SocketInterfaceDestTypeCato                SocketInterfaceDestType = "CATO"
	SocketInterfaceDestTypeInterfaceDisabled   SocketInterfaceDestType = "INTERFACE_DISABLED"
	SocketInterfaceDestTypeLan                 SocketInterfaceDestType = "LAN"
	SocketInterfaceDestTypeLanAndHa            SocketInterfaceDestType = "LAN_AND_HA"
	SocketInterfaceDestTypeLanLagMaster        SocketInterfaceDestType = "LAN_LAG_MASTER"
	SocketInterfaceDestTypeLanLagMasterAndVrrp SocketInterfaceDestType = "LAN_LAG_MASTER_AND_VRRP"
	SocketInterfaceDestTypeLanLagMember        SocketInterfaceDestType = "LAN_LAG_MEMBER"
	SocketInterfaceDestTypeLayer2Wan           SocketInterfaceDestType = "LAYER_2_WAN"
	SocketInterfaceDestTypeVrrp                SocketInterfaceDestType = "VRRP"
	SocketInterfaceDestTypeVrrpAndLan          SocketInterfaceDestType = "VRRP_AND_LAN"
)

var AllSocketInterfaceDestType = []SocketInterfaceDestType{
	SocketInterfaceDestTypeAlternative,
	SocketInterfaceDestTypeCato,
	SocketInterfaceDestTypeInterfaceDisabled,
	SocketInterfaceDestTypeLan,
	SocketInterfaceDestTypeLanAndHa,
	SocketInterfaceDestTypeLanLagMaster,
	SocketInterfaceDestTypeLanLagMasterAndVrrp,
	SocketInterfaceDestTypeLanLagMember,
	SocketInterfaceDestTypeLayer2Wan,
	SocketInterfaceDestTypeVrrp,
	SocketInterfaceDestTypeVrrpAndLan,
}

func (e SocketInterfaceDestType) IsValid() bool {
	switch e {
	case SocketInterfaceDestTypeAlternative, SocketInterfaceDestTypeCato, SocketInterfaceDestTypeInterfaceDisabled, SocketInterfaceDestTypeLan, SocketInterfaceDestTypeLanAndHa, SocketInterfaceDestTypeLanLagMaster, SocketInterfaceDestTypeLanLagMasterAndVrrp, SocketInterfaceDestTypeLanLagMember, SocketInterfaceDestTypeLayer2Wan, SocketInterfaceDestTypeVrrp, SocketInterfaceDestTypeVrrpAndLan:
		return true
	}
	return false
}

func (e SocketInterfaceDestType) String() string {
	return string(e)
}

func (e *SocketInterfaceDestType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceDestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceDestType", str)
	}
	return nil
}

func (e SocketInterfaceDestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids
type SocketInterfaceIDEnum string

const (
	SocketInterfaceIDEnumInt1  SocketInterfaceIDEnum = "INT_1"
	SocketInterfaceIDEnumInt10 SocketInterfaceIDEnum = "INT_10"
	SocketInterfaceIDEnumInt11 SocketInterfaceIDEnum = "INT_11"
	SocketInterfaceIDEnumInt12 SocketInterfaceIDEnum = "INT_12"
	SocketInterfaceIDEnumInt2  SocketInterfaceIDEnum = "INT_2"
	SocketInterfaceIDEnumInt3  SocketInterfaceIDEnum = "INT_3"
	SocketInterfaceIDEnumInt4  SocketInterfaceIDEnum = "INT_4"
	SocketInterfaceIDEnumInt5  SocketInterfaceIDEnum = "INT_5"
	SocketInterfaceIDEnumInt6  SocketInterfaceIDEnum = "INT_6"
	SocketInterfaceIDEnumInt7  SocketInterfaceIDEnum = "INT_7"
	SocketInterfaceIDEnumInt8  SocketInterfaceIDEnum = "INT_8"
	SocketInterfaceIDEnumInt9  SocketInterfaceIDEnum = "INT_9"
	SocketInterfaceIDEnumLan1  SocketInterfaceIDEnum = "LAN1"
	SocketInterfaceIDEnumLan2  SocketInterfaceIDEnum = "LAN2"
	SocketInterfaceIDEnumLte   SocketInterfaceIDEnum = "LTE"
	SocketInterfaceIDEnumUsb1  SocketInterfaceIDEnum = "USB1"
	SocketInterfaceIDEnumUsb2  SocketInterfaceIDEnum = "USB2"
	SocketInterfaceIDEnumWan1  SocketInterfaceIDEnum = "WAN1"
	SocketInterfaceIDEnumWan2  SocketInterfaceIDEnum = "WAN2"
	SocketInterfaceIDEnumWlan  SocketInterfaceIDEnum = "WLAN"
)

var AllSocketInterfaceIDEnum = []SocketInterfaceIDEnum{
	SocketInterfaceIDEnumInt1,
	SocketInterfaceIDEnumInt10,
	SocketInterfaceIDEnumInt11,
	SocketInterfaceIDEnumInt12,
	SocketInterfaceIDEnumInt2,
	SocketInterfaceIDEnumInt3,
	SocketInterfaceIDEnumInt4,
	SocketInterfaceIDEnumInt5,
	SocketInterfaceIDEnumInt6,
	SocketInterfaceIDEnumInt7,
	SocketInterfaceIDEnumInt8,
	SocketInterfaceIDEnumInt9,
	SocketInterfaceIDEnumLan1,
	SocketInterfaceIDEnumLan2,
	SocketInterfaceIDEnumLte,
	SocketInterfaceIDEnumUsb1,
	SocketInterfaceIDEnumUsb2,
	SocketInterfaceIDEnumWan1,
	SocketInterfaceIDEnumWan2,
	SocketInterfaceIDEnumWlan,
}

func (e SocketInterfaceIDEnum) IsValid() bool {
	switch e {
	case SocketInterfaceIDEnumInt1, SocketInterfaceIDEnumInt10, SocketInterfaceIDEnumInt11, SocketInterfaceIDEnumInt12, SocketInterfaceIDEnumInt2, SocketInterfaceIDEnumInt3, SocketInterfaceIDEnumInt4, SocketInterfaceIDEnumInt5, SocketInterfaceIDEnumInt6, SocketInterfaceIDEnumInt7, SocketInterfaceIDEnumInt8, SocketInterfaceIDEnumInt9, SocketInterfaceIDEnumLan1, SocketInterfaceIDEnumLan2, SocketInterfaceIDEnumLte, SocketInterfaceIDEnumUsb1, SocketInterfaceIDEnumUsb2, SocketInterfaceIDEnumWan1, SocketInterfaceIDEnumWan2, SocketInterfaceIDEnumWlan:
		return true
	}
	return false
}

func (e SocketInterfaceIDEnum) String() string {
	return string(e)
}

func (e *SocketInterfaceIDEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceIDEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceIDEnum", str)
	}
	return nil
}

func (e SocketInterfaceIDEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfacePrecedenceEnum string

const (
	SocketInterfacePrecedenceEnumActive     SocketInterfacePrecedenceEnum = "ACTIVE"
	SocketInterfacePrecedenceEnumLastResort SocketInterfacePrecedenceEnum = "LAST_RESORT"
	SocketInterfacePrecedenceEnumPassive    SocketInterfacePrecedenceEnum = "PASSIVE"
)

var AllSocketInterfacePrecedenceEnum = []SocketInterfacePrecedenceEnum{
	SocketInterfacePrecedenceEnumActive,
	SocketInterfacePrecedenceEnumLastResort,
	SocketInterfacePrecedenceEnumPassive,
}

func (e SocketInterfacePrecedenceEnum) IsValid() bool {
	switch e {
	case SocketInterfacePrecedenceEnumActive, SocketInterfacePrecedenceEnumLastResort, SocketInterfacePrecedenceEnumPassive:
		return true
	}
	return false
}

func (e SocketInterfacePrecedenceEnum) String() string {
	return string(e)
}

func (e *SocketInterfacePrecedenceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfacePrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfacePrecedenceEnum", str)
	}
	return nil
}

func (e SocketInterfacePrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceRole string

const (
	SocketInterfaceRoleWan1 SocketInterfaceRole = "wan_1"
	SocketInterfaceRoleWan2 SocketInterfaceRole = "wan_2"
	SocketInterfaceRoleWan3 SocketInterfaceRole = "wan_3"
	SocketInterfaceRoleWan4 SocketInterfaceRole = "wan_4"
)

var AllSocketInterfaceRole = []SocketInterfaceRole{
	SocketInterfaceRoleWan1,
	SocketInterfaceRoleWan2,
	SocketInterfaceRoleWan3,
	SocketInterfaceRoleWan4,
}

func (e SocketInterfaceRole) IsValid() bool {
	switch e {
	case SocketInterfaceRoleWan1, SocketInterfaceRoleWan2, SocketInterfaceRoleWan3, SocketInterfaceRoleWan4:
		return true
	}
	return false
}

func (e SocketInterfaceRole) String() string {
	return string(e)
}

func (e *SocketInterfaceRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceRole", str)
	}
	return nil
}

func (e SocketInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInventoryItemStatus string

const (
	SocketInventoryItemStatusConnected SocketInventoryItemStatus = "CONNECTED"
	SocketInventoryItemStatusDelivered SocketInventoryItemStatus = "DELIVERED"
	SocketInventoryItemStatusInstalled SocketInventoryItemStatus = "INSTALLED"
	SocketInventoryItemStatusOrdered   SocketInventoryItemStatus = "ORDERED"
	SocketInventoryItemStatusShipped   SocketInventoryItemStatus = "SHIPPED"
)

var AllSocketInventoryItemStatus = []SocketInventoryItemStatus{
	SocketInventoryItemStatusConnected,
	SocketInventoryItemStatusDelivered,
	SocketInventoryItemStatusInstalled,
	SocketInventoryItemStatusOrdered,
	SocketInventoryItemStatusShipped,
}

func (e SocketInventoryItemStatus) IsValid() bool {
	switch e {
	case SocketInventoryItemStatusConnected, SocketInventoryItemStatusDelivered, SocketInventoryItemStatusInstalled, SocketInventoryItemStatusOrdered, SocketInventoryItemStatusShipped:
		return true
	}
	return false
}

func (e SocketInventoryItemStatus) String() string {
	return string(e)
}

func (e *SocketInventoryItemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInventoryItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInventoryItemStatus", str)
	}
	return nil
}

func (e SocketInventoryItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketPlatform string

const (
	SocketPlatformAws1500   SocketPlatform = "AWS1500"
	SocketPlatformAz1500    SocketPlatform = "AZ1500"
	SocketPlatformEsx1500   SocketPlatform = "ESX1500"
	SocketPlatformX1500     SocketPlatform = "X1500"
	SocketPlatformX1500Br2  SocketPlatform = "X1500_BR2"
	SocketPlatformX1500bBr2 SocketPlatform = "X1500B_BR2"
	SocketPlatformX1600     SocketPlatform = "X1600"
	SocketPlatformX1600Lte  SocketPlatform = "X1600_LTE"
	SocketPlatformX1700     SocketPlatform = "X1700"
	SocketPlatformX1700b    SocketPlatform = "X1700B"
)

var AllSocketPlatform = []SocketPlatform{
	SocketPlatformAws1500,
	SocketPlatformAz1500,
	SocketPlatformEsx1500,
	SocketPlatformX1500,
	SocketPlatformX1500Br2,
	SocketPlatformX1500bBr2,
	SocketPlatformX1600,
	SocketPlatformX1600Lte,
	SocketPlatformX1700,
	SocketPlatformX1700b,
}

func (e SocketPlatform) IsValid() bool {
	switch e {
	case SocketPlatformAws1500, SocketPlatformAz1500, SocketPlatformEsx1500, SocketPlatformX1500, SocketPlatformX1500Br2, SocketPlatformX1500bBr2, SocketPlatformX1600, SocketPlatformX1600Lte, SocketPlatformX1700, SocketPlatformX1700b:
		return true
	}
	return false
}

func (e SocketPlatform) String() string {
	return string(e)
}

func (e *SocketPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPlatform", str)
	}
	return nil
}

func (e SocketPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketRegistrationStatus string

const (
	SocketRegistrationStatusAssignedSite                SocketRegistrationStatus = "ASSIGNED_SITE"
	SocketRegistrationStatusAssignedSitePendingRegister SocketRegistrationStatus = "ASSIGNED_SITE_PENDING_REGISTER"
	SocketRegistrationStatusNew                         SocketRegistrationStatus = "NEW"
	SocketRegistrationStatusPending                     SocketRegistrationStatus = "PENDING"
	SocketRegistrationStatusRegistered                  SocketRegistrationStatus = "REGISTERED"
	SocketRegistrationStatusRejected                    SocketRegistrationStatus = "REJECTED"
	SocketRegistrationStatusUnassigning                 SocketRegistrationStatus = "UNASSIGNING"
)

var AllSocketRegistrationStatus = []SocketRegistrationStatus{
	SocketRegistrationStatusAssignedSite,
	SocketRegistrationStatusAssignedSitePendingRegister,
	SocketRegistrationStatusNew,
	SocketRegistrationStatusPending,
	SocketRegistrationStatusRegistered,
	SocketRegistrationStatusRejected,
	SocketRegistrationStatusUnassigning,
}

func (e SocketRegistrationStatus) IsValid() bool {
	switch e {
	case SocketRegistrationStatusAssignedSite, SocketRegistrationStatusAssignedSitePendingRegister, SocketRegistrationStatusNew, SocketRegistrationStatusPending, SocketRegistrationStatusRegistered, SocketRegistrationStatusRejected, SocketRegistrationStatusUnassigning:
		return true
	}
	return false
}

func (e SocketRegistrationStatus) String() string {
	return string(e)
}

func (e *SocketRegistrationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketRegistrationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketRegistrationStatus", str)
	}
	return nil
}

func (e SocketRegistrationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketUpgradeStatus string

const (
	SocketUpgradeStatusCancel        SocketUpgradeStatus = "CANCEL"
	SocketUpgradeStatusFail          SocketUpgradeStatus = "FAIL"
	SocketUpgradeStatusFatal         SocketUpgradeStatus = "FATAL"
	SocketUpgradeStatusPending       SocketUpgradeStatus = "PENDING"
	SocketUpgradeStatusPendingReboot SocketUpgradeStatus = "PENDING_REBOOT"
	SocketUpgradeStatusRetry         SocketUpgradeStatus = "RETRY"
	SocketUpgradeStatusSkip          SocketUpgradeStatus = "SKIP"
	SocketUpgradeStatusStarted       SocketUpgradeStatus = "STARTED"
	SocketUpgradeStatusStarting      SocketUpgradeStatus = "STARTING"
	SocketUpgradeStatusSuccess       SocketUpgradeStatus = "SUCCESS"
)

var AllSocketUpgradeStatus = []SocketUpgradeStatus{
	SocketUpgradeStatusCancel,
	SocketUpgradeStatusFail,
	SocketUpgradeStatusFatal,
	SocketUpgradeStatusPending,
	SocketUpgradeStatusPendingReboot,
	SocketUpgradeStatusRetry,
	SocketUpgradeStatusSkip,
	SocketUpgradeStatusStarted,
	SocketUpgradeStatusStarting,
	SocketUpgradeStatusSuccess,
}

func (e SocketUpgradeStatus) IsValid() bool {
	switch e {
	case SocketUpgradeStatusCancel, SocketUpgradeStatusFail, SocketUpgradeStatusFatal, SocketUpgradeStatusPending, SocketUpgradeStatusPendingReboot, SocketUpgradeStatusRetry, SocketUpgradeStatusSkip, SocketUpgradeStatusStarted, SocketUpgradeStatusStarting, SocketUpgradeStatusSuccess:
		return true
	}
	return false
}

func (e SocketUpgradeStatus) String() string {
	return string(e)
}

func (e *SocketUpgradeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketUpgradeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketUpgradeStatus", str)
	}
	return nil
}

func (e SocketUpgradeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "asc"
	SortDirectionEnumDesc SortDirectionEnum = "desc"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryEngineTypeEnum string

const (
	StoryEngineTypeEnumAnomaly  StoryEngineTypeEnum = "ANOMALY"
	StoryEngineTypeEnumEndpoint StoryEngineTypeEnum = "ENDPOINT"
	StoryEngineTypeEnumIdentity StoryEngineTypeEnum = "IDENTITY"
	StoryEngineTypeEnumNetwork  StoryEngineTypeEnum = "NETWORK"
	StoryEngineTypeEnumThreat   StoryEngineTypeEnum = "THREAT"
)

var AllStoryEngineTypeEnum = []StoryEngineTypeEnum{
	StoryEngineTypeEnumAnomaly,
	StoryEngineTypeEnumEndpoint,
	StoryEngineTypeEnumIdentity,
	StoryEngineTypeEnumNetwork,
	StoryEngineTypeEnumThreat,
}

func (e StoryEngineTypeEnum) IsValid() bool {
	switch e {
	case StoryEngineTypeEnumAnomaly, StoryEngineTypeEnumEndpoint, StoryEngineTypeEnumIdentity, StoryEngineTypeEnumNetwork, StoryEngineTypeEnumThreat:
		return true
	}
	return false
}

func (e StoryEngineTypeEnum) String() string {
	return string(e)
}

func (e *StoryEngineTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryEngineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryEngineTypeEnum", str)
	}
	return nil
}

func (e StoryEngineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryProducerEnum string

const (
	StoryProducerEnumAnomalyEvents             StoryProducerEnum = "AnomalyEvents"
	StoryProducerEnumAnomalyStats              StoryProducerEnum = "AnomalyStats"
	StoryProducerEnumCatoEndpointAlert         StoryProducerEnum = "CatoEndpointAlert"
	StoryProducerEnumEntraIDAlert              StoryProducerEnum = "EntraIdAlert"
	StoryProducerEnumMicrosoftEndpointDefender StoryProducerEnum = "MicrosoftEndpointDefender"
	StoryProducerEnumNetworkMonitor            StoryProducerEnum = "NetworkMonitor"
	StoryProducerEnumNetworkXdr                StoryProducerEnum = "NetworkXDR"
	StoryProducerEnumThreatHunt                StoryProducerEnum = "ThreatHunt"
	StoryProducerEnumThreatPrevention          StoryProducerEnum = "ThreatPrevention"
)

var AllStoryProducerEnum = []StoryProducerEnum{
	StoryProducerEnumAnomalyEvents,
	StoryProducerEnumAnomalyStats,
	StoryProducerEnumCatoEndpointAlert,
	StoryProducerEnumEntraIDAlert,
	StoryProducerEnumMicrosoftEndpointDefender,
	StoryProducerEnumNetworkMonitor,
	StoryProducerEnumNetworkXdr,
	StoryProducerEnumThreatHunt,
	StoryProducerEnumThreatPrevention,
}

func (e StoryProducerEnum) IsValid() bool {
	switch e {
	case StoryProducerEnumAnomalyEvents, StoryProducerEnumAnomalyStats, StoryProducerEnumCatoEndpointAlert, StoryProducerEnumEntraIDAlert, StoryProducerEnumMicrosoftEndpointDefender, StoryProducerEnumNetworkMonitor, StoryProducerEnumNetworkXdr, StoryProducerEnumThreatHunt, StoryProducerEnumThreatPrevention:
		return true
	}
	return false
}

func (e StoryProducerEnum) String() string {
	return string(e)
}

func (e *StoryProducerEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryProducerEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryProducerEnum", str)
	}
	return nil
}

func (e StoryProducerEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StorySortFieldName string

const (
	StorySortFieldNameAccountName StorySortFieldName = "accountName"
	StorySortFieldNameCreatedAt   StorySortFieldName = "createdAt"
	StorySortFieldNameCriticality StorySortFieldName = "criticality"
	StorySortFieldNameEngineType  StorySortFieldName = "engineType"
	StorySortFieldNameFirstSignal StorySortFieldName = "firstSignal"
	StorySortFieldNameProducer    StorySortFieldName = "producer"
	StorySortFieldNameQueryName   StorySortFieldName = "queryName"
	StorySortFieldNameRiskScore   StorySortFieldName = "riskScore"
	StorySortFieldNameSeverity    StorySortFieldName = "severity"
	StorySortFieldNameSource      StorySortFieldName = "source"
	StorySortFieldNameSourceIP    StorySortFieldName = "sourceIp"
	StorySortFieldNameStatus      StorySortFieldName = "status"
	StorySortFieldNameUpdatedAt   StorySortFieldName = "updatedAt"
)

var AllStorySortFieldName = []StorySortFieldName{
	StorySortFieldNameAccountName,
	StorySortFieldNameCreatedAt,
	StorySortFieldNameCriticality,
	StorySortFieldNameEngineType,
	StorySortFieldNameFirstSignal,
	StorySortFieldNameProducer,
	StorySortFieldNameQueryName,
	StorySortFieldNameRiskScore,
	StorySortFieldNameSeverity,
	StorySortFieldNameSource,
	StorySortFieldNameSourceIP,
	StorySortFieldNameStatus,
	StorySortFieldNameUpdatedAt,
}

func (e StorySortFieldName) IsValid() bool {
	switch e {
	case StorySortFieldNameAccountName, StorySortFieldNameCreatedAt, StorySortFieldNameCriticality, StorySortFieldNameEngineType, StorySortFieldNameFirstSignal, StorySortFieldNameProducer, StorySortFieldNameQueryName, StorySortFieldNameRiskScore, StorySortFieldNameSeverity, StorySortFieldNameSource, StorySortFieldNameSourceIP, StorySortFieldNameStatus, StorySortFieldNameUpdatedAt:
		return true
	}
	return false
}

func (e StorySortFieldName) String() string {
	return string(e)
}

func (e *StorySortFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorySortFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorySortFieldName", str)
	}
	return nil
}

func (e StorySortFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryStatusEnum string

const (
	StoryStatusEnumClosed          StoryStatusEnum = "Closed"
	StoryStatusEnumMonitoring      StoryStatusEnum = "Monitoring"
	StoryStatusEnumOpen            StoryStatusEnum = "Open"
	StoryStatusEnumPendingAnalysis StoryStatusEnum = "PendingAnalysis"
	StoryStatusEnumPendingMoreInfo StoryStatusEnum = "PendingMoreInfo"
	StoryStatusEnumReopened        StoryStatusEnum = "Reopened"
)

var AllStoryStatusEnum = []StoryStatusEnum{
	StoryStatusEnumClosed,
	StoryStatusEnumMonitoring,
	StoryStatusEnumOpen,
	StoryStatusEnumPendingAnalysis,
	StoryStatusEnumPendingMoreInfo,
	StoryStatusEnumReopened,
}

func (e StoryStatusEnum) IsValid() bool {
	switch e {
	case StoryStatusEnumClosed, StoryStatusEnumMonitoring, StoryStatusEnumOpen, StoryStatusEnumPendingAnalysis, StoryStatusEnumPendingMoreInfo, StoryStatusEnumReopened:
		return true
	}
	return false
}

func (e StoryStatusEnum) String() string {
	return string(e)
}

func (e *StoryStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryStatusEnum", str)
	}
	return nil
}

func (e StoryStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryVerdictEnum string

const (
	StoryVerdictEnumBenign        StoryVerdictEnum = "Benign"
	StoryVerdictEnumInformational StoryVerdictEnum = "Informational"
	StoryVerdictEnumMalicious     StoryVerdictEnum = "Malicious"
	StoryVerdictEnumSuspicious    StoryVerdictEnum = "Suspicious"
)

var AllStoryVerdictEnum = []StoryVerdictEnum{
	StoryVerdictEnumBenign,
	StoryVerdictEnumInformational,
	StoryVerdictEnumMalicious,
	StoryVerdictEnumSuspicious,
}

func (e StoryVerdictEnum) IsValid() bool {
	switch e {
	case StoryVerdictEnumBenign, StoryVerdictEnumInformational, StoryVerdictEnumMalicious, StoryVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e StoryVerdictEnum) String() string {
	return string(e)
}

func (e *StoryVerdictEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryVerdictEnum", str)
	}
	return nil
}

func (e StoryVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubnetType string

const (
	SubnetTypeDirect          SubnetType = "Direct"
	SubnetTypeNative          SubnetType = "Native"
	SubnetTypeRouted          SubnetType = "Routed"
	SubnetTypeSecondaryNative SubnetType = "SecondaryNative"
	SubnetTypeVlan            SubnetType = "VLAN"
)

var AllSubnetType = []SubnetType{
	SubnetTypeDirect,
	SubnetTypeNative,
	SubnetTypeRouted,
	SubnetTypeSecondaryNative,
	SubnetTypeVlan,
}

func (e SubnetType) IsValid() bool {
	switch e {
	case SubnetTypeDirect, SubnetTypeNative, SubnetTypeRouted, SubnetTypeSecondaryNative, SubnetTypeVlan:
		return true
	}
	return false
}

func (e SubnetType) String() string {
	return string(e)
}

func (e *SubnetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubnetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubnetType", str)
	}
	return nil
}

func (e SubnetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetType string

const (
	TargetTypeDomain TargetType = "domain"
	TargetTypeFqdn   TargetType = "fqdn"
	TargetTypeIP     TargetType = "ip"
	TargetTypeURL    TargetType = "url"
)

var AllTargetType = []TargetType{
	TargetTypeDomain,
	TargetTypeFqdn,
	TargetTypeIP,
	TargetTypeURL,
}

func (e TargetType) IsValid() bool {
	switch e {
	case TargetTypeDomain, TargetTypeFqdn, TargetTypeIP, TargetTypeURL:
		return true
	}
	return false
}

func (e TargetType) String() string {
	return string(e)
}

func (e *TargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetType", str)
	}
	return nil
}

func (e TargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeFrameModifier string

const (
	TimeFrameModifierAnalystUpdate TimeFrameModifier = "AnalystUpdate"
	TimeFrameModifierStoryCreate   TimeFrameModifier = "StoryCreate"
	TimeFrameModifierStoryUpdate   TimeFrameModifier = "StoryUpdate"
)

var AllTimeFrameModifier = []TimeFrameModifier{
	TimeFrameModifierAnalystUpdate,
	TimeFrameModifierStoryCreate,
	TimeFrameModifierStoryUpdate,
}

func (e TimeFrameModifier) IsValid() bool {
	switch e {
	case TimeFrameModifierAnalystUpdate, TimeFrameModifierStoryCreate, TimeFrameModifierStoryUpdate:
		return true
	}
	return false
}

func (e TimeFrameModifier) String() string {
	return string(e)
}

func (e *TimeFrameModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeFrameModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeFrameModifier", str)
	}
	return nil
}

func (e TimeFrameModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineItemCategoryEnum string

const (
	TimelineItemCategoryEnumError       TimelineItemCategoryEnum = "Error"
	TimelineItemCategoryEnumInformation TimelineItemCategoryEnum = "Information"
	TimelineItemCategoryEnumWarning     TimelineItemCategoryEnum = "Warning"
)

var AllTimelineItemCategoryEnum = []TimelineItemCategoryEnum{
	TimelineItemCategoryEnumError,
	TimelineItemCategoryEnumInformation,
	TimelineItemCategoryEnumWarning,
}

func (e TimelineItemCategoryEnum) IsValid() bool {
	switch e {
	case TimelineItemCategoryEnumError, TimelineItemCategoryEnumInformation, TimelineItemCategoryEnumWarning:
		return true
	}
	return false
}

func (e TimelineItemCategoryEnum) String() string {
	return string(e)
}

func (e *TimelineItemCategoryEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineItemCategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineItemCategoryEnum", str)
	}
	return nil
}

func (e TimelineItemCategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineTypeEnum string

const (
	TimelineTypeEnumAction  TimelineTypeEnum = "Action"
	TimelineTypeEnumComment TimelineTypeEnum = "Comment"
	TimelineTypeEnumDiff    TimelineTypeEnum = "Diff"
)

var AllTimelineTypeEnum = []TimelineTypeEnum{
	TimelineTypeEnumAction,
	TimelineTypeEnumComment,
	TimelineTypeEnumDiff,
}

func (e TimelineTypeEnum) IsValid() bool {
	switch e {
	case TimelineTypeEnumAction, TimelineTypeEnumComment, TimelineTypeEnumDiff:
		return true
	}
	return false
}

func (e TimelineTypeEnum) String() string {
	return string(e)
}

func (e *TimelineTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineTypeEnum", str)
	}
	return nil
}

func (e TimelineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeseriesMetricType string

const (
	// Total avg downstream traffic (from the Cato Cloud to the site)
	TimeseriesMetricTypeBytesDownstream TimeseriesMetricType = "bytesDownstream"
	// Total max downstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesDownstreamMax TimeseriesMetricType = "bytesDownstreamMax"
	// Total number of bytes of upstream and downstream traffic
	TimeseriesMetricTypeBytesTotal TimeseriesMetricType = "bytesTotal"
	// Total avg upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstream TimeseriesMetricType = "bytesUpstream"
	// Total max upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstreamMax TimeseriesMetricType = "bytesUpstreamMax"
	// Health analytics for the site
	TimeseriesMetricTypeHealth TimeseriesMetricType = "health"
	// Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterDownstream TimeseriesMetricType = "jitterDownstream"
	// Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterUpstream TimeseriesMetricType = "jitterUpstream"
	// Latency from socket directly to a well known global service, not through Cato. This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMileLatency TimeseriesMetricType = "lastMileLatency"
	// Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMilePacketLoss TimeseriesMetricType = "lastMilePacketLoss"
	// Number of packets lost for downstream traffic
	TimeseriesMetricTypeLostDownstream TimeseriesMetricType = "lostDownstream"
	// Percent of packet loss for downstream traffic
	TimeseriesMetricTypeLostDownstreamPcnt TimeseriesMetricType = "lostDownstreamPcnt"
	// Number of packets lost for upstream traffic
	TimeseriesMetricTypeLostUpstream TimeseriesMetricType = "lostUpstream"
	// Percent of packet loss for upstream traffic
	TimeseriesMetricTypeLostUpstreamPcnt TimeseriesMetricType = "lostUpstreamPcnt"
	// Total packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstream TimeseriesMetricType = "packetsDiscardedDownstream"
	// Percent packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt TimeseriesMetricType = "packetsDiscardedDownstreamPcnt"
	// Total packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstream TimeseriesMetricType = "packetsDiscardedUpstream"
	// Percent packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt TimeseriesMetricType = "packetsDiscardedUpstreamPcnt"
	// Total downstream packets
	TimeseriesMetricTypePacketsDownstream TimeseriesMetricType = "packetsDownstream"
	// Total upstream packets
	TimeseriesMetricTypePacketsUpstream TimeseriesMetricType = "packetsUpstream"
	// Round-trip time from the Socket to the Cato Cloud
	TimeseriesMetricTypeRtt TimeseriesMetricType = "rtt"
	// The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)
	TimeseriesMetricTypeTunnelAge TimeseriesMetricType = "tunnelAge"
)

var AllTimeseriesMetricType = []TimeseriesMetricType{
	TimeseriesMetricTypeBytesDownstream,
	TimeseriesMetricTypeBytesDownstreamMax,
	TimeseriesMetricTypeBytesTotal,
	TimeseriesMetricTypeBytesUpstream,
	TimeseriesMetricTypeBytesUpstreamMax,
	TimeseriesMetricTypeHealth,
	TimeseriesMetricTypeJitterDownstream,
	TimeseriesMetricTypeJitterUpstream,
	TimeseriesMetricTypeLastMileLatency,
	TimeseriesMetricTypeLastMilePacketLoss,
	TimeseriesMetricTypeLostDownstream,
	TimeseriesMetricTypeLostDownstreamPcnt,
	TimeseriesMetricTypeLostUpstream,
	TimeseriesMetricTypeLostUpstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedDownstream,
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedUpstream,
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt,
	TimeseriesMetricTypePacketsDownstream,
	TimeseriesMetricTypePacketsUpstream,
	TimeseriesMetricTypeRtt,
	TimeseriesMetricTypeTunnelAge,
}

func (e TimeseriesMetricType) IsValid() bool {
	switch e {
	case TimeseriesMetricTypeBytesDownstream, TimeseriesMetricTypeBytesDownstreamMax, TimeseriesMetricTypeBytesTotal, TimeseriesMetricTypeBytesUpstream, TimeseriesMetricTypeBytesUpstreamMax, TimeseriesMetricTypeHealth, TimeseriesMetricTypeJitterDownstream, TimeseriesMetricTypeJitterUpstream, TimeseriesMetricTypeLastMileLatency, TimeseriesMetricTypeLastMilePacketLoss, TimeseriesMetricTypeLostDownstream, TimeseriesMetricTypeLostDownstreamPcnt, TimeseriesMetricTypeLostUpstream, TimeseriesMetricTypeLostUpstreamPcnt, TimeseriesMetricTypePacketsDiscardedDownstream, TimeseriesMetricTypePacketsDiscardedDownstreamPcnt, TimeseriesMetricTypePacketsDiscardedUpstream, TimeseriesMetricTypePacketsDiscardedUpstreamPcnt, TimeseriesMetricTypePacketsDownstream, TimeseriesMetricTypePacketsUpstream, TimeseriesMetricTypeRtt, TimeseriesMetricTypeTunnelAge:
		return true
	}
	return false
}

func (e TimeseriesMetricType) String() string {
	return string(e)
}

func (e *TimeseriesMetricType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeseriesMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeseriesMetricType", str)
	}
	return nil
}

func (e TimeseriesMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TrafficDirectionEnum string

const (
	TrafficDirectionEnumDownstream TrafficDirectionEnum = "DOWNSTREAM"
	TrafficDirectionEnumUpstream   TrafficDirectionEnum = "UPSTREAM"
)

var AllTrafficDirectionEnum = []TrafficDirectionEnum{
	TrafficDirectionEnumDownstream,
	TrafficDirectionEnumUpstream,
}

func (e TrafficDirectionEnum) IsValid() bool {
	switch e {
	case TrafficDirectionEnumDownstream, TrafficDirectionEnumUpstream:
		return true
	}
	return false
}

func (e TrafficDirectionEnum) String() string {
	return string(e)
}

func (e *TrafficDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficDirectionEnum", str)
	}
	return nil
}

func (e TrafficDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UnitType string

const (
	UnitTypeBits UnitType = "bits"
	// Bits per second
	UnitTypeBps   UnitType = "bps"
	UnitTypeBytes UnitType = "bytes"
	// Bytes per second
	UnitTypeBytesPerSec UnitType = "bytesPerSec"
	// The number of occurrences for this unit
	UnitTypeCount   UnitType = "count"
	UnitTypeMs      UnitType = "ms"
	UnitTypeNone    UnitType = "none"
	UnitTypePackets UnitType = "packets"
	UnitTypePercent UnitType = "percent"
	// health analytics for the site
	UnitTypeScore UnitType = "score"
	// For metrics that are measured in seconds, such as tunnelAge, the number of seconds
	UnitTypeSeconds UnitType = "seconds"
)

var AllUnitType = []UnitType{
	UnitTypeBits,
	UnitTypeBps,
	UnitTypeBytes,
	UnitTypeBytesPerSec,
	UnitTypeCount,
	UnitTypeMs,
	UnitTypeNone,
	UnitTypePackets,
	UnitTypePercent,
	UnitTypeScore,
	UnitTypeSeconds,
}

func (e UnitType) IsValid() bool {
	switch e {
	case UnitTypeBits, UnitTypeBps, UnitTypeBytes, UnitTypeBytesPerSec, UnitTypeCount, UnitTypeMs, UnitTypeNone, UnitTypePackets, UnitTypePercent, UnitTypeScore, UnitTypeSeconds:
		return true
	}
	return false
}

func (e UnitType) String() string {
	return string(e)
}

func (e *UnitType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitType", str)
	}
	return nil
}

func (e UnitType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleEditor       UserRole = "EDITOR"
	UserRoleOwner        UserRole = "OWNER"
	UserRolePublicEditor UserRole = "PUBLIC_EDITOR"
	UserRolePublicViewer UserRole = "PUBLIC_VIEWER"
	UserRoleSitesViewer  UserRole = "SITES_VIEWER"
	UserRoleSuperUser    UserRole = "SUPER_USER"
	UserRoleViewer       UserRole = "VIEWER"
)

var AllUserRole = []UserRole{
	UserRoleEditor,
	UserRoleOwner,
	UserRolePublicEditor,
	UserRolePublicViewer,
	UserRoleSitesViewer,
	UserRoleSuperUser,
	UserRoleViewer,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleEditor, UserRoleOwner, UserRolePublicEditor, UserRolePublicViewer, UserRoleSitesViewer, UserRoleSuperUser, UserRoleViewer:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VendorEnum string

const (
	VendorEnumCato      VendorEnum = "CATO"
	VendorEnumMicrosoft VendorEnum = "MICROSOFT"
)

var AllVendorEnum = []VendorEnum{
	VendorEnumCato,
	VendorEnumMicrosoft,
}

func (e VendorEnum) IsValid() bool {
	switch e {
	case VendorEnumCato, VendorEnumMicrosoft:
		return true
	}
	return false
}

func (e VendorEnum) String() string {
	return string(e)
}

func (e *VendorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorEnum", str)
	}
	return nil
}

func (e VendorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VrrpType string

const (
	VrrpTypeDirectLink VrrpType = "DIRECT_LINK"
	VrrpTypeViaSwitch  VrrpType = "VIA_SWITCH"
)

var AllVrrpType = []VrrpType{
	VrrpTypeDirectLink,
	VrrpTypeViaSwitch,
}

func (e VrrpType) IsValid() bool {
	switch e {
	case VrrpTypeDirectLink, VrrpTypeViaSwitch:
		return true
	}
	return false
}

func (e VrrpType) String() string {
	return string(e)
}

func (e *VrrpType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VrrpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VrrpType", str)
	}
	return nil
}

func (e VrrpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallActionEnum string

const (
	// Allow the network traffic to pass through the firewall.
	WanFirewallActionEnumAllow WanFirewallActionEnum = "ALLOW"
	// Deny the network traffic from passing through the firewall.
	WanFirewallActionEnumBlock WanFirewallActionEnum = "BLOCK"
	// Requests user confirmation to allow or block network traffic.
	WanFirewallActionEnumPrompt WanFirewallActionEnum = "PROMPT"
)

var AllWanFirewallActionEnum = []WanFirewallActionEnum{
	WanFirewallActionEnumAllow,
	WanFirewallActionEnumBlock,
	WanFirewallActionEnumPrompt,
}

func (e WanFirewallActionEnum) IsValid() bool {
	switch e {
	case WanFirewallActionEnumAllow, WanFirewallActionEnumBlock, WanFirewallActionEnumPrompt:
		return true
	}
	return false
}

func (e WanFirewallActionEnum) String() string {
	return string(e)
}

func (e *WanFirewallActionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallActionEnum", str)
	}
	return nil
}

func (e WanFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallDirectionEnum string

const (
	WanFirewallDirectionEnumBoth WanFirewallDirectionEnum = "BOTH"
	WanFirewallDirectionEnumTo   WanFirewallDirectionEnum = "TO"
)

var AllWanFirewallDirectionEnum = []WanFirewallDirectionEnum{
	WanFirewallDirectionEnumBoth,
	WanFirewallDirectionEnumTo,
}

func (e WanFirewallDirectionEnum) IsValid() bool {
	switch e {
	case WanFirewallDirectionEnumBoth, WanFirewallDirectionEnumTo:
		return true
	}
	return false
}

func (e WanFirewallDirectionEnum) String() string {
	return string(e)
}

func (e *WanFirewallDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallDirectionEnum", str)
	}
	return nil
}

func (e WanFirewallDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Geographical regions that can be associated with a remote user license
type ZtnaUsersLicenseGroup string

const (
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupChina ZtnaUsersLicenseGroup = "CHINA"
	// Legacy group
	ZtnaUsersLicenseGroupDubai   ZtnaUsersLicenseGroup = "DUBAI"
	ZtnaUsersLicenseGroupGeneral ZtnaUsersLicenseGroup = "GENERAL"
	// Legacy group
	ZtnaUsersLicenseGroupLatam ZtnaUsersLicenseGroup = "LATAM"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupMorocco ZtnaUsersLicenseGroup = "MOROCCO"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupVietnam ZtnaUsersLicenseGroup = "VIETNAM"
)

var AllZtnaUsersLicenseGroup = []ZtnaUsersLicenseGroup{
	ZtnaUsersLicenseGroupChina,
	ZtnaUsersLicenseGroupDubai,
	ZtnaUsersLicenseGroupGeneral,
	ZtnaUsersLicenseGroupLatam,
	ZtnaUsersLicenseGroupMorocco,
	ZtnaUsersLicenseGroupVietnam,
}

func (e ZtnaUsersLicenseGroup) IsValid() bool {
	switch e {
	case ZtnaUsersLicenseGroupChina, ZtnaUsersLicenseGroupDubai, ZtnaUsersLicenseGroupGeneral, ZtnaUsersLicenseGroupLatam, ZtnaUsersLicenseGroupMorocco, ZtnaUsersLicenseGroupVietnam:
		return true
	}
	return false
}

func (e ZtnaUsersLicenseGroup) String() string {
	return string(e)
}

func (e *ZtnaUsersLicenseGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaUsersLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaUsersLicenseGroup", str)
	}
	return nil
}

func (e ZtnaUsersLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
