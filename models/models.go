// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package cato_models

import (
	"fmt"
	"io"
	"strconv"

	"github.com/routebyintuition/cato-go-sdk/scalars"
)

type Activity interface {
	IsActivity()
	GetID() string
	GetResourceID() string
	GetParentResourceID() string
}

type Anomalies interface {
	IsMergedIncident()
	IsAnomalies()
	GetID() string
	GetFirstSignal() string
	GetLastSignal() string
	GetEngineType() *StoryEngineTypeEnum
	GetVendor() *VendorEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetConnectionType() *ConnectionTypeEnum
	GetIndication() string
	GetQueryName() *string
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSourceIP() *string
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDirection() *string
}

type CatoResource interface {
	IsEndpointResource()
	IsCatoResource()
	// Unique Cato ID for this EPP resource
	GetID() string
	// Timestamp that the this resource was used
	GetCreatedDateTime() *string
	// Enum for the remediation status associated with this resource
	GetRemediationStatus() *RemediationStatusEnum
}

type DeviceDetails interface {
	IsDeviceDetails()
	GetID() string
	GetDeviceName() *string
	GetOsDetails() *OsDetails
	GetLoggedOnUsers() []EndpointUser
}

type Endpoint interface {
	IsMergedIncident()
	IsEndpoint()
	// Unique Cato ID for the story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Enum for the connection for this incident (ie. site, host, user)
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetSourceIP() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDevice() DeviceDetails
	GetAlerts() []EndpointAlert
}

type EndpointAlert interface {
	IsEndpointAlert()
	GetID() string
	GetTitle() *string
	GetDescription() *string
	GetThreatName() *string
	GetMitreTechnique() []*Mitre
	GetMitreSubTechnique() []*Mitre
	GetCreatedDateTime() *string
	GetResources() []EndpointResource
	GetActivities() []Activity
	GetCriticality() *int64
}

type EndpointResource interface {
	IsEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
}

type EndpointUser interface {
	IsEndpointUser()
	GetID() string
	GetName() string
}

type FileResource interface {
	IsEndpointResource()
	IsFileResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetFileDetails() *FileDetails
	GetDetectionStatus() *DetectionStatusEnum
}

// Define settings for the Internet Firewall policy
type IPolicy interface {
	IsIPolicy()
	// TRUE = Policy is enabled, FALSE = Policy is disabled
	GetEnabled() bool
	// Return list of rules in the policy
	GetRules() []IPolicyRulePayload
	// Return sections in the policy
	GetSections() []*PolicySectionPayload
	// Audit data for the policy
	GetAudit() *PolicyAudit
	// Return data for the Policy revision
	GetRevision() *PolicyRevision
}

// Results of policy change
type IPolicyMutationPayload interface {
	IsIPolicyMutationPayload()
	// Data for the policy
	GetPolicy() IPolicy
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

type IPolicyRule interface {
	IsIPolicyRule()
	// Rule ID
	GetID() string
	// Name of the rule
	GetName() string
	// Description for the rule
	GetDescription() *string
	// Position / priority of rule
	GetIndex() int64
	// TRUE = Rule is enabled, FALSE = Rule is disabled
	GetEnabled() bool
	// Policy section where the rule is located
	GetSection() *PolicySectionInfo
}

// Results of rule change
type IPolicyRuleMutationPayload interface {
	IsIPolicyRuleMutationPayload()
	// Returns settings for the rule
	GetRule() IPolicyRulePayload
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

// Results of changes to the rule
type IPolicyRulePayload interface {
	IsIPolicyRulePayload()
	GetAudit() *PolicyElementAudit
	// Rule that was changed
	GetRule() IPolicyRule
	// Summary of rule change, (ie. ADDED, UPDATED)
	GetProperties() []PolicyElementPropertiesEnum
}

// An interface containing properties that are common to all license types
type License interface {
	IsLicense()
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License start date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
}

type MergedIncident interface {
	IsMergedIncident()
	// Unique Cato ID for each story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Enum for the connection for this incident (ie. site, host, user)
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
	//
	// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	GetCriticality() *int64
	// For Network stories - The site where the network issue is occurring
	//
	// For Security stories - IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	// The ticket an analyst created for this story
	GetTicket() *string
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	GetStatus() *StoryStatusEnum
	// The value is TRUE when the story is currently being researched by Security Analysts
	GetResearch() *bool
	// Site name related to the story
	GetSiteName() *string
	// Amount of time since the story was opened (no value for closed stories)
	GetStoryDuration() *int64
	// For Security stories, description of the threat
	GetDescription() *string
	// The source IP address of the device in your network sending or receiving the flow
	GetSourceIP() *string
	// Fields related to analysts research of the threat incident
	GetAnalystFeedback() *AnalystFeedback
	// Cato ID and name for the site
	GetSite() *SiteRef
	// Cato ID and name for the user
	GetUser() *UserRef
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
}

type MicrosoftEndpointResource interface {
	IsEndpointResource()
	IsMicrosoftEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetRemediationStatusDetails() *string
	GetTags() []string
	GetRoles() []ResourceRoleEnum
	GetVerdict() *MsResourceVerdictEnum
}

type ObjectRef interface {
	IsObjectRef()
	// Object's unique identifier
	GetID() string
	// Object's unique name
	GetName() string
}

type ProcessResource interface {
	IsEndpointResource()
	IsProcessResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetProcessID() int64
	GetProcessCommandLine() *string
	GetImageFile() *FileDetails
	GetUserAccount() EndpointUser
}

type QuantifiableLicense interface {
	IsLicense()
	IsQuantifiableLicense()
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License initiation date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
	// license quantity
	GetTotal() int64
}

type RegistryResource interface {
	IsEndpointResource()
	IsRegistryResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetHive() *string
	GetKey() *string
	GetValue() *string
	GetValueName() *string
	GetValueType() *string
}

type Value interface {
	IsValue()
}

type AccountDataPayload struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Subdomain string `json:"subdomain"`
}

type AccountIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type AccountMetrics struct {
	// Unique Identifier of Account.
	ID *string `json:"id,omitempty"`
	// Starting time
	From *string `json:"from,omitempty"`
	// Ending time
	To *string `json:"to,omitempty"`
	// The size of a single time bucket in seconds
	Granularity *int64 `json:"granularity,omitempty"`
	// Site connectivity metrics for the requested sites.
	Sites []*SiteMetrics `json:"sites,omitempty"`
	// Connectivity metrics for the requested users connecting remotely with the Client.
	// Doesn’t include user traffic behind a site.
	Users      []*SiteMetrics `json:"users,omitempty"`
	Timeseries []*Timeseries  `json:"timeseries,omitempty"`
}

type AccountRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AccountRef) IsObjectRef() {}

// Object's unique identifier
func (this AccountRef) GetID() string { return this.ID }

// Object's unique name
func (this AccountRef) GetName() string { return this.Name }

type AccountRolesResult struct {
	Items []*RBACRole `json:"items"`
	Total int64       `json:"total"`
}

type AccountSnapshot struct {
	// Unique Identifier of Account
	ID *string `json:"id,omitempty"`
	// Sites includes information about online as well as offline sites
	Sites []*SiteSnapshot `json:"sites,omitempty"`
	// VPN users information includes only connected users by default (Unlike sites), unless specific ID is requested
	Users     []*UserSnapshot `json:"users,omitempty"`
	Timestamp *string         `json:"timestamp,omitempty"`
}

type AddAdminInput struct {
	FirstName            string                  `json:"firstName"`
	LastName             string                  `json:"lastName"`
	Email                string                  `json:"email"`
	PasswordNeverExpires bool                    `json:"passwordNeverExpires"`
	MfaEnabled           bool                    `json:"mfaEnabled"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddIpsecIkeV2SiteInput struct {
	// The name of the site
	Name string `json:"name"`
	// Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER.
	SiteType    SiteType `json:"siteType"`
	Description *string  `json:"description,omitempty"`
	// The native range of the site
	NativeNetworkRange string `json:"nativeNetworkRange"`
	// The location of the site
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
}

type AddIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                           `json:"fqdn,omitempty"`
	Tunnels []*AddIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type AddIpsecIkeV2SitePayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteTunnelPayload struct {
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *AddIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *AddIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsPayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
	// Cato’s FQDN for the primary tunnel
	Primary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// Cato’s FQDN for the secondary tunnel
	Secondary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
}

type AddIpsecIkeV2TunnelInput struct {
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk string `json:"psk"`
}

type AddIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string `json:"publicCatoIpId,omitempty"`
	// The PoP location ID
	PopLocationID *string                     `json:"popLocationId,omitempty"`
	Tunnels       []*AddIpsecIkeV2TunnelInput `json:"tunnels"`
}

type AddNetworkRangeInput struct {
	Name             string     `json:"name"`
	RangeType        SubnetType `json:"rangeType"`
	Subnet           string     `json:"subnet"`
	TranslatedSubnet *string    `json:"translatedSubnet,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway *string `json:"gateway,omitempty"`
	// Only relevant for VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector *bool `json:"mdnsReflector,omitempty"`
}

type AddNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type AddSiteLocationInput struct {
	// country code
	CountryCode string `json:"countryCode"`
	// optional state code
	StateCode *string `json:"stateCode,omitempty"`
	// time zone
	Timezone string `json:"timezone"`
	// optional address
	Address *string `json:"address,omitempty"`
	// city name, must belong to the country or country and state
	City *string `json:"city,omitempty"`
}

type AddSocketSiteInput struct {
	Name               string                 `json:"name"`
	ConnectionType     SiteConnectionTypeEnum `json:"connectionType"`
	SiteType           SiteType               `json:"siteType"`
	Description        *string                `json:"description,omitempty"`
	NativeNetworkRange string                 `json:"nativeNetworkRange"`
	TranslatedSubnet   *string                `json:"translatedSubnet,omitempty"`
	SiteLocation       *AddSiteLocationInput  `json:"siteLocation"`
}

type AddSocketSitePayload struct {
	SiteID string `json:"siteId"`
}

type AddStaticHostInput struct {
	Name       string  `json:"name"`
	IP         string  `json:"ip"`
	MacAddress *string `json:"macAddress,omitempty"`
}

type AddStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// A CC2 administrator
type Admin struct {
	ID                    string             `json:"id"`
	Version               string             `json:"version"`
	Role                  *UserRole          `json:"role,omitempty"`
	FirstName             *string            `json:"firstName,omitempty"`
	LastName              *string            `json:"lastName,omitempty"`
	Email                 *string            `json:"email,omitempty"`
	CreationDate          *string            `json:"creationDate,omitempty"`
	ModifyDate            *string            `json:"modifyDate,omitempty"`
	Status                *OperationalStatus `json:"status,omitempty"`
	PasswordNeverExpires  *bool              `json:"passwordNeverExpires,omitempty"`
	MfaEnabled            *bool              `json:"mfaEnabled,omitempty"`
	NativeAccountID       *string            `json:"nativeAccountID,omitempty"`
	AllowedItems          []*Entity          `json:"allowedItems,omitempty"`
	PresentUsageAndEvents *bool              `json:"presentUsageAndEvents,omitempty"`
	ManagedRoles          []*AdminRole       `json:"managedRoles,omitempty"`
	ResellerRoles         []*AdminRole       `json:"resellerRoles,omitempty"`
}

type AdminMutations struct {
	AddAdmin    *AddAdminPayload    `json:"addAdmin,omitempty"`
	RemoveAdmin *RemoveAdminPayload `json:"removeAdmin,omitempty"`
	UpdateAdmin *UpdateAdminPayload `json:"updateAdmin,omitempty"`
}

type AdminRole struct {
	Role            *RBACRole `json:"role"`
	AllowedEntities []*Entity `json:"allowedEntities,omitempty"`
	AllowedAccounts []string  `json:"allowedAccounts,omitempty"`
}

type AdminsResult struct {
	Items []*Admin `json:"items"`
	Total int64    `json:"total"`
}

type AnalystFeedback struct {
	Verdict              *StoryVerdictEnum          `json:"verdict,omitempty"`
	Severity             *SeverityEnum              `json:"severity,omitempty"`
	ThreatType           *AnalystFeedbackThreatType `json:"threatType,omitempty"`
	ThreatClassification *string                    `json:"threatClassification,omitempty"`
	AdditionalInfo       *string                    `json:"additionalInfo,omitempty"`
}

type AnalystFeedbackThreatType struct {
	Name              *string `json:"name,omitempty"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
	Details           *string `json:"details,omitempty"`
}

type AnalystInfo struct {
	// Security analyst name
	Name *string `json:"name,omitempty"`
	// Security analyst email address
	Email *string `json:"email,omitempty"`
}

type AnomalyEvents struct {
	ID                  string                  `json:"id"`
	FirstSignal         string                  `json:"firstSignal"`
	LastSignal          string                  `json:"lastSignal"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Indication          string                  `json:"indication"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Ticket              *string                 `json:"ticket,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	Site                *SiteRef                `json:"site,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	LogonName           *string                 `json:"logonName,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Direction           *string                 `json:"direction,omitempty"`
}

func (AnomalyEvents) IsAnomalies()                                {}
func (this AnomalyEvents) GetID() string                          { return this.ID }
func (this AnomalyEvents) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyEvents) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyEvents) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyEvents) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyEvents) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyEvents) GetProducerName() string                { return this.ProducerName }
func (this AnomalyEvents) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyEvents) GetIndication() string                  { return this.Indication }
func (this AnomalyEvents) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyEvents) GetSource() *string                     { return this.Source }
func (this AnomalyEvents) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyEvents) GetTicket() *string                     { return this.Ticket }
func (this AnomalyEvents) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyEvents) GetResearch() *bool                     { return this.Research }
func (this AnomalyEvents) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyEvents) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyEvents) GetDescription() *string                { return this.Description }
func (this AnomalyEvents) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyEvents) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyEvents) GetUser() *UserRef                      { return this.User }
func (this AnomalyEvents) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyEvents) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyEvents) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyEvents) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyEvents) GetDirection() *string                  { return this.Direction }

func (AnomalyEvents) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type AnomalyStats struct {
	ID                  string                  `json:"id"`
	FirstSignal         string                  `json:"firstSignal"`
	LastSignal          string                  `json:"lastSignal"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Indication          string                  `json:"indication"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Ticket              *string                 `json:"ticket,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	Site                *SiteRef                `json:"site,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	LogonName           *string                 `json:"logonName,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Direction           *string                 `json:"direction,omitempty"`
}

func (AnomalyStats) IsAnomalies()                                {}
func (this AnomalyStats) GetID() string                          { return this.ID }
func (this AnomalyStats) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyStats) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyStats) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyStats) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyStats) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyStats) GetProducerName() string                { return this.ProducerName }
func (this AnomalyStats) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyStats) GetIndication() string                  { return this.Indication }
func (this AnomalyStats) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyStats) GetSource() *string                     { return this.Source }
func (this AnomalyStats) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyStats) GetTicket() *string                     { return this.Ticket }
func (this AnomalyStats) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyStats) GetResearch() *bool                     { return this.Research }
func (this AnomalyStats) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyStats) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyStats) GetDescription() *string                { return this.Description }
func (this AnomalyStats) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyStats) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyStats) GetUser() *UserRef                      { return this.User }
func (this AnomalyStats) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyStats) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyStats) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyStats) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyStats) GetDirection() *string                  { return this.Direction }

func (AnomalyStats) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type AppStats struct {
	ID      *string                `json:"id,omitempty"`
	From    *string                `json:"from,omitempty"`
	To      *string                `json:"to,omitempty"`
	Total   *int64                 `json:"total,omitempty"`
	Totals  map[string]interface{} `json:"totals,omitempty"`
	Records []*AppStatsRecord      `json:"records,omitempty"`
}

type AppStatsField struct {
	Name  AppStatsFieldName `json:"name"`
	Value Value             `json:"value"`
}

type AppStatsFilter struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Operator  FilterOperator    `json:"operator"`
	Values    []string          `json:"values"`
}

type AppStatsRecord struct {
	Fields          []*AppStatsField `json:"fields,omitempty"`
	FieldsUnitTypes []UnitType       `json:"fieldsUnitTypes,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap     map[string]interface{} `json:"fieldsMap,omitempty"`
	Trends        map[string]interface{} `json:"trends,omitempty"`
	PrevTimeFrame map[string]interface{} `json:"prevTimeFrame,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
}

type AppStatsSort struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Order     DirectionEnum     `json:"order"`
}

type AppStatsTimeSeries struct {
	ID          *string       `json:"id,omitempty"`
	From        *string       `json:"from,omitempty"`
	To          *string       `json:"to,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
}

type ApplicationCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationCategoryRef) GetName() string { return this.Name }

type ApplicationCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationRef) GetName() string { return this.Name }

type ApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AuditFeed struct {
	From         *string                    `json:"from,omitempty"`
	To           *string                    `json:"to,omitempty"`
	Marker       *string                    `json:"marker,omitempty"`
	FetchedCount int64                      `json:"fetchedCount"`
	HasMore      *bool                      `json:"hasMore,omitempty"`
	Accounts     []*AuditFeedAccountRecords `json:"accounts,omitempty"`
}

type AuditFeedAccountRecords struct {
	ID      *string        `json:"id,omitempty"`
	Records []*AuditRecord `json:"records,omitempty"`
}

type AuditField struct {
	Name  string `json:"name"`
	Value Value  `json:"value"`
}

type AuditFieldFilterInput struct {
	FieldName *FieldNameInput `json:"fieldName"`
	// Use AuditFieldName for audits
	Operator ElasticOperator `json:"operator"`
	Values   []string        `json:"values,omitempty"`
}

// Represents a single event in the audit database
type AuditRecord struct {
	Admin   *Entity     `json:"admin,omitempty"`
	APIKey  *Entity     `json:"apiKey,omitempty"`
	Object  *Entity     `json:"object,omitempty"`
	Account *EntityInfo `json:"account,omitempty"`
	Time    *string     `json:"time,omitempty"`
	// All fields in the audit record (including the admin and object)
	Fields []*AuditField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap map[string]interface{} `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
}

type BGPConnection struct {
	ConnectionName *string        `json:"connectionName,omitempty"`
	PeerIP         *string        `json:"peerIp,omitempty"`
	PeerAsn        *scalars.Asn32 `json:"peerAsn,omitempty"`
	CatoIP         *string        `json:"catoIp,omitempty"`
	CatoAsn        *scalars.Asn16 `json:"catoAsn,omitempty"`
}

type BooleanPredicate struct {
	Is string `json:"is"`
}

// Cloud Access Security Broker (CASB) service license details
type CasbLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (CasbLicense) IsLicense()                   {}
func (this CasbLicense) GetDescription() *string { return this.Description }

// License plan type
func (this CasbLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this CasbLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this CasbLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this CasbLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this CasbLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this CasbLicense) GetLastUpdated() *string { return this.LastUpdated }

type CatoActivity struct {
	// Unique Cato ID for this activity
	ID string `json:"id"`
	// Unique Cato ID for the resource (process or file) involved in the alert
	ResourceID string `json:"resourceId"`
	// Unique Cato ID for the preceding resource (process or file) in the alert
	ParentResourceID string `json:"parentResourceId"`
}

func (CatoActivity) IsActivity()                      {}
func (this CatoActivity) GetID() string               { return this.ID }
func (this CatoActivity) GetResourceID() string       { return this.ResourceID }
func (this CatoActivity) GetParentResourceID() string { return this.ParentResourceID }

type CatoEndpoint struct {
	// ID for the Endpoint Protection story
	ID string `json:"id"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// Timestamp for the last (most recent) incident signal related to this story
	LastSignal string `json:"lastSignal"`
	// enum that shows XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
	// enum for the Producer (specific XDR engine or service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string `json:"producerName"`
	// enum for the connection for this incident (ie. host, user)
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string  `json:"indication"`
	QueryName  *string `json:"queryName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// The ticket for this story
	Ticket *string `json:"ticket,omitempty"`
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	Status *StoryStatusEnum `json:"status,omitempty"`
	// TRUE indicates that the story is currently being researched by Security Analysts
	Research *bool `json:"research,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Cato ID and name for the site
	User                *UserRef            `json:"user,omitempty"`
	SimilarStoriesData  []*SimilarStoryData `json:"similarStoriesData"`
	PredictedVerdict    *StoryVerdictEnum   `json:"predictedVerdict,omitempty"`
	PredictedThreatType *string             `json:"predictedThreatType,omitempty"`
	// Details for the EPP device (ie. device name, OS, MAC address)
	Device *CatoEndpointDeviceDetails `json:"device,omitempty"`
	// Details for the threat detected by the EPP
	Alerts []*CatoEndpointAlert `json:"alerts"`
}

func (CatoEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this CatoEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this CatoEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this CatoEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this CatoEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this CatoEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this CatoEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this CatoEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this CatoEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this CatoEndpoint) GetSource() *string                   { return this.Source }
func (this CatoEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this CatoEndpoint) GetTicket() *string                   { return this.Ticket }
func (this CatoEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this CatoEndpoint) GetResearch() *bool                   { return this.Research }
func (this CatoEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this CatoEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this CatoEndpoint) GetDescription() *string              { return this.Description }
func (this CatoEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this CatoEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this CatoEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this CatoEndpoint) GetUser() *UserRef                    { return this.User }
func (this CatoEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this CatoEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this CatoEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this CatoEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (CatoEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type CatoEndpointAlert struct {
	// Unique Cato ID for the Endpoint Protection story
	ID string `json:"id"`
	// Title of the endpoint alert
	Title *string `json:"title,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Name of threat detected on the device
	ThreatName *string `json:"threatName,omitempty"`
	// MITRE ATT&CK® technique for the threat
	MitreTechnique []*Mitre `json:"mitreTechnique"`
	// MITRE ATT&CK® sub-technique for the threat
	MitreSubTechnique []*Mitre `json:"mitreSubTechnique"`
	// Timestamp that the threat was detected and the alert generated
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Data for the remediation status of the alert
	Resources []CatoResource `json:"resources"`
	// Unique Cato IDs for the activities related to the alert
	Activities []*CatoActivity `json:"activities"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Enum for the EPP engine related to this story
	EngineType *CatoEndpointEngineType `json:"engineType,omitempty"`
	// Enum for the remediation status of the EPP alert
	Status *RemediationStatusEnum `json:"status,omitempty"`
	// EPP profile that is assigned to this device
	EndpointProtectionProfile *string `json:"endpointProtectionProfile,omitempty"`
}

func (CatoEndpointAlert) IsEndpointAlert()             {}
func (this CatoEndpointAlert) GetID() string           { return this.ID }
func (this CatoEndpointAlert) GetTitle() *string       { return this.Title }
func (this CatoEndpointAlert) GetDescription() *string { return this.Description }
func (this CatoEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this CatoEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCriticality() *int64 { return this.Criticality }

type CatoEndpointDeviceDetails struct {
	// Unique Cato ID for this story
	ID string `json:"id"`
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// OS data (ie. type, build, version)
	OsDetails *OsDetails `json:"osDetails,omitempty"`
	// Data for one or more users logged in to the device
	LoggedOnUsers []EndpointUser `json:"loggedOnUsers"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
}

func (CatoEndpointDeviceDetails) IsDeviceDetails()              {}
func (this CatoEndpointDeviceDetails) GetID() string            { return this.ID }
func (this CatoEndpointDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this CatoEndpointDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this CatoEndpointDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type CatoEndpointUser struct {
	// ID for the user
	ID string `json:"id"`
	// Username for the user whose activity generated the indication
	Name string `json:"name"`
}

func (CatoEndpointUser) IsEndpointUser()      {}
func (this CatoEndpointUser) GetID() string   { return this.ID }
func (this CatoEndpointUser) GetName() string { return this.Name }

type CatoFileResource struct {
	// Unique Cato ID for this file resource
	ID string `json:"id"`
	// Timestamp that the this file resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Enum for the remediation status associated with this file resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	// Details of the file related to this resource
	FileDetails *FileDetails `json:"fileDetails,omitempty"`
	// Enum for the detection status of this file resource
	DetectionStatus *DetectionStatusEnum `json:"detectionStatus,omitempty"`
}

func (CatoFileResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoFileResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoFileResource) IsEndpointResource() {}

func (CatoFileResource) IsFileResource() {}

func (this CatoFileResource) GetFileDetails() *FileDetails             { return this.FileDetails }
func (this CatoFileResource) GetDetectionStatus() *DetectionStatusEnum { return this.DetectionStatus }

type CatoProcessResource struct {
	// Unique Cato ID for this resource
	ID string `json:"id"`
	// Timestamp that the this resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Enum for the remediation status associated with this resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	// ID for the process
	ProcessID int64 `json:"processId"`
	// CLI command related to this process
	ProcessCommandLine *string `json:"processCommandLine,omitempty"`
	// Details of the file related to this process
	ImageFile *FileDetails `json:"imageFile,omitempty"`
	// User account related to this process
	UserAccount EndpointUser `json:"userAccount,omitempty"`
}

func (CatoProcessResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoProcessResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoProcessResource) IsEndpointResource() {}

func (CatoProcessResource) IsProcessResource() {}

func (this CatoProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this CatoProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this CatoProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this CatoProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

type CellularInterface struct {
	// 2G, 3G, or 4G
	NetworkType *CellularNetworkType `json:"networkType,omitempty"`
	// Shows the currently active SIM slot; the other slot is in standby. Slot 1 is active by default.
	SimSlotID *int64 `json:"simSlotId,omitempty"`
	// Represents the current status of the modem. Valid values are Error, OK, or Unknown.
	ModemStatus *CellularModemStatus `json:"modemStatus,omitempty"`
	// Indicates if the cellular modem is currently connected to the internet.
	IsModemConnected bool `json:"isModemConnected"`
	// Unique identifier (20-digit number) for the modem.
	Iccid *string `json:"iccid,omitempty"`
	// Unique identifier (15-digit number) for a specific SIM.
	Imei *string `json:"imei,omitempty"`
	// Displays the operator or carrier name, such as Verizon.
	OperatorName *string `json:"operatorName,omitempty"`
	// Indicates if the modem is currently suspended.
	IsModemSuspended bool `json:"isModemSuspended"`
	// Represents the Access Point Name (e.g., uwap.orange.co.il). Configurable from Socket WebUI or SIM switch.
	Apn *string `json:"apn,omitempty"`
	// Determines how the APN is selected. Valid values are Auto or Manual (configurable in WebUI).
	ApnSelectionMethod *ApnMethod `json:"apnSelectionMethod,omitempty"`
	// Represents the signal strength of the cellular connection, in units of calculation.
	SignalStrength *string `json:"signalStrength,omitempty"`
	// Indicates whether roaming is enabled.
	IsRoamingAllowed bool `json:"isRoamingAllowed"`
	// The phone number associated with the SIM.
	SimNumber *string `json:"simNumber,omitempty"`
	// Displays the reason for the modem disconnecting. Valid values are 0 (No reason provided) or 1 (The session timed out).
	DisconnectionReason *CellularDisconnectionReason `json:"disconnectionReason,omitempty"`
	// Indicates whether a SIM is detected in the first slot.
	IsSimSlot1Detected bool `json:"isSimSlot1Detected"`
	// Indicates whether a SIM is detected in the second slot.
	IsSimSlot2Detected bool `json:"isSimSlot2Detected"`
}

// A group with members of a single type of entity (for example: IP, FQDN)
type ContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (ContainerRef) IsObjectRef() {}

// Object's unique identifier
func (this ContainerRef) GetID() string { return this.ID }

// Object's unique name
func (this ContainerRef) GetName() string { return this.Name }

// Add a container by ID or name
type ContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

type CountryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CountryRef) IsObjectRef() {}

// Object's unique identifier
func (this CountryRef) GetID() string { return this.ID }

// Object's unique name
func (this CountryRef) GetName() string { return this.Name }

type CountryRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

type CustomApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomApplicationRef) GetName() string { return this.Name }

type CustomApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type CustomCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomCategoryRef) GetName() string { return this.Name }

type CustomCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomService struct {
	Port      []scalars.Port `json:"port,omitempty"`
	PortRange *PortRange     `json:"portRange,omitempty"`
	Protocol  IPProtocol     `json:"protocol"`
}

// Add a Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomServiceInput struct {
	Port      []scalars.Port  `json:"port,omitempty"`
	PortRange *PortRangeInput `json:"portRange,omitempty"`
	Protocol  IPProtocol      `json:"protocol"`
}

type DataLakeLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The version of the Data Processing Agreement (DPA) that your company signed with Cato.
	DpaVersion DpaVersion `json:"dpaVersion"`
	// Data retention period, in months, during which the account data may remain on the Cato Cloud. After this period the data will be permanently deleted.
	RetentionPeriod int64 `json:"retentionPeriod"`
	// Total number of the Data Storage Units under this license. Each Data Storage Unit increases the allowed ingestion rate (events per hour and total events storage)
	Total int64 `json:"total"`
}

func (DataLakeLicense) IsLicense()                   {}
func (this DataLakeLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DataLakeLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DataLakeLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DataLakeLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DataLakeLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DataLakeLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DataLakeLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DataLakeLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DataLakeLicense) GetTotal() int64 { return this.Total }

type DateValue struct {
	Date *string `json:"date,omitempty"`
}

func (DateValue) IsValue() {}

// DEM Pro service license details
type DemProLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License quantity
	Total int64 `json:"total"`
}

func (DemProLicense) IsLicense()                   {}
func (this DemProLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DemProLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DemProLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DemProLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DemProLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DemProLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DemProLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DemProLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DemProLicense) GetTotal() int64 { return this.Total }

type DeviceProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DeviceProfileRef) IsObjectRef() {}

// Object's unique identifier
func (this DeviceProfileRef) GetID() string { return this.ID }

// Object's unique name
func (this DeviceProfileRef) GetName() string { return this.Name }

type DeviceProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DeviceSnapshot struct {
	// Unique internal Cato ID for the Socket
	ID *string `json:"id,omitempty"`
	// Name of the device
	Name *string `json:"name,omitempty"`
	// Unique identifier for the device
	Identifier *string `json:"identifier,omitempty"`
	// A boolean value that indicates if the site is connected to the Cato Cloud
	Connected *bool `json:"connected,omitempty"`
	// Shows if this is the primary or secondary Socket in high availability mode
	HaRole *string `json:"haRole,omitempty"`
	// Snapshot data for outbound facing interfaces
	Interfaces []*InterfaceSnapshot `json:"interfaces,omitempty"`
	// The last time the device was seen
	LastConnected *string `json:"lastConnected,omitempty"`
	// The uptime of the last tunnel from this device (or current), in seconds
	LastDuration *int64 `json:"lastDuration,omitempty"`
	// For connected devices (this somewhat overlaps to last duration)
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// The ID of the PoP that the Socket is connected to
	LastPopID *int64 `json:"lastPopID,omitempty"`
	// The PoP name that the Socket is connected to
	LastPopName *string `json:"lastPopName,omitempty"`
	// Data related to the most recent completed traffic flows
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
	// Shows the Socket model or vSocket type
	Type *string `json:"type,omitempty"`
	// Shows data related to the Socket, such as version and serial number
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// Information of the link state of various interfaces in the devices. Unlike the `interfacess` field, it contains
	//    all links of the device, not just the outbound facing ones
	InterfacesLinkState []*InterfaceLinkState `json:"interfacesLinkState,omitempty"`
	// Operating system of the Device.
	OsType *string `json:"osType,omitempty"`
	// Version of the Socket operating system
	OsVersion *string `json:"osVersion,omitempty"`
	// Device version
	Version *string `json:"version,omitempty"`
	// Device major version
	VersionNumber *int64 `json:"versionNumber,omitempty"`
	// Shows the release group for the site
	ReleaseGroup *string `json:"releaseGroup,omitempty"`
	// Shows the amount of time remaining before the MFA token expires
	MfaExpirationTime *int64 `json:"mfaExpirationTime,omitempty"`
	// The time the mfa cookie (for sdp users) was created
	MfaCreationTime *int64 `json:"mfaCreationTime,omitempty"`
	// Device's internal IP in the account's routing table
	InternalIP *string `json:"internalIP,omitempty"`
}

type Dimension struct {
	FieldName AppStatsFieldName `json:"fieldName"`
}

type DimensionData struct {
	// Type of the dimension
	Label string `json:"label"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

type DimensionKey struct {
	// Dimension field
	FieldName string `json:"fieldName"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

// Data Loss Prevention (DLP) Service license details
type DlpLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (DlpLicense) IsLicense()                   {}
func (this DlpLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DlpLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DlpLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DlpLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DlpLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DlpLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DlpLicense) GetLastUpdated() *string { return this.LastUpdated }

// End Point Protection (EPP) license details
type EndpointProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The maximum number of users that can use this service
	Total int64 `json:"total"`
}

func (EndpointProtectionLicense) IsLicense()                   {}
func (this EndpointProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this EndpointProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this EndpointProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this EndpointProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this EndpointProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this EndpointProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this EndpointProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

func (EndpointProtectionLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this EndpointProtectionLicense) GetTotal() int64 { return this.Total }

type EngineTypePredicate struct {
	In    []StoryEngineTypeEnum `json:"in,omitempty"`
	NotIn []StoryEngineTypeEnum `json:"not_in,omitempty"`
}

type Entity struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

func (Entity) IsValue() {}

type EntityInfo struct {
	Entity       *Entity                `json:"entity"`
	Description  string                 `json:"description"`
	HelperFields map[string]interface{} `json:"helperFields"`
}

type EntityInput struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

type EntityLookupResult struct {
	Items []*EntityInfo `json:"items"`
	Total *int64        `json:"total,omitempty"`
}

type Event struct {
	SignatureID           *string     `json:"signatureId,omitempty"`
	EventType             *string     `json:"eventType,omitempty"`
	ThreatType            *string     `json:"threatType,omitempty"`
	ThreatName            *string     `json:"threatName,omitempty"`
	Severity              *string     `json:"severity,omitempty"`
	Action                *string     `json:"action,omitempty"`
	RuleID                *string     `json:"ruleId,omitempty"`
	VirusName             *string     `json:"virusName,omitempty"`
	ScanResult            *ScanResult `json:"scanResult,omitempty"`
	AppID                 *string     `json:"appId,omitempty"`
	AppName               *string     `json:"appName,omitempty"`
	DNSProtectionCategory *string     `json:"dnsProtectionCategory,omitempty"`
}

type EventFeedFieldFilterInput struct {
	FieldName EventFeedFilterFieldName `json:"fieldName"`
	// Use event_type and event_sub_type for events
	Operator EventFeedFilterOperator `json:"operator"`
	Values   []string                `json:"values,omitempty"`
}

type EventField struct {
	Name  EventFieldName `json:"name"`
	Value Value          `json:"value"`
}

type EventRecord struct {
	Time *string `json:"time,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap map[string]interface{} `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
}

type Events struct {
	ID      *string                `json:"id,omitempty"`
	From    *string                `json:"from,omitempty"`
	To      *string                `json:"to,omitempty"`
	Total   *int64                 `json:"total,omitempty"`
	Totals  map[string]interface{} `json:"totals,omitempty"`
	Records []*EventsRecord        `json:"records,omitempty"`
}

type EventsDimension struct {
	FieldName EventFieldName `json:"fieldName"`
}

type EventsFeedAccountRecords struct {
	ID          *string        `json:"id,omitempty"`
	ErrorString *string        `json:"errorString,omitempty"`
	Records     []*EventRecord `json:"records,omitempty"`
}

type EventsFeedData struct {
	Marker       *string                     `json:"marker,omitempty"`
	FetchedCount int64                       `json:"fetchedCount"`
	Accounts     []*EventsFeedAccountRecords `json:"accounts,omitempty"`
}

type EventsFilter struct {
	FieldName EventFieldName `json:"fieldName"`
	Operator  FilterOperator `json:"operator"`
	Values    []string       `json:"values"`
}

type EventsMeasure struct {
	FieldName EventFieldName  `json:"fieldName"`
	AggType   AggregationType `json:"aggType"`
	Trend     *bool           `json:"trend,omitempty"`
}

type EventsRecord struct {
	Fields          []*EventField `json:"fields,omitempty"`
	FieldsUnitTypes []UnitType    `json:"fieldsUnitTypes,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap     map[string]interface{} `json:"fieldsMap,omitempty"`
	Trends        map[string]interface{} `json:"trends,omitempty"`
	PrevTimeFrame map[string]interface{} `json:"prevTimeFrame,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
}

type EventsSort struct {
	FieldName EventFieldName `json:"fieldName"`
	Order     DirectionEnum  `json:"order"`
}

type EventsTimeSeries struct {
	ID          *string       `json:"id,omitempty"`
	From        *string       `json:"from,omitempty"`
	To          *string       `json:"to,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
}

type Extra struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

// FieldName for the different types of FieldName inputs
// Use the EventFieldName for events, and AuditFieldName for audit
type FieldNameInput struct {
	EventFieldName *EventFieldName `json:"EventFieldName,omitempty"`
	AuditFieldName *AuditFieldName `json:"AuditFieldName,omitempty"`
}

type FileDetails struct {
	Name      *string `json:"name,omitempty"`
	Path      *string `json:"path,omitempty"`
	Size      *int64  `json:"size,omitempty"`
	Sha1      *string `json:"sha1,omitempty"`
	Sha256    *string `json:"sha256,omitempty"`
	Md5       *string `json:"md5,omitempty"`
	Issuer    *string `json:"issuer,omitempty"`
	Signer    *string `json:"signer,omitempty"`
	Publisher *string `json:"publisher,omitempty"`
}

// Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRef struct {
	// Unique Floating Subnet ID
	ID string `json:"id"`
	// Name for the Floating Subnet
	Name string `json:"name"`
}

func (FloatingSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this FloatingSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this FloatingSubnetRef) GetName() string { return this.Name }

// Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

type FreeTextFilterInput struct {
	Search string `json:"search"`
}

type Gaussian struct {
	Std    *float64 `json:"std,omitempty"`
	Ss     *float64 `json:"ss,omitempty"`
	ZScore *float64 `json:"z_score,omitempty"`
	Avg    *float64 `json:"avg,omitempty"`
	N      *float64 `json:"n,omitempty"`
}

type GetAdminPayload struct {
	ID                   string       `json:"id"`
	FirstName            string       `json:"firstName"`
	LastName             string       `json:"lastName"`
	Email                string       `json:"email"`
	CreationDate         string       `json:"creationDate"`
	PasswordNeverExpires bool         `json:"passwordNeverExpires"`
	MfaEnabled           bool         `json:"mfaEnabled"`
	ManagedRoles         []*AdminRole `json:"managedRoles,omitempty"`
	ResellerRoles        []*AdminRole `json:"resellerRoles,omitempty"`
}

type GlobalIPRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalIPRangeRef) IsObjectRef() {}

// Object's unique identifier
func (this GlobalIPRangeRef) GetID() string { return this.ID }

// Object's unique name
func (this GlobalIPRangeRef) GetName() string { return this.Name }

type GlobalIPRangeRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

// License usage and allocation across all accounts
type GlobalLicenseAllocations struct {
	// Public IP addresses usage across the accounts
	PublicIps *PublicIpsLicenseAllocations `json:"publicIps,omitempty"`
	// ZTNA license allocation across the accounts
	ZtnaUsers *ZtnaUsersLicenseAllocations `json:"ztnaUsers,omitempty"`
}

type GroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GroupRef) IsObjectRef() {}

// Object's unique identifier
func (this GroupRef) GetID() string { return this.ID }

// Object's unique name
func (this GroupRef) GetName() string { return this.Name }

type GroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Basic Site Ha readiness information
type HaStatus struct {
	Readiness       *HaReadiness `json:"readiness,omitempty"`
	WanConnectivity *HaSubStatus `json:"wanConnectivity,omitempty"`
	Keepalive       *HaSubStatus `json:"keepalive,omitempty"`
	SocketVersion   *HaSubStatus `json:"socketVersion,omitempty"`
}

type HardwareManagementQueries struct {
	// Retrieve the account socket inventory
	SocketInventory *SocketInventoryPayload `json:"socketInventory"`
}

type HostRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (HostRef) IsObjectRef() {}

// Object's unique identifier
func (this HostRef) GetID() string { return this.ID }

// Object's unique name
func (this HostRef) GetName() string { return this.Name }

type HostRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A general structure to contain IP detailed information
type IPInfo struct {
	// IP address of the link
	IP *string `json:"ip,omitempty"`
	// Geolocation ISO country code
	CountryCode *string `json:"countryCode,omitempty"`
	// Geolocation country name
	CountryName *string `json:"countryName,omitempty"`
	// Geolocation city
	City *string `json:"city,omitempty"`
	// Geolocation state
	State *string `json:"state,omitempty"`
	// ISP Internet provider
	Provider *string `json:"provider,omitempty"`
	// Geolocation latitude for the ISP
	Latitude *float64 `json:"latitude,omitempty"`
	// Geolocation longitude for the ISP
	Longitude *float64 `json:"longitude,omitempty"`
}

// Basic IPSec configuration information
type IPSecInfo struct {
	// For HA configurations, when this boolean value is true, this the primary IPsec firewall or routing device
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// The source IP address for the IPsec tunnel in the Cato Cloud
	CatoIP *string `json:"catoIP,omitempty"`
	// The destination IP address for the IPsec tunnel (in the site)
	RemoteIP *string `json:"remoteIP,omitempty"`
	// Shows 1 for IKEv1 and 2 for IKEv2
	IkeVersion *int64 `json:"ikeVersion,omitempty"`
}

type IlmmContact struct {
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
	Email *string `json:"email,omitempty"`
}

type IlmmDetails struct {
	LinkDetails *IlmmLinkDetails `json:"linkDetails,omitempty"`
	IspDetails  *IlmmIspDetails  `json:"ispDetails,omitempty"`
	Contacts    []*IlmmContact   `json:"contacts,omitempty"`
}

type IlmmIspDetails struct {
	Name         *string     `json:"name,omitempty"`
	IspAccountID *string     `json:"ispAccountId,omitempty"`
	SupportEmail *string     `json:"supportEmail,omitempty"`
	SupportPhone *string     `json:"supportPhone,omitempty"`
	Description  *string     `json:"description,omitempty"`
	CountryCode  *string     `json:"countryCode,omitempty"`
	LoaFile      *IspLoaFile `json:"loaFile,omitempty"`
}

// Intelligent Last Mile Monitoring (ILMM) License details
type IlmmLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The total amount of ILMM licenses.
	Total int64 `json:"total"`
}

func (IlmmLicense) IsLicense()                   {}
func (this IlmmLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IlmmLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IlmmLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IlmmLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IlmmLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IlmmLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IlmmLicense) GetLastUpdated() *string { return this.LastUpdated }

func (IlmmLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this IlmmLicense) GetTotal() int64 { return this.Total }

type IlmmLinkDetails struct {
	LinkID           *string               `json:"linkId,omitempty"`
	Description      *string               `json:"description,omitempty"`
	IspLinkID        *string               `json:"ispLinkId,omitempty"`
	Comments         *string               `json:"comments,omitempty"`
	OnboardingStatus *IlmmOnboardingStatus `json:"onboardingStatus,omitempty"`
	ActiveLicense    *bool                 `json:"activeLicense,omitempty"`
}

type IncidentFlow struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	Referer                *string `json:"referer,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
	Method                 *string `json:"method,omitempty"`
	URL                    *string `json:"url,omitempty"`
	Target                 *string `json:"target,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	User                   *string `json:"user,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
}

type IncidentTargetRep struct {
	Type                  *TargetType `json:"type,omitempty"`
	Name                  *string     `json:"name,omitempty"`
	AnalysisScore         *float64    `json:"analysisScore,omitempty"`
	InfectionSource       *bool       `json:"infectionSource,omitempty"`
	ThreatReference       *string     `json:"threatReference,omitempty"`
	CatoPopularity        *int64      `json:"catoPopularity,omitempty"`
	ThreatFeeds           *int64      `json:"threatFeeds,omitempty"`
	CreationTime          *string     `json:"creationTime,omitempty"`
	Categories            *string     `json:"categories,omitempty"`
	CountryOfRegistration *string     `json:"countryOfRegistration,omitempty"`
	SearchHits            *string     `json:"searchHits,omitempty"`
	Engines               *int64      `json:"engines,omitempty"`
	EventData             []*Event    `json:"eventData"`
}

type IncidentTimeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// Indicates the type of the timeseries
	Label string   `json:"label"`
	Sum   *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string       `json:"info,omitempty"`
	Key  *TimeseriesKey `json:"key,omitempty"`
}

type IntPredicate struct {
	Gt    *int64  `json:"gt,omitempty"`
	Gte   *int64  `json:"gte,omitempty"`
	Lt    *int64  `json:"lt,omitempty"`
	Lte   *int64  `json:"lte,omitempty"`
	Eq    *int64  `json:"eq,omitempty"`
	In    []int64 `json:"in,omitempty"`
	NotIn []int64 `json:"not_in,omitempty"`
}

// Basic Socket Interface configuration information
type InterfaceInfo struct {
	// ID for the Socket port in the Socket WebUI Monitor tab
	ID string `json:"id"`
	// Name for the port in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Maximum allowed bandwidth on this port, for traffic from the site to the Cato Cloud
	UpstreamBandwidth *int64 `json:"upstreamBandwidth,omitempty"`
	// Maximum allowed bandwidth for traffic on this port, from the Cato Cloud to the site
	DownstreamBandwidth *int64 `json:"downstreamBandwidth,omitempty"`
	// The destination type configured to the Socket interface
	DestType *string `json:"destType,omitempty"`
}

type InterfaceLinkState struct {
	// The ID for the specific Socket port, for example LAN1 or LAN2
	ID *string `json:"id,omitempty"`
	// When this boolean value is true, then the link for the port is up
	Up *bool `json:"up,omitempty"`
	// When this boolean value is true, then a cable is connected to the Socket port
	MediaIn *bool `json:"mediaIn,omitempty"`
	// Shows the maximum bandwidth configured for the link
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// Shows the duplex mode for the link
	Duplex *string `json:"duplex,omitempty"`
}

type InterfaceMetrics struct {
	// Traffic data for the link
	Metrics *Metrics `json:"metrics,omitempty"`
	// Link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// For site metrics, timeseries info field will include: siteID, interfaceName, for last mile metrics it will also
	// include the destination last mile check
	Timeseries []*Timeseries `json:"timeseries,omitempty"`
	// Time stamp annotation that shows a time increment for a GUI
	Annotations []*TimeAnnotation `json:"annotations,omitempty"`
	// object that is a specific time duration
	Periods []*TimePeriod `json:"periods,omitempty"`
	// Data related to the link IP address, such as country code
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version. Applicable only for site
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// Data related to IPsec sites, such as IKE version . Applicable only for site
	IpsecInfo *IPSecInfo `json:"ipsecInfo,omitempty"`
	// Basic configuration information about the Socket interface . Applicable only for site
	InterfaceInfo *InterfaceInfo `json:"interfaceInfo,omitempty"`
}

type InterfaceSnapshot struct {
	// Shows if the WAN link is connected to the PoP
	Connected *bool `json:"connected,omitempty"`
	// Interface ID for the WAN link
	ID *string `json:"id,omitempty"`
	// WAN link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Physical WAN port on the Socket
	PhysicalPort *int64 `json:"physicalPort,omitempty"`
	// Interface Natural order for WAN link
	NaturalOrder *int64 `json:"naturalOrder,omitempty"`
	// The name of the PoP that the WAN link is connected to
	PopName *string `json:"popName,omitempty"`
	// The ID of the PoP that the WAN link was connected to before the current one
	PreviousPopID *int64 `json:"previousPopID,omitempty"`
	// The name of the PoP that the WAN link was connected to before the current one
	PreviousPopName *string `json:"previousPopName,omitempty"`
	// Reason that the tunnel required a new connection (for example, PoP or Socket restarted)
	TunnelConnectionReason *string `json:"tunnelConnectionReason,omitempty"`
	// Number of seconds that the tunnel is connected to a PoP
	TunnelUptime *int64 `json:"tunnelUptime,omitempty"`
	// IP address of the WAN ISP
	TunnelRemoteIP *string `json:"tunnelRemoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the WAN ISP
	TunnelRemoteIPInfo *IPInfo `json:"tunnelRemoteIPInfo,omitempty"`
	Type               *string `json:"type,omitempty"`
	// data about the WAN link that is configured in the Socket Configuration window for the site
	Info *InterfaceInfo `json:"info,omitempty"`
	// Information about cellular (LTE) interface
	CellularInterfaceInfo *CellularInterface `json:"cellularInterfaceInfo,omitempty"`
}

type InternetFirewallAddRuleDataInput struct {
	Enabled     bool   `json:"enabled"`
	Name        string `json:"name"`
	Description string `json:"description"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceInput `json:"source"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRefInput `json:"country"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeInput `json:"service"`
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions"`
}

// Rule parameters and relevant position
type InternetFirewallAddRuleInput struct {
	// Parameters for the rule you are adding
	Rule *InternetFirewallAddRuleDataInput `json:"rule"`
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
}

// Destination match criteria set
type InternetFirewallDestination struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// Countries
	Country []*CountryRef `json:"country"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn"`
	Container []*ContainerRef `json:"container"`
}

// Destination match criteria set
type InternetFirewallDestinationInput struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// Countries
	Country []*CountryRefInput `json:"country"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16      `json:"remoteAsn"`
	Container []*ContainerRefInput `json:"container"`
}

// Destination match criteria set
type InternetFirewallDestinationUpdateInput struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// Countries
	Country []*CountryRefInput `json:"country,omitempty"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16      `json:"remoteAsn,omitempty"`
	Container []*ContainerRefInput `json:"container,omitempty"`
}

type InternetFirewallPolicy struct {
	Enabled  bool                           `json:"enabled"`
	Rules    []*InternetFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload        `json:"sections"`
	Audit    *PolicyAudit                   `json:"audit,omitempty"`
	Revision *PolicyRevision                `json:"revision,omitempty"`
}

func (InternetFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this InternetFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this InternetFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this InternetFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this InternetFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this InternetFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type InternetFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type InternetFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Internet Firewall policy information provided in the API response
type InternetFirewallPolicyMutationPayload struct {
	Policy *InternetFirewallPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
	Errors []*PolicyMutationError  `json:"errors"`
}

func (InternetFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this InternetFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this InternetFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this InternetFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Internet firewall Policy information returned to the caller in the API response.
type InternetFirewallPolicyMutations struct {
	// Add a new rule to the Internet Firewall policy.
	AddRule *InternetFirewallRuleMutationPayload `json:"addRule"`
	// Update an existing rule of the Internet Firewall policy.
	UpdateRule *InternetFirewallRuleMutationPayload `json:"updateRule"`
	// Remove an existing rule from the Internet Firewall policy.
	RemoveRule *InternetFirewallRuleMutationPayload `json:"removeRule"`
	// Change the relative location of an existing rule within the Internet Firewall policy.
	MoveRule *InternetFirewallRuleMutationPayload `json:"moveRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection *PolicySectionMutationPayload `json:"addSection"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection *PolicySectionMutationPayload `json:"moveSection"`
	// Create the policy revision. Create a new empty policy revision.
	CreatePolicyRevision *InternetFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	// Publish the policy revision. A published revision becomes the active policy, and its content is merged with all unpublished revisions for other admins.
	PublishPolicyRevision *InternetFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	// Discard the policy revision. All changes in this discarded revision are discarded, and the revision is deleted.
	DiscardPolicyRevision *InternetFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *InternetFirewallPolicyMutationPayload `json:"updatePolicy"`
}

type InternetFirewallPolicyQueries struct {
	Policy    *InternetFirewallPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type InternetFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type InternetFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type InternetFirewallRule struct {
	// Rule ID
	ID string `json:"id"`
	// Name of the rule
	Name string `json:"name"`
	// Description for the rule
	Description string `json:"description"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSource `json:"source"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestination `json:"destination"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceType `json:"service"`
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleException `json:"exceptions"`
}

func (InternetFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this InternetFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this InternetFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this InternetFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this InternetFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this InternetFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this InternetFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleException struct {
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSource `json:"source"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestination `json:"destination"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceType `json:"service"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleExceptionInput struct {
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSourceInput `json:"source"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceTypeInput `json:"service"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
}

type InternetFirewallRuleMutationPayload struct {
	Rule   *InternetFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus         `json:"status"`
	Errors []*PolicyMutationError       `json:"errors"`
}

func (InternetFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this InternetFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this InternetFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this InternetFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Internet Firewall policy information for a specific revision
type InternetFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Rule       *InternetFirewallRule         `json:"rule"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
}

func (InternetFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this InternetFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this InternetFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this InternetFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceType struct {
	Standard []*ServiceRef    `json:"standard"`
	Custom   []*CustomService `json:"custom"`
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceTypeInput struct {
	Standard []*ServiceRefInput    `json:"standard"`
	Custom   []*CustomServiceInput `json:"custom"`
}

// Add the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceTypeUpdateInput struct {
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
}

// Returns the settings for Source of an Internet Firewall rule
type InternetFirewallSource struct {
	// IPv4 address
	IP []string `json:"ip"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
}

// Input of the settings for Source of an Internet Firewall rule
type InternetFirewallSourceInput struct {
	// IPv4 address
	IP []string `json:"ip"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
}

// Input of the settings for Source of an Internet Firewall rule
type InternetFirewallSourceUpdateInput struct {
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
}

type InternetFirewallUpdateRuleDataInput struct {
	Enabled     *bool   `json:"enabled,omitempty"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceUpdateInput `json:"source,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRefInput `json:"country,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// The action applied by the Internet Firewall if the rule is matched
	Action *InternetFirewallActionEnum `json:"action,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions,omitempty"`
}

type InternetFirewallUpdateRuleInput struct {
	ID   string                               `json:"id"`
	Rule *InternetFirewallUpdateRuleDataInput `json:"rule"`
}

// Inclusive range of IPs
type IPAddressRange struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Inclusive range of IPs
type IPAddressRangeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
type IpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (IpsLicense) IsLicense()                   {}
func (this IpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IpsLicense) GetLastUpdated() *string { return this.LastUpdated }

type IpsecIkeV2MessageInput struct {
	// The SA tunnel encryption method. Note: For situations where GCM isn’t supported for the INIT phase, we recommend that you use the CBC algorithm for the INIT phase, and GCM for AUTH
	Cipher *IPSecCipher `json:"cipher,omitempty"`
	// The Diffie-Hellman Group. The first number is the DH-group number, and the second number is the corresponding prime modulus size in bits
	DhGroup *IPSecDHGroup `json:"dhGroup,omitempty"`
	// The algorithm used to verify the integrity and authenticity of IPsec packets
	Integrity *IPSecHash `json:"integrity,omitempty"`
	// The Pseudo-random function (PRF) used to derive the cryptographic keys used in the SA establishment process
	Prf *IPSecHash `json:"prf,omitempty"`
}

type IspLoaFile struct {
	FileName   *string       `json:"fileName,omitempty"`
	FileHash   *string       `json:"fileHash,omitempty"`
	UploadedAt *scalars.Time `json:"uploadedAt,omitempty"`
}

type LastMileBwInput struct {
	// The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
	Downstream *int64 `json:"downstream,omitempty"`
	// The maximum upstream bandwidth, in Mbps. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
	Upstream *int64 `json:"upstream,omitempty"`
}

// Public license API
type LicensingInfo struct {
	// License inventory
	Licenses []License `json:"licenses"`
	// License usage and allocation across the managed accounts
	GlobalLicenseAllocations *GlobalLicenseAllocations `json:"globalLicenseAllocations"`
}

type LicensingQueries struct {
	// BETA
	LicensingInfo *LicensingInfo `json:"licensingInfo,omitempty"`
}

type LinkQualityIssue struct {
	IssueType *LinkQualityIssueTypeEnum `json:"issueType,omitempty"`
	Direction *TrafficDirectionEnum     `json:"direction,omitempty"`
	Current   *int64                    `json:"current,omitempty"`
	Threshold *int64                    `json:"threshold,omitempty"`
}

type LookupFilterInput struct {
	Filter *LookupFilterType `json:"filter,omitempty"`
	Value  *string           `json:"value,omitempty"`
}

// Anti-Malware service license details (Legacy license, replaced by TP)
type MalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (MalwareProtectionLicense) IsLicense()                   {}
func (this MalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this MalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this MalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this MalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this MalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this MalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this MalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

// Managed XDR service license details
type ManagedXdrLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (ManagedXdrLicense) IsLicense()                   {}
func (this ManagedXdrLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ManagedXdrLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ManagedXdrLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ManagedXdrLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ManagedXdrLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ManagedXdrLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ManagedXdrLicense) GetLastUpdated() *string { return this.LastUpdated }

type Measure struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	AggType   AggregationType   `json:"aggType"`
	Trend     *bool             `json:"trend,omitempty"`
}

type Metric struct {
	Name  string  `json:"name"`
	Value float64 `json:"value"`
}

type MetricDetails struct {
	Name  string `json:"name"`
	Units string `json:"units"`
}

type Metrics struct {
	// total amount of time for the site data
	Duration *int64 `json:"duration,omitempty"`
	// duration in seconds for a single metrics bucket
	Granularity *int64 `json:"granularity,omitempty"`
	// total downstream traffic (from the Cato Cloud to the site)
	BytesDownstream *float64 `json:"bytesDownstream,omitempty"`
	// total upstream traffic (from the site to the Cato Cloud)
	BytesUpstream *float64 `json:"bytesUpstream,omitempty"`
	// total traffic for the site
	BytesTotal *float64 `json:"bytesTotal,omitempty"`
	// number of packets lost for downstream traffic
	LostDownstream *float64 `json:"lostDownstream,omitempty"`
	// percent of packet loss for downstream traffic
	LostDownstreamPcnt *float64 `json:"lostDownstreamPcnt,omitempty"`
	// number of packets lost for upstream traffic
	LostUpstream *float64 `json:"lostUpstream,omitempty"`
	// percent of packet loss for upstream traffic
	LostUpstreamPcnt *float64 `json:"lostUpstreamPcnt,omitempty"`
	// total downstream packets
	PacketsDownstream *float64 `json:"packetsDownstream,omitempty"`
	// total upstream packets
	PacketsUpstream *float64 `json:"packetsUpstream,omitempty"`
	// jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterUpstream *float64 `json:"jitterUpstream,omitempty"`
	// jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterDownstream *float64 `json:"jitterDownstream,omitempty"`
	// total packets discarded for downstream traffic
	PacketsDiscardedDownstream *float64 `json:"packetsDiscardedDownstream,omitempty"`
	// total packets discarded for upstream traffic
	PacketsDiscardedUpstream *float64 `json:"packetsDiscardedUpstream,omitempty"`
	// round-trip time from the site to the Cato Cloud
	Rtt *int64 `json:"rtt,omitempty"`
	// The number of hosts in the tunnel. Relevant only for per site Metrics, ignored in per-interface metrics.
	HostCount *float64 `json:"hostCount,omitempty"`
	// The configurable limit of the number of hosts in the tunnel. Relevant only for per site Metrics, ignored in
	// per-interface metrics.
	HostLimit *float64 `json:"hostLimit,omitempty"`
	// The number of flows (connections) in the tunnel. Relevant only for per site Metrics, ignored in per-interface
	// metrics.
	FlowCount *float64 `json:"flowCount,omitempty"`
}

type MicrosoftActivity struct {
	ID                    string  `json:"id"`
	ResourceID            string  `json:"resourceId"`
	ParentResourceID      string  `json:"parentResourceId"`
	Action                *string `json:"action,omitempty"`
	FirstActivityDateTime *string `json:"firstActivityDateTime,omitempty"`
	LastActivityDateTime  *string `json:"lastActivityDateTime,omitempty"`
}

func (MicrosoftActivity) IsActivity()                      {}
func (this MicrosoftActivity) GetID() string               { return this.ID }
func (this MicrosoftActivity) GetResourceID() string       { return this.ResourceID }
func (this MicrosoftActivity) GetParentResourceID() string { return this.ParentResourceID }

type MicrosoftDefenderEndpointAlert struct {
	ID                    string                      `json:"id"`
	Title                 *string                     `json:"title,omitempty"`
	Description           *string                     `json:"description,omitempty"`
	ThreatName            *string                     `json:"threatName,omitempty"`
	MitreTechnique        []*Mitre                    `json:"mitreTechnique"`
	MitreSubTechnique     []*Mitre                    `json:"mitreSubTechnique"`
	CreatedDateTime       *string                     `json:"createdDateTime,omitempty"`
	Resources             []MicrosoftEndpointResource `json:"resources"`
	Activities            []*MicrosoftActivity        `json:"activities"`
	Criticality           *int64                      `json:"criticality,omitempty"`
	Comments              []string                    `json:"comments"`
	RecommendedActions    *string                     `json:"recommendedActions,omitempty"`
	Category              *string                     `json:"category,omitempty"`
	OwnerName             *string                     `json:"ownerName,omitempty"`
	ThreatFamilyName      *string                     `json:"threatFamilyName,omitempty"`
	ThreatType            *string                     `json:"threatType,omitempty"`
	ResolvedDateTime      *string                     `json:"resolvedDateTime,omitempty"`
	FirstActivityDateTime *string                     `json:"firstActivityDateTime,omitempty"`
	LastActivityDateTime  *string                     `json:"lastActivityDateTime,omitempty"`
	LastUpdateDateTime    *string                     `json:"lastUpdateDateTime,omitempty"`
	LocalIP               *string                     `json:"localIp,omitempty"`
	DestinationIP         *string                     `json:"destinationIp,omitempty"`
	DestinationURL        *string                     `json:"destinationUrl,omitempty"`
	Status                *MsAlertStatus              `json:"status,omitempty"`
	ProviderAlertID       *string                     `json:"providerAlertId,omitempty"`
	AlertWebURL           *string                     `json:"alertWebUrl,omitempty"`
	Determination         *AlertDeterminationEnum     `json:"determination,omitempty"`
	DetectionSource       *DetectionSourceEnum        `json:"detectionSource,omitempty"`
	Classification        *AlertClassificationEnum    `json:"classification,omitempty"`
}

func (MicrosoftDefenderEndpointAlert) IsEndpointAlert()             {}
func (this MicrosoftDefenderEndpointAlert) GetID() string           { return this.ID }
func (this MicrosoftDefenderEndpointAlert) GetTitle() *string       { return this.Title }
func (this MicrosoftDefenderEndpointAlert) GetDescription() *string { return this.Description }
func (this MicrosoftDefenderEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this MicrosoftDefenderEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftDefenderEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCriticality() *int64 { return this.Criticality }

type MicrosoftDeviceDetails struct {
	ID                string                  `json:"id"`
	DeviceName        *string                 `json:"deviceName,omitempty"`
	OsDetails         *OsDetails              `json:"osDetails,omitempty"`
	LoggedOnUsers     []EndpointUser          `json:"loggedOnUsers"`
	FirstSeenDateTime *string                 `json:"firstSeenDateTime,omitempty"`
	AvStatus          *DeviceAvStatusEnum     `json:"avStatus,omitempty"`
	HealthStatus      *DeviceHealthStatusEnum `json:"healthStatus,omitempty"`
	RbacGroup         *RbacGroup              `json:"rbacGroup,omitempty"`
	IPInterfaces      []string                `json:"ipInterfaces"`
	AzureAdDeviceID   *string                 `json:"azureAdDeviceId,omitempty"`
	OnboardingStatus  *OnboardingStatusEnum   `json:"onboardingStatus,omitempty"`
}

func (MicrosoftDeviceDetails) IsDeviceDetails()              {}
func (this MicrosoftDeviceDetails) GetID() string            { return this.ID }
func (this MicrosoftDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this MicrosoftDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this MicrosoftDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type MicrosoftEndpoint struct {
	ID                  string                            `json:"id"`
	FirstSignal         string                            `json:"firstSignal"`
	LastSignal          string                            `json:"lastSignal"`
	EngineType          *StoryEngineTypeEnum              `json:"engineType,omitempty"`
	Vendor              *VendorEnum                       `json:"vendor,omitempty"`
	Producer            StoryProducerEnum                 `json:"producer"`
	ProducerName        string                            `json:"producerName"`
	ConnectionType      *ConnectionTypeEnum               `json:"connectionType,omitempty"`
	Indication          string                            `json:"indication"`
	QueryName           *string                           `json:"queryName,omitempty"`
	Source              *string                           `json:"source,omitempty"`
	Criticality         *int64                            `json:"criticality,omitempty"`
	Ticket              *string                           `json:"ticket,omitempty"`
	Status              *StoryStatusEnum                  `json:"status,omitempty"`
	Research            *bool                             `json:"research,omitempty"`
	SiteName            *string                           `json:"siteName,omitempty"`
	StoryDuration       *int64                            `json:"storyDuration,omitempty"`
	Description         *string                           `json:"description,omitempty"`
	SourceIP            *string                           `json:"sourceIp,omitempty"`
	AnalystFeedback     *AnalystFeedback                  `json:"analystFeedback,omitempty"`
	Site                *SiteRef                          `json:"site,omitempty"`
	User                *UserRef                          `json:"user,omitempty"`
	SimilarStoriesData  []*SimilarStoryData               `json:"similarStoriesData"`
	PredictedVerdict    *StoryVerdictEnum                 `json:"predictedVerdict,omitempty"`
	PredictedThreatType *string                           `json:"predictedThreatType,omitempty"`
	Device              *MicrosoftDeviceDetails           `json:"device,omitempty"`
	Alerts              []*MicrosoftDefenderEndpointAlert `json:"alerts"`
}

func (MicrosoftEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this MicrosoftEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this MicrosoftEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this MicrosoftEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this MicrosoftEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this MicrosoftEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this MicrosoftEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this MicrosoftEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this MicrosoftEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this MicrosoftEndpoint) GetSource() *string                   { return this.Source }
func (this MicrosoftEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this MicrosoftEndpoint) GetTicket() *string                   { return this.Ticket }
func (this MicrosoftEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this MicrosoftEndpoint) GetResearch() *bool                   { return this.Research }
func (this MicrosoftEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this MicrosoftEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this MicrosoftEndpoint) GetDescription() *string              { return this.Description }
func (this MicrosoftEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this MicrosoftEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this MicrosoftEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this MicrosoftEndpoint) GetUser() *UserRef                    { return this.User }
func (this MicrosoftEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this MicrosoftEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this MicrosoftEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this MicrosoftEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (MicrosoftEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Enum for the Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Enum for the connection for this incident (ie. site, host, user)

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Enum for the status of this story (ie. Open, Closed, Monitoring)

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type MicrosoftEndpointUser struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	UserSid       *string `json:"userSid,omitempty"`
	AccountName   *string `json:"accountName,omitempty"`
	DomainName    *string `json:"domainName,omitempty"`
	PrincipalName *string `json:"principalName,omitempty"`
}

func (MicrosoftEndpointUser) IsEndpointUser()      {}
func (this MicrosoftEndpointUser) GetID() string   { return this.ID }
func (this MicrosoftEndpointUser) GetName() string { return this.Name }

type MicrosoftFileResource struct {
	ID                       string                 `json:"id"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Tags                     []string               `json:"tags"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
	FileDetails              *FileDetails           `json:"fileDetails,omitempty"`
	DetectionStatus          *DetectionStatusEnum   `json:"detectionStatus,omitempty"`
}

func (MicrosoftFileResource) IsEndpointResource()              {}
func (this MicrosoftFileResource) GetID() string               { return this.ID }
func (this MicrosoftFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftFileResource) IsFileResource() {}

func (this MicrosoftFileResource) GetFileDetails() *FileDetails { return this.FileDetails }
func (this MicrosoftFileResource) GetDetectionStatus() *DetectionStatusEnum {
	return this.DetectionStatus
}

func (MicrosoftFileResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftFileResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftFileResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

type MicrosoftProcessResource struct {
	ID                       string                 `json:"id"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Tags                     []string               `json:"tags"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
	ProcessID                int64                  `json:"processId"`
	ProcessCommandLine       *string                `json:"processCommandLine,omitempty"`
	ImageFile                *FileDetails           `json:"imageFile,omitempty"`
	UserAccount              EndpointUser           `json:"userAccount,omitempty"`
}

func (MicrosoftProcessResource) IsEndpointResource()              {}
func (this MicrosoftProcessResource) GetID() string               { return this.ID }
func (this MicrosoftProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftProcessResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftProcessResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftProcessResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftProcessResource) IsProcessResource() {}

func (this MicrosoftProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this MicrosoftProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this MicrosoftProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this MicrosoftProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

type MicrosoftRegistryResource struct {
	ID                       string                 `json:"id"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Tags                     []string               `json:"tags"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
	Hive                     *string                `json:"hive,omitempty"`
	Key                      *string                `json:"key,omitempty"`
	Value                    *string                `json:"value,omitempty"`
	ValueName                *string                `json:"valueName,omitempty"`
	ValueType                *string                `json:"valueType,omitempty"`
}

func (MicrosoftRegistryResource) IsEndpointResource()              {}
func (this MicrosoftRegistryResource) GetID() string               { return this.ID }
func (this MicrosoftRegistryResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftRegistryResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftRegistryResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftRegistryResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftRegistryResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftRegistryResource) IsRegistryResource() {}

func (this MicrosoftRegistryResource) GetHive() *string      { return this.Hive }
func (this MicrosoftRegistryResource) GetKey() *string       { return this.Key }
func (this MicrosoftRegistryResource) GetValue() *string     { return this.Value }
func (this MicrosoftRegistryResource) GetValueName() *string { return this.ValueName }
func (this MicrosoftRegistryResource) GetValueType() *string { return this.ValueType }

type Mitre struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type Mutation struct {
}

// NOC as a Service (NOCaaS) service license details
type NOCaaSLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (NOCaaSLicense) IsLicense()                   {}
func (this NOCaaSLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NOCaaSLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NOCaaSLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NOCaaSLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NOCaaSLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NOCaaSLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NOCaaSLicense) GetLastUpdated() *string { return this.LastUpdated }

type NetworkDhcpSettingsInput struct {
	DhcpType     DhcpType `json:"dhcpType"`
	IPRange      *string  `json:"ipRange,omitempty"`
	RelayGroupID *string  `json:"relayGroupId,omitempty"`
}

type NetworkInterfaceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (NetworkInterfaceRef) IsObjectRef() {}

// Object's unique identifier
func (this NetworkInterfaceRef) GetID() string { return this.ID }

// Object's unique name
func (this NetworkInterfaceRef) GetName() string { return this.Name }

type NetworkInterfaceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type NetworkTimelineEvent struct {
	Created              string                    `json:"created"`
	Validated            string                    `json:"validated"`
	Description          *string                   `json:"description,omitempty"`
	EventType            *NetworkXDREventTypeEnum  `json:"eventType,omitempty"`
	IncidentID           *string                   `json:"incidentId,omitempty"`
	NetworkEventSource   *NetworkEventSourceEnum   `json:"networkEventSource,omitempty"`
	EventIds             []string                  `json:"eventIds"`
	Acknowledged         *bool                     `json:"acknowledged,omitempty"`
	LinkID               *string                   `json:"linkId,omitempty"`
	LinkName             *string                   `json:"linkName,omitempty"`
	LinkConfigPrecedence *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkStatus           *LinkStatusEnum           `json:"linkStatus,omitempty"`
	LinkConfigBandwidth  *string                   `json:"linkConfigBandwidth,omitempty"`
	DeviceConfigHaRole   *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	DeviceHaRoleState    *DeviceHaRoleStateEnum    `json:"deviceHaRoleState,omitempty"`
	SocketSerialID       *string                   `json:"socketSerialId,omitempty"`
	Pop                  *string                   `json:"pop,omitempty"`
	Isp                  *string                   `json:"isp,omitempty"`
	BgpConnection        *BGPConnection            `json:"bgpConnection,omitempty"`
	LinkQualityIssue     *LinkQualityIssue         `json:"linkQualityIssue,omitempty"`
	HostIP               *string                   `json:"hostIp,omitempty"`
	RuleName             *string                   `json:"ruleName,omitempty"`
	TunnelResetCount     *int64                    `json:"tunnelResetCount,omitempty"`
	Muted                *bool                     `json:"muted,omitempty"`
}

type NetworkXDRIncident struct {
	ID                      string                    `json:"id"`
	FirstSignal             string                    `json:"firstSignal"`
	LastSignal              string                    `json:"lastSignal"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Indication              string                    `json:"indication"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Source                  *string                   `json:"source,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	SiteName                string                    `json:"siteName"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	NetworkIncidentTimeline []*NetworkTimelineEvent   `json:"networkIncidentTimeline"`
	StoryType               string                    `json:"storyType"`
	Occurrences             *int64                    `json:"occurrences,omitempty"`
	SiteConnectionType      *string                   `json:"siteConnectionType,omitempty"`
	SiteConfigLocation      *string                   `json:"siteConfigLocation,omitempty"`
	Acknowledged            *bool                     `json:"acknowledged,omitempty"`
	LinkID                  *string                   `json:"linkId,omitempty"`
	LinkName                *string                   `json:"linkName,omitempty"`
	LinkConfigPrecedence    *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	DeviceConfigHaRole      *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	LicenseRegion           *string                   `json:"licenseRegion,omitempty"`
	LicenseBandwidth        *string                   `json:"licenseBandwidth,omitempty"`
	Pop                     *string                   `json:"pop,omitempty"`
	Isp                     *string                   `json:"isp,omitempty"`
	BgpConnection           *BGPConnection            `json:"bgpConnection,omitempty"`
	HostIP                  *string                   `json:"hostIp,omitempty"`
	RuleName                *string                   `json:"ruleName,omitempty"`
	Muted                   *bool                     `json:"muted,omitempty"`
	IlmmDetails             *IlmmDetails              `json:"ilmmDetails,omitempty"`
}

func (NetworkXDRIncident) IsMergedIncident() {}

// Unique Cato ID for each story
func (this NetworkXDRIncident) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this NetworkXDRIncident) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this NetworkXDRIncident) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this NetworkXDRIncident) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this NetworkXDRIncident) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this NetworkXDRIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this NetworkXDRIncident) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this NetworkXDRIncident) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this NetworkXDRIncident) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this NetworkXDRIncident) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this NetworkXDRIncident) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this NetworkXDRIncident) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this NetworkXDRIncident) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this NetworkXDRIncident) GetSiteName() *string { return &this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this NetworkXDRIncident) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this NetworkXDRIncident) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this NetworkXDRIncident) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this NetworkXDRIncident) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this NetworkXDRIncident) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this NetworkXDRIncident) GetUser() *UserRef                      { return this.User }
func (this NetworkXDRIncident) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this NetworkXDRIncident) GetPredictedThreatType() *string        { return this.PredictedThreatType }

// NG Anti-Malware service license details (Legacy license, replaced by TP)
type NextGenMalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (NextGenMalwareProtectionLicense) IsLicense()                   {}
func (this NextGenMalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NextGenMalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NextGenMalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NextGenMalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NextGenMalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NextGenMalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NextGenMalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

type OsDetails struct {
	OsType    string  `json:"osType"`
	OsBuild   *int64  `json:"osBuild,omitempty"`
	OsVersion *string `json:"osVersion,omitempty"`
}

type PageInfo struct {
	Total int64 `json:"total"`
}

type Paging struct {
	// Based on the filter and sort parameters, the first story that is returned
	From int64 `json:"from"`
	// Based on the filter and sort parameters, the number of stories returned after the from. For example, the argument {from: 10, limit: 10} returns stories 10-20.
	Limit int64 `json:"limit"`
	// Total number of stories returned
	Total int64 `json:"total"`
}

type PagingInput struct {
	Limit int64 `json:"limit"`
	From  int64 `json:"from"`
}

type PartnerPooledBandwidthLicenseAccount struct {
	// Identifying data for the account
	Account *AccountRef `json:"account"`
	// Allocated bandwidth for this account
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
}

// Input for adding section info to a policy
type PolicyAddSectionInfoInput struct {
	Name string `json:"name"`
}

// Input for adding a section to a policy
type PolicyAddSectionInput struct {
	Section *PolicyAddSectionInfoInput  `json:"section"`
	At      *PolicySectionPositionInput `json:"at"`
}

type PolicyAudit struct {
	PublishedTime string `json:"publishedTime"`
	PublishedBy   string `json:"publishedBy"`
}

type PolicyCreateRevisionInput struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// Returns data for a custom recurring time range that a rule is active
type PolicyCustomRecurring struct {
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
	Days []DayOfWeek  `json:"days"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringInput struct {
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
	Days []DayOfWeek  `json:"days"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringUpdateInput struct {
	From *scalars.Time `json:"from,omitempty"`
	To   *scalars.Time `json:"to,omitempty"`
	Days []DayOfWeek   `json:"days,omitempty"`
}

// Returns data for a custom one-time time range that a rule is active
type PolicyCustomTimeframe struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeUpdateInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Discards unpublished revision for the policy and reverts to the settings for the published policy.
type PolicyDiscardRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyElementAudit struct {
	// The last date and time the rule was updated
	UpdatedTime string `json:"updatedTime"`
	// The admin, or the API-key, that performed the last update
	UpdatedBy string `json:"updatedBy"`
}

// Move the rule to a different position in the policy
type PolicyMoveRuleInput struct {
	ID string                   `json:"id"`
	To *PolicyRulePositionInput `json:"to,omitempty"`
}

// Input for moving a section within a policy
type PolicyMoveSectionInput struct {
	ID string                      `json:"id"`
	To *PolicySectionPositionInput `json:"to,omitempty"`
}

// The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.
//
// ## Policy Errors
//
// ### `ConcurrentPolicyPublish`
// - **Error Message:** "Another policy is currently publishing"
//
// ### `PolicyRevisionMismatch`
// - **Error Message:** "Revision is not owned by the admin"
//
// ### `PolicyRevisionNotFound`
// - **Error Message:** "Revision was not found"
//
// ### `PolicyInvalidEntity`
// - **Error Message:** "Invalid entity"
//
// ### `DuplicateRuleName`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `DuplicateSectionName`
// - **Error Message:** "Section with the same name already exists"
//
// ### `PolicyFailure`
// - **Error Message:** "Can’t publish policy due to an internal error. Please try again in a few minutes"
//
// ## Rule Errors
//
// ### `ruleIsLocked`
// - **Error Message:** "Rule is locked by another revision"
//
// ### `ruleWasRemoved`
// - **Error Message:** "Rule was already removed"
//
// ### `ruleNotExist`
// - **Error Message:** "Rule does not exist"
//
// ### `ruleSectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `ruleSectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `rulePositionInvalid`
// - **Error Message:** "Rule position is invalid"
//
// ### `ruleNameIsEmpty`
// - **Error Message:** "Rule name can't be empty"
//
// ### `ruleNameAlreadyExists`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `ruleSystemModification`
// - **Error Message:** "Can't modify a system rule"
//
// ### `ruleSystemMove`
// - **Error Message:** "Can't add a rule above the system rules"
//
// ### `ruleHasInvalidEntity`
// - **Error Message:** "Rule has an invalid entity"
//
// ### `failedValidatingRule`
// - **Error Message:** "Something went wrong, couldn't validate rule"
//
// ## Section Errors
//
// ### `sectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `sectionSystemMove`
// - **Error Message:** "Section with system rules cannot be moved or removed"
//
// ### `sectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `sectionPositionInvalid`
// - **Error Message:** "Section position is invalid"
type PolicyMutationError struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`
	ErrorCode    *string `json:"errorCode,omitempty"`
}

type PolicyMutationRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

// Policies that can be configured with mutation APIs.
type PolicyMutations struct {
	InternetFirewall *InternetFirewallPolicyMutations `json:"internetFirewall,omitempty"`
	WanFirewall      *WanFirewallPolicyMutations      `json:"wanFirewall,omitempty"`
}

// Published revision is the active policy
// applied on the traffic.
// In addition, when a policy is published, revision changes become visible
// to other admins, and rules locked by the revision become unlocked
type PolicyPublishRevisionInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

// policies which configuration can be read with query APIs.
type PolicyQueries struct {
	InternetFirewall *InternetFirewallPolicyQueries `json:"internetFirewall,omitempty"`
	WanFirewall      *WanFirewallPolicyQueries      `json:"wanFirewall,omitempty"`
}

// Input for removing a section from a policy
type PolicyRemoveSectionInput struct {
	ID string `json:"id"`
}

// Returns data about the policy revision, such as when the change was made, how many rules were changed, etc.
type PolicyRevision struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Changes     int64  `json:"changes"`
	CreatedTime string `json:"createdTime"`
	UpdatedTime string `json:"updatedTime"`
}

// Input for specifying a policy revision
type PolicyRevisionInput struct {
	Type *PolicyRevisionType `json:"type,omitempty"`
	ID   *string             `json:"id,omitempty"`
}

// Returns data for publishing the policy
type PolicyRevisionsPayload struct {
	Revision []*PolicyRevision `json:"revision"`
}

// Parameters required to define the rule position
type PolicyRulePositionInput struct {
	// Position relative to a policy, a section or another rule
	Position *PolicyRulePositionEnum `json:"position,omitempty"`
	// The identifier of the object (e.g. a rule, a section) relative to which the position of the added rule is defined
	Ref *string `json:"ref,omitempty"`
}

// Returns data for the alert settings for the rule
type PolicyRuleTrackingAlert struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRef `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRef `json:"webhook"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRef `json:"mailingList"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertUpdateInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled *bool `json:"enabled,omitempty"`
	// Returns data for the alert frequency
	Frequency *PolicyRuleTrackingFrequencyEnum `json:"frequency,omitempty"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup,omitempty"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook,omitempty"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList,omitempty"`
}

// Returns data if an alert is sent for a rule
type PolicyRuleTrackingEvent struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventInput struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type PolicySchedule struct {
	ActiveOn        PolicyActiveOnEnum     `json:"activeOn"`
	CustomTimeframe *PolicyCustomTimeframe `json:"customTimeframe,omitempty"`
	CustomRecurring *PolicyCustomRecurring `json:"customRecurring,omitempty"`
}

type PolicyScheduleInput struct {
	ActiveOn        PolicyActiveOnEnum          `json:"activeOn"`
	CustomTimeframe *PolicyCustomTimeframeInput `json:"customTimeframe,omitempty"`
	CustomRecurring *PolicyCustomRecurringInput `json:"customRecurring,omitempty"`
}

type PolicyScheduleUpdateInput struct {
	ActiveOn        *PolicyActiveOnEnum               `json:"activeOn,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeUpdateInput `json:"customTimeframe,omitempty"`
	CustomRecurring *PolicyCustomRecurringUpdateInput `json:"customRecurring,omitempty"`
}

// Define settings for a policy section
type PolicySectionInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type PolicySectionMutationPayload struct {
	Section *PolicySectionPayload  `json:"section,omitempty"`
	Status  PolicyMutationStatus   `json:"status"`
	Errors  []*PolicyMutationError `json:"errors"`
}

type PolicySectionPayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Section    *PolicySectionInfo            `json:"section"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
}

type PolicySectionPositionInput struct {
	Position PolicySectionPositionEnum `json:"position"`
	Ref      *string                   `json:"ref,omitempty"`
}

type PolicyTracking struct {
	Event *PolicyRuleTrackingEvent `json:"event"`
	Alert *PolicyRuleTrackingAlert `json:"alert"`
}

type PolicyTrackingInput struct {
	Event *PolicyRuleTrackingEventInput `json:"event"`
	Alert *PolicyRuleTrackingAlertInput `json:"alert"`
}

type PolicyTrackingUpdateInput struct {
	Event *PolicyRuleTrackingEventUpdateInput `json:"event,omitempty"`
	Alert *PolicyRuleTrackingAlertUpdateInput `json:"alert,omitempty"`
}

type PolicyUpdateSectionInfoInput struct {
	Name *string `json:"name,omitempty"`
}

type PolicyUpdateSectionInput struct {
	ID      string                        `json:"id"`
	Section *PolicyUpdateSectionInfoInput `json:"section"`
}

type PooledBandwidthLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Regional license group
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// Maximum available bandwidth, in Mbps, for all the sites under this license. This constitutes the bandwidth pool that is allocated to different sites.
	Total int64 `json:"total"`
	// allocated bandwidth, in Mbps, for all the sites assigned to this license.
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
	// Sites that this license is assigned to (and the license usage within each site)
	Sites []*PooledBandwidthLicenseSite `json:"sites"`
	// Accounts that this license is assigned to (and the license usage within each account)
	Accounts []*PartnerPooledBandwidthLicenseAccount `json:"accounts"`
}

func (PooledBandwidthLicense) IsLicense()                   {}
func (this PooledBandwidthLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PooledBandwidthLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PooledBandwidthLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PooledBandwidthLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PooledBandwidthLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PooledBandwidthLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PooledBandwidthLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PooledBandwidthLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PooledBandwidthLicense) GetTotal() int64 { return this.Total }

type PooledBandwidthLicenseSite struct {
	// Identifying data for the site
	Site *SiteRef `json:"site"`
	// Allocated bandwidth for this site
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
}

// Inclusive network port range
type PortRange struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Inclusive network port range
type PortRangeInput struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Public IP address license
type PublicIpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The number of public IPs available in the licenses
	Total int64 `json:"total"`
}

func (PublicIpsLicense) IsLicense()                   {}
func (this PublicIpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PublicIpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PublicIpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PublicIpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PublicIpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PublicIpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PublicIpsLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PublicIpsLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PublicIpsLicense) GetTotal() int64 { return this.Total }

// IP addresses license usage and allocation across all accounts
type PublicIpsLicenseAllocations struct {
	Total     int64 `json:"total"`
	Allocated int64 `json:"allocated"`
	Available int64 `json:"available"`
}

type Query struct {
}

type RBACRole struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Description  *string `json:"description,omitempty"`
	IsPredefined bool    `json:"isPredefined"`
}

type RbacGroup struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// Remote Browser Isolation (RBI) service license details
type RbiLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (RbiLicense) IsLicense()                   {}
func (this RbiLicense) GetDescription() *string { return this.Description }

// License plan type
func (this RbiLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this RbiLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this RbiLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this RbiLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this RbiLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this RbiLicense) GetLastUpdated() *string { return this.LastUpdated }

type RecentConnection struct {
	// The duration of the connection
	Duration *int64 `json:"duration,omitempty"`
	// Name for the port in the Cato Management Application
	InterfaceName *string `json:"interfaceName,omitempty"`
	// Serial number for the Device
	DeviceName *string `json:"deviceName,omitempty"`
	// The last time this connection was detected (so lastConnected - duration is the start of the connection
	LastConnected *string `json:"lastConnected,omitempty"`
	// The name of the PoP that the traffic flow was connected to
	PopName *string `json:"popName,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the PoP that the traffic flow was connected to
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
}

type RemoveAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type RemoveSitePayload struct {
	SiteID string `json:"siteId"`
}

type RemoveStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// SaaS Security API service license details
type SaasSecurityAPILicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// license quantity
	Total int64 `json:"total"`
}

func (SaasSecurityAPILicense) IsLicense()                   {}
func (this SaasSecurityAPILicense) GetDescription() *string { return this.Description }

// License plan type
func (this SaasSecurityAPILicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SaasSecurityAPILicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SaasSecurityAPILicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SaasSecurityAPILicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SaasSecurityAPILicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SaasSecurityAPILicense) GetLastUpdated() *string { return this.LastUpdated }

func (SaasSecurityAPILicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SaasSecurityAPILicense) GetTotal() int64 { return this.Total }

type SanctionedAppsCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SanctionedAppsCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this SanctionedAppsCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this SanctionedAppsCategoryRef) GetName() string { return this.Name }

type SanctionedAppsCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ServiceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ServiceRef) IsObjectRef() {}

// Object's unique identifier
func (this ServiceRef) GetID() string { return this.ID }

// Object's unique name
func (this ServiceRef) GetName() string { return this.Name }

type ServiceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SimilarStoryData struct {
	StoryID              *string  `json:"storyId,omitempty"`
	ThreatTypeName       *string  `json:"threatTypeName,omitempty"`
	Verdict              *string  `json:"verdict,omitempty"`
	ThreatClassification *string  `json:"threatClassification,omitempty"`
	SimilarityPercentage *float64 `json:"similarityPercentage,omitempty"`
	Indication           *string  `json:"indication,omitempty"`
}

// Basic Site configuration information
type SiteInfo struct {
	// Name for the site
	Name *string `json:"name,omitempty"`
	// Site type in the Cato Management Application, such as branch office or datacenter
	Type *SiteType `json:"type,omitempty"`
	// User defined description of the site
	Description *string `json:"description,omitempty"`
	// Code for the Country that is the physical location of the site
	CountryCode *string `json:"countryCode,omitempty"`
	// Geographical PoP region that the site is licensed to use
	Region *string `json:"region,omitempty"`
	// Country that is the physical location of the site
	CountryName *string `json:"countryName,omitempty"`
	// When this boolean value is true, the site is enabled for high availability
	IsHa *bool `json:"isHA,omitempty"`
	// The Connection Type field defines how the site connects to the Cato Cloud, such as X1500 Socket or AWS vSocket (array with nested fields)
	ConnType *ProtoType `json:"connType,omitempty"`
	// Timestamp for when the site was created
	CreationTime *string `json:"creationTime,omitempty"`
	// Basic configuration information about the Socket interface
	Interfaces []*InterfaceInfo `json:"interfaces,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version (array with nested fields)
	Sockets []*SocketInfo `json:"sockets,omitempty"`
	// data related to IPsec sites, such as IKE version
	Ipsec []*IPSecInfo `json:"ipsec,omitempty"`
}

// Site bandwidth license
type SiteLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The license group.
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// For the relevant license groups, indicates whether this is a global or regional license. For other regions, the value is set to ‘NA’ (not applicable).
	Regionality *Regionality `json:"regionality,omitempty"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// Maximum available bandwidth for the site, in Mbps
	Total int64 `json:"total"`
	// Identifying data for the site the license is assigned to
	Site *SiteRef `json:"site,omitempty"`
}

func (SiteLicense) IsLicense()                   {}
func (this SiteLicense) GetDescription() *string { return this.Description }

// License plan type
func (this SiteLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SiteLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SiteLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SiteLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SiteLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SiteLicense) GetLastUpdated() *string { return this.LastUpdated }

func (SiteLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SiteLicense) GetTotal() int64 { return this.Total }

type SiteMetrics struct {
	// Site ID
	ID *string `json:"id,omitempty"`
	// Analytics that are returned for the links for a site
	Interfaces []*InterfaceMetrics `json:"interfaces,omitempty"`
	// Traffic metrics and data for sites
	Metrics *Metrics `json:"metrics,omitempty"`
	// Site names
	Name *string `json:"name,omitempty"`
	// Shows general information about the site (array with nested fields). Applicable only for site
	Info *SiteInfo `json:"info,omitempty"`
	// Timeseries with the number of hosts in the site. Applicable only for site
	HostCount *Timeseries `json:"hostCount,omitempty"`
	// Timeseries with the number of flows (connections) in the site. Applicable only for site
	FlowCount *Timeseries `json:"flowCount,omitempty"`
	// Timeseries with the configurable limit of the number of hosts in the site. Applicable only for site
	HostLimit *Timeseries `json:"hostLimit,omitempty"`
	Samples   *int64      `json:"samples,omitempty"`
}

type SiteMutations struct {
	AddIpsecIkeV2Site                  *AddIpsecIkeV2SitePayload                  `json:"addIpsecIkeV2Site,omitempty"`
	UpdateIpsecIkeV2SiteGeneralDetails *UpdateIpsecIkeV2SiteGeneralDetailsPayload `json:"updateIpsecIkeV2SiteGeneralDetails,omitempty"`
	AddIpsecIkeV2SiteTunnels           *AddIpsecIkeV2SiteTunnelsPayload           `json:"addIpsecIkeV2SiteTunnels,omitempty"`
	UpdateIpsecIkeV2SiteTunnels        *UpdateIpsecIkeV2SiteTunnelsPayload        `json:"updateIpsecIkeV2SiteTunnels,omitempty"`
	AddSocketSite                      *AddSocketSitePayload                      `json:"addSocketSite,omitempty"`
	UpdateSiteGeneralDetails           *UpdateSiteGeneralDetailsPayload           `json:"updateSiteGeneralDetails,omitempty"`
	RemoveSite                         *RemoveSitePayload                         `json:"removeSite,omitempty"`
	UpdateSocketInterface              *UpdateSocketInterfacePayload              `json:"updateSocketInterface,omitempty"`
	AddNetworkRange                    *AddNetworkRangePayload                    `json:"addNetworkRange,omitempty"`
	UpdateNetworkRange                 *UpdateNetworkRangePayload                 `json:"updateNetworkRange,omitempty"`
	RemoveNetworkRange                 *RemoveNetworkRangePayload                 `json:"removeNetworkRange,omitempty"`
	UpdateHa                           *UpdateHaPayload                           `json:"updateHa,omitempty"`
	AddStaticHost                      *AddStaticHostPayload                      `json:"addStaticHost,omitempty"`
	UpdateStaticHost                   *UpdateStaticHostPayload                   `json:"updateStaticHost,omitempty"`
	RemoveStaticHost                   *RemoveStaticHostPayload                   `json:"removeStaticHost,omitempty"`
}

type SiteNetworkSubnetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteNetworkSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteNetworkSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteNetworkSubnetRef) GetName() string { return this.Name }

type SiteNetworkSubnetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteRef) GetName() string { return this.Name }

type SiteRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteSnapshot struct {
	// site ID
	ID      *string `json:"id,omitempty"`
	ProtoID *int64  `json:"protoId,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// Site HA readiness information
	HaStatus *HaStatus `json:"haStatus,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *OperationalStatus `json:"operationalStatus,omitempty"`
	// Relevant when the site is disconnected - the last time the device was connected
	LastConnected *string `json:"lastConnected,omitempty"`
	// For connected sites, since when are they connected
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// Name of the PoP that the site is connected to
	PopName *string `json:"popName,omitempty"`
	// Data related to the Sockets for a site
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// General real-time information about the site
	Info *SiteInfo `json:"info,omitempty"`
	// Number of hosts connected to a site
	HostCount *int64 `json:"hostCount,omitempty"`
	// Alternative WAN connectivity status
	AltWanStatus *string `json:"altWanStatus,omitempty"`
}

// Basic information about socket
type SocketInfo struct {
	// Unique ID for Socket
	ID *string `json:"id,omitempty"`
	// Serial number for the Socket
	Serial *string `json:"serial,omitempty"`
	// For HA configurations, when this boolean value is true, this the primary Socket
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// Shows Socket type
	Platform *SocketPlatform `json:"platform,omitempty"`
	// Software version number that is currently installed on the Socket
	Version *string `json:"version,omitempty"`
	// Timestamp when the Socket upgraded to the current hardware version
	VersionUpdateTime *string `json:"versionUpdateTime,omitempty"`
}

type SocketInterfaceAltWanInput struct {
	PrivateInterfaceIP string  `json:"privateInterfaceIp"`
	PrivateNetwork     string  `json:"privateNetwork"`
	PrivateGatewayIP   string  `json:"privateGatewayIp"`
	PrivateVlanTag     *int64  `json:"privateVlanTag,omitempty"`
	PublicInterfaceIP  *string `json:"publicInterfaceIp,omitempty"`
	PublicNetwork      *string `json:"publicNetwork,omitempty"`
	PublicGatewayIP    *string `json:"publicGatewayIp,omitempty"`
	PublicVlanTag      *int64  `json:"publicVlanTag,omitempty"`
}

type SocketInterfaceBandwidthInput struct {
	UpstreamBandwidth   int64 `json:"upstreamBandwidth"`
	DownstreamBandwidth int64 `json:"downstreamBandwidth"`
}

type SocketInterfaceLagInput struct {
	MinLinks int64 `json:"minLinks"`
}

type SocketInterfaceLanInput struct {
	Subnet           string  `json:"subnet"`
	TranslatedSubnet *string `json:"translatedSubnet,omitempty"`
	LocalIP          string  `json:"localIp"`
}

type SocketInterfaceOffCloudInput struct {
	Enabled          bool    `json:"enabled"`
	PublicIP         *string `json:"publicIp,omitempty"`
	PublicStaticPort *int64  `json:"publicStaticPort,omitempty"`
}

type SocketInterfaceVrrpInput struct {
	VrrpType *VrrpType `json:"vrrpType,omitempty"`
}

type SocketInterfaceWanInput struct {
	Role       SocketInterfaceRole           `json:"role"`
	Precedence SocketInterfacePrecedenceEnum `json:"precedence"`
}

type SocketInventoryFilterInput struct {
	// Will run contains operation for the provided text on the following fields serialNumber,socketMac,socketVersion,installedSite,
	// shippingCompany,trackingNumber,deliverySiteName,description with OR between them
	FreeText *FreeTextFilterInput `json:"freeText,omitempty"`
}

type SocketInventoryInput struct {
	Filter *SocketInventoryFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                `json:"paging,omitempty"`
	Sort   *SocketInventoryOrderInput  `json:"sort,omitempty"`
}

type SocketInventoryItem struct {
	// ID
	ID string `json:"id"`
	// Socket status (see SocketInventoryItemStatus)
	Status *SocketInventoryItemStatus `json:"status,omitempty"`
	// Serial number (unique)
	SerialNumber *string `json:"serialNumber,omitempty"`
	// Mac address
	SocketMac *string `json:"socketMac,omitempty"`
	// Socket version
	SocketVersion *string `json:"socketVersion,omitempty"`
	// Socket's site
	Site *SiteRef `json:"site,omitempty"`
	// Socket account
	Account *AccountRef `json:"account"`
	// Shipping date
	ShippingDate *string `json:"shippingDate,omitempty"`
	// Socket Type
	SocketType *SocketPlatform `json:"socketType,omitempty"`
	// tracking url from the shipping company
	TrackingURL *string `json:"trackingUrl,omitempty"`
	// tracking number from the shipping company
	TrackingNumber *string `json:"trackingNumber,omitempty"`
	// Shipping company
	ShippingCompany *string `json:"shippingCompany,omitempty"`
	// Name of the delivery site
	DeliverySiteName *string `json:"deliverySiteName,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Is primary socket
	IsPrimary bool `json:"isPrimary"`
	// Registration status
	RegistrationStatus *SocketRegistrationStatus `json:"registrationStatus,omitempty"`
	// Available upgrade versions
	AvailableUpgradeVersions []string `json:"availableUpgradeVersions"`
	// Upgrade status
	UpgradeStatus *SocketUpgradeStatus `json:"upgradeStatus,omitempty"`
	// Are automatic upgrade paused
	UpgradesPaused bool `json:"upgradesPaused"`
}

type SocketInventoryOrderInput struct {
	// Default sort field
	Status           *SortOrderInput `json:"status,omitempty"`
	Description      *SortOrderInput `json:"description,omitempty"`
	DeliverySiteName *SortOrderInput `json:"deliverySiteName,omitempty"`
	InstalledSite    *SortOrderInput `json:"installedSite,omitempty"`
	SocketType       *SortOrderInput `json:"socketType,omitempty"`
	SerialNumber     *SortOrderInput `json:"serialNumber,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	ShippingCompany  *SortOrderInput `json:"shippingCompany,omitempty"`
}

type SocketInventoryPayload struct {
	Items    []*SocketInventoryItem `json:"items"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type SortInput struct {
	Field *string         `json:"field,omitempty"`
	Order *DirectionInput `json:"order,omitempty"`
}

type SortOrderInput struct {
	Direction SortOrder `json:"direction"`
	Priority  int64     `json:"priority"`
}

type StoriesData struct {
	// Define the stories that are returned, similar to a page of stories in the Cato Management Application
	Paging *Paging `json:"paging"`
	// Fields returned from the Story query
	Items []*Story `json:"items"`
}

type Story struct {
	// Unique Cato ID for each story
	ID string `json:"id"`
	// ID for your Cato account
	AccountID int64 `json:"accountId"`
	// Name of analyst working on the story
	AnalystName *string `json:"analystName,omitempty"`
	// Email address of the analyst working on the story
	AnalystEmail *string `json:"analystEmail,omitempty"`
	// Name of the account in the Cato Management Application
	AccountName *string `json:"accountName,omitempty"`
	// Timestamp when the story was most recently updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the story was created
	CreatedAt string `json:"createdAt"`
	// URL for the playbook in the Knowledge Base to help troubleshoot the story
	Playbook *string `json:"playbook,omitempty"`
	// Summary of the story
	Summary *string `json:"summary,omitempty"`
	// Data related to the fields and incidents that were merged to create or update the story
	Incident MergedIncident `json:"incident"`
	// Data for the story timeline
	Timeline []*TimelineItem `json:"timeline"`
}

type StoryDrillDownFilter struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type StoryFilterInput struct {
	TimeFrame   *TimeFramePredicate     `json:"timeFrame"`
	Producer    *StoryProducerPredicate `json:"producer,omitempty"`
	Status      *StoryStatusPredicate   `json:"status,omitempty"`
	Criticality *IntPredicate           `json:"criticality,omitempty"`
	Source      *StringPredicate        `json:"source,omitempty"`
	Severity    *StorySeverityPredicate `json:"severity,omitempty"`
	IncidentID  *StringPredicate        `json:"incidentId,omitempty"`
	Ioa         *StringPredicate        `json:"ioa,omitempty"`
	AccountID   *AccountIDPredicate     `json:"accountId,omitempty"`
	StoryID     *StoryIDPredicate       `json:"storyId,omitempty"`
	QueryName   *StringPredicate        `json:"queryName,omitempty"`
	Verdict     *StoryVerdictPredicate  `json:"verdict,omitempty"`
	EngineType  *EngineTypePredicate    `json:"engineType,omitempty"`
	Vendor      *VendorPredicate        `json:"vendor,omitempty"`
	SourceIP    *StringPredicate        `json:"sourceIp,omitempty"`
	Muted       *BooleanPredicate       `json:"muted,omitempty"`
}

type StoryIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type StoryInput struct {
	Paging *PagingInput        `json:"paging"`
	Sort   []*StorySortInput   `json:"sort,omitempty"`
	Filter []*StoryFilterInput `json:"filter"`
}

type StoryProducerPredicate struct {
	In    []StoryProducerEnum `json:"in,omitempty"`
	NotIn []StoryProducerEnum `json:"not_in,omitempty"`
}

type StorySeverityPredicate struct {
	In    []SeverityEnum `json:"in,omitempty"`
	NotIn []SeverityEnum `json:"not_in,omitempty"`
}

type StorySortInput struct {
	FieldName StorySortFieldName `json:"fieldName"`
	Order     *SortDirectionEnum `json:"order,omitempty"`
}

type StoryStatusPredicate struct {
	In    []StoryStatusEnum `json:"in,omitempty"`
	NotIn []StoryStatusEnum `json:"not_in,omitempty"`
}

type StoryVerdictPredicate struct {
	In    []StoryVerdictEnum `json:"in,omitempty"`
	NotIn []StoryVerdictEnum `json:"not_in,omitempty"`
}

type StringPredicate struct {
	In       []*string `json:"in,omitempty"`
	NotIn    []*string `json:"not_in,omitempty"`
	Contains *string   `json:"contains,omitempty"`
}

type StringValue struct {
	String *string `json:"string,omitempty"`
}

func (StringValue) IsValue() {}

type SubDomain struct {
	AccountID   string `json:"accountId"`
	AccountName string `json:"accountName"`
	AccountType string `json:"accountType"`
	SubDomain   string `json:"subDomain"`
}

type SubscriptionGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionGroupRef) GetName() string { return this.Name }

type SubscriptionGroupRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

type SubscriptionMailingListRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionMailingListRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionMailingListRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionMailingListRef) GetName() string { return this.Name }

type SubscriptionMailingListRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

type SubscriptionWebhookRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionWebhookRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionWebhookRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionWebhookRef) GetName() string { return this.Name }

type SubscriptionWebhookRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

type SystemGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SystemGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SystemGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SystemGroupRef) GetName() string { return this.Name }

type SystemGroupRefInput struct {
	Input string      `json:"input"`
	By    ObjectRefBy `json:"by"`
}

type Threat struct {
	// Unique Cato ID for this threat
	ID string `json:"id"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// Timestamp for the first incident signal related to this story
	LastSignal string `json:"lastSignal"`
	// XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string `json:"producerName"`
	// Enum for the connection for this incident (ie. site, host, user)
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string `json:"indication"`
	// Category for the indication ID related to the story
	QueryName *string `json:"queryName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// The ticket an analyst created for this story
	Ticket *string `json:"ticket,omitempty"`
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	Status *StoryStatusEnum `json:"status,omitempty"`
	// The value is TRUE when the story is currently being researched by Security Analysts
	Research *bool `json:"research,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Cato ID and name for the user
	User *UserRef `json:"user,omitempty"`
	// Data for stories that are similar
	SimilarStoriesData []*SimilarStoryData `json:"similarStoriesData"`
	// Enum for Cato’s predicted verdict of the story (ie. Malicious, Benign)
	PredictedVerdict *StoryVerdictEnum `json:"predictedVerdict,omitempty"`
	// Cato’s predicted threat type for the story
	PredictedThreatType *string `json:"predictedThreatType,omitempty"`
	// Cato ID for the site that is the source of the threat
	SrcSiteID *string `json:"srcSiteId,omitempty"`
	// Cardinality of traffic flows for the threat
	FlowsCardinality *int64 `json:"flowsCardinality,omitempty"`
	// The estimated risk level of the threat (ie. Malicious, High, Low)
	RiskLevel *RiskLevelEnum `json:"riskLevel,omitempty"`
	// OS for device or host that is the threat target
	Os *string `json:"os,omitempty"`
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
	// The source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Username for the device
	LogonName *string `json:"logonName,omitempty"`
	// Traffic direction for the threat
	Direction *string `json:"direction,omitempty"`
	// Client Class for the traffic flow
	ClientClass []string `json:"clientClass"`
	// Data for the Cato event for this story
	Events []*Event `json:"events,omitempty"`
	// Mitre data for the story (ie. ID, name)
	Mitres []*Mitre `json:"mitres,omitempty"`
	// Timeseries data for the incident
	TimeSeries []*IncidentTimeseries `json:"timeSeries,omitempty"`
	// Data about the target of the threat
	Targets []*IncidentTargetRep `json:"targets"`
	// Data about the traffic flow for the threat
	Flows []*IncidentFlow `json:"flows,omitempty"`
}

func (Threat) IsMergedIncident() {}

// Unique Cato ID for each story
func (this Threat) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this Threat) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this Threat) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this Threat) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this Threat) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this Threat) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this Threat) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this Threat) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this Threat) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this Threat) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this Threat) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this Threat) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this Threat) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this Threat) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this Threat) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this Threat) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this Threat) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this Threat) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this Threat) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this Threat) GetUser() *UserRef                      { return this.User }
func (this Threat) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this Threat) GetPredictedThreatType() *string        { return this.PredictedThreatType }

type ThreatPrevention struct {
	ID                      string                    `json:"id"`
	FirstSignal             string                    `json:"firstSignal"`
	LastSignal              string                    `json:"lastSignal"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Indication              string                    `json:"indication"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Source                  *string                   `json:"source,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	SiteName                *string                   `json:"siteName,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	SrcSiteID               *string                   `json:"srcSiteId,omitempty"`
	FlowsCardinality        *int64                    `json:"flowsCardinality,omitempty"`
	RiskLevel               *RiskLevelEnum            `json:"riskLevel,omitempty"`
	Os                      *string                   `json:"os,omitempty"`
	DeviceName              *string                   `json:"deviceName,omitempty"`
	MacAddress              *string                   `json:"macAddress,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	LogonName               *string                   `json:"logonName,omitempty"`
	Direction               *string                   `json:"direction,omitempty"`
	ClientClass             []string                  `json:"clientClass"`
	Events                  []*Event                  `json:"events,omitempty"`
	Mitres                  []*Mitre                  `json:"mitres,omitempty"`
	TimeSeries              []*IncidentTimeseries     `json:"timeSeries,omitempty"`
	Targets                 []*IncidentTargetRep      `json:"targets"`
	ThreatPreventionsEvents []*ThreatPreventionEvents `json:"threatPreventionsEvents,omitempty"`
}

func (ThreatPrevention) IsMergedIncident() {}

// Unique Cato ID for each story
func (this ThreatPrevention) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this ThreatPrevention) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this ThreatPrevention) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this ThreatPrevention) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this ThreatPrevention) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this ThreatPrevention) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this ThreatPrevention) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this ThreatPrevention) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this ThreatPrevention) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this ThreatPrevention) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this ThreatPrevention) GetTicket() *string { return this.Ticket }

// Enum for the status of this story (ie. Open, Closed, Monitoring)
func (this ThreatPrevention) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this ThreatPrevention) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this ThreatPrevention) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this ThreatPrevention) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this ThreatPrevention) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this ThreatPrevention) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this ThreatPrevention) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this ThreatPrevention) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this ThreatPrevention) GetUser() *UserRef                      { return this.User }
func (this ThreatPrevention) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this ThreatPrevention) GetPredictedThreatType() *string        { return this.PredictedThreatType }

type ThreatPreventionEvents struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	Method                 *string `json:"method,omitempty"`
	URL                    *string `json:"url,omitempty"`
	Target                 *string `json:"target,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Referrer               *string `json:"referrer,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
}

// Threat Prevention (TP) license details
type ThreatPreventionLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
}

func (ThreatPreventionLicense) IsLicense()                   {}
func (this ThreatPreventionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ThreatPreventionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ThreatPreventionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ThreatPreventionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ThreatPreventionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ThreatPreventionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ThreatPreventionLicense) GetLastUpdated() *string { return this.LastUpdated }

// An object for marking specific events in time.
type TimeAnnotation struct {
	// Timestamp of the event
	Time float64 `json:"time"`
	// Description of the event
	Label string `json:"label"`
	// Brief description of the event
	ShortLabel string `json:"shortLabel"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type AnnotationType `json:"type"`
}

type TimeFramePredicate struct {
	Time              string             `json:"time"`
	TimeFrameModifier *TimeFrameModifier `json:"timeFrameModifier,omitempty"`
}

// An object for marking durations!
type TimePeriod struct {
	// An tuple of two numbers representing  start time, end time in ms since epoch, start bucket index, end bucket index
	Duration []float64 `json:"duration"`
	// Label that describes the metrics
	Title string `json:"title"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type PeriodType `json:"type"`
}

type TimelineItem struct {
	// Timestamp the story was created
	CreatedAt string `json:"createdAt"`
	// Description for the story in the timeline
	Description string `json:"description"`
	// Status of the timeline item
	Context string `json:"context"`
	// Enum for the type (ie. Diff, Action, Comment)
	Type TimelineTypeEnum `json:"type"`
	// Description for the story in the timeline
	Descriptions []string `json:"descriptions"`
	// Enum for the timeline category (ie. Information, Warning, Error)
	Category *TimelineItemCategoryEnum `json:"category,omitempty"`
	// Additional information about this timeline item
	AdditionalInfo *string `json:"additionalInfo,omitempty"`
	// Data about the analyst for this timeline item (ie. name, email)
	AnalystInfo *AnalystInfo `json:"analystInfo,omitempty"`
}

type Timeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// Indicates the type of the timeseries
	Label string `json:"label"`
	// List of dimension values for this timeseries
	Dimensions []*DimensionData `json:"dimensions,omitempty"`
	// Timeseries key: measure and dimension values
	Key *TimeseriesKey `json:"key,omitempty"`
	// Summary of the metrics over the given time frame
	Sum *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string `json:"info,omitempty"`
}

type TimeseriesKey struct {
	// Measure field
	MeasureFieldName string `json:"measureFieldName"`
	// List of dimension key-value pair for this timeseries key
	Dimensions []*DimensionKey `json:"dimensions,omitempty"`
}

type UpdateAccountRoleInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type UpdateAdminInput struct {
	FirstName            *string                 `json:"firstName,omitempty"`
	LastName             *string                 `json:"lastName,omitempty"`
	PasswordNeverExpires *bool                   `json:"passwordNeverExpires,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateAdminRoleInput struct {
	Role            *UpdateAccountRoleInput `json:"role"`
	AllowedEntities []*EntityInput          `json:"allowedEntities,omitempty"`
	AllowedAccounts []string                `json:"allowedAccounts,omitempty"`
}

type UpdateHaInput struct {
	PrimaryManagementIP   *string `json:"primaryManagementIp,omitempty"`
	SecondaryManagementIP *string `json:"secondaryManagementIp,omitempty"`
	Vrid                  *int64  `json:"vrid,omitempty"`
}

type UpdateHaPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsInput struct {
	// Determines the protocol for establishing the Security Association (SA) Tunnel. Valid values are:
	// Responder-Only Mode: Cato Cloud only responds to incoming requests by the initiator (e.g. a Firewall device) to establish a security association.
	// Bidirectional Mode: Both Cato Cloud and the peer device on customer site can initiate the IPSec SA establishment.
	ConnectionMode *ConnectionMode `json:"connectionMode,omitempty"`
	// The authentication identification type used for SA authentication. When using “BIDIRECTIONAL”, it is set to “IPv4” by default. Other methods are available in Responder mode only.
	IdentificationType *IdentificationType `json:"identificationType,omitempty"`
	// The init message parameters
	InitMessage *IpsecIkeV2MessageInput `json:"initMessage,omitempty"`
	// The auth message parameters.
	AuthMessage *IpsecIkeV2MessageInput `json:"authMessage,omitempty"`
	// The local IP ranges for the SAs
	NetworkRanges []*string `json:"networkRanges,omitempty"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
	// The local ID for the site
	LocalID *string `json:"localId,omitempty"`
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*UpdateIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type UpdateIpsecIkeV2SiteTunnelPayload struct {
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *UpdateIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *UpdateIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsPayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
	// The primary multi-tunnel
	Primary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// The secondary multi-tunnel
	Secondary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
}

type UpdateIpsecIkeV2TunnelInput struct {
	// The ID of the tunnel
	TunnelID IPSecV2InterfaceID `json:"tunnelId"`
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk *string `json:"psk,omitempty"`
}

type UpdateIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string `json:"publicCatoIpId,omitempty"`
	// The PoP location ID
	PopLocationID *string                        `json:"popLocationId,omitempty"`
	Tunnels       []*UpdateIpsecIkeV2TunnelInput `json:"tunnels"`
}

type UpdateNetworkRangeInput struct {
	Name             *string     `json:"name,omitempty"`
	RangeType        *SubnetType `json:"rangeType,omitempty"`
	Subnet           *string     `json:"subnet,omitempty"`
	TranslatedSubnet *string     `json:"translatedSubnet,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway *string `json:"gateway,omitempty"`
	// Only relevant for VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector *bool `json:"mdnsReflector,omitempty"`
}

type UpdateNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type UpdateSiteGeneralDetailsInput struct {
	Name         *string                  `json:"name,omitempty"`
	SiteType     *SiteType                `json:"siteType,omitempty"`
	Description  *string                  `json:"description,omitempty"`
	SiteLocation *UpdateSiteLocationInput `json:"siteLocation,omitempty"`
}

type UpdateSiteGeneralDetailsPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateSiteLocationInput struct {
	CountryCode *string `json:"countryCode,omitempty"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    *string `json:"timezone,omitempty"`
	Address     *string `json:"address,omitempty"`
}

type UpdateSocketInterfaceInput struct {
	DestType SocketInterfaceDestType `json:"destType"`
	Name     *string                 `json:"name,omitempty"`
	// Only relevant for LAN, VRRP_AND_LAN, LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lan *SocketInterfaceLanInput `json:"lan,omitempty"`
	// Only relevant for CATO, ALTERNATIVE, LAYER_2_WAN
	Bandwidth *SocketInterfaceBandwidthInput `json:"bandwidth,omitempty"`
	// Only relevant for CATO
	Wan *SocketInterfaceWanInput `json:"wan,omitempty"`
	// Only relevant for CATO
	OffCloud *SocketInterfaceOffCloudInput `json:"offCloud,omitempty"`
	// Only relevant for ALTERNATIVE, LAYER_2_WAN
	AltWan *SocketInterfaceAltWanInput `json:"altWan,omitempty"`
	// Only relevant for LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lag *SocketInterfaceLagInput `json:"lag,omitempty"`
	// Only relevant for VRRP
	Vrrp *SocketInterfaceVrrpInput `json:"vrrp,omitempty"`
}

type UpdateSocketInterfacePayload struct {
	SiteID            string                `json:"siteId"`
	SocketInterfaceID SocketInterfaceIDEnum `json:"socketInterfaceId"`
}

type UpdateStaticHostInput struct {
	Name       *string `json:"name,omitempty"`
	IP         *string `json:"ip,omitempty"`
	MacAddress *string `json:"macAddress,omitempty"`
}

type UpdateStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// Basic User configuration information
type UserInfo struct {
	// Name of the VPN user
	Name *string `json:"name,omitempty"`
	// Status of the Client as the type STRING
	Status *OperationalStatus `json:"status,omitempty"`
	// Email address of the VPN user
	Email *string `json:"email,omitempty"`
	// Timestamp when the VPN user was created in the account
	CreationTime *string `json:"creationTime,omitempty"`
	// Phone number for the VPN user
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// User creation mechanism, current supported REGULAR or LDAP
	Origin *string `json:"origin,omitempty"`
	// Additional authentication mechanism, currently MFA or NONE
	AuthMethod *string `json:"authMethod,omitempty"`
}

type UserRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UserRef) IsObjectRef() {}

// Object's unique identifier
func (this UserRef) GetID() string { return this.ID }

// Object's unique name
func (this UserRef) GetName() string { return this.Name }

type UserRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type UserSnapshot struct {
	// VPN user ID
	ID *string `json:"id,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *OperationalStatus `json:"operationalStatus,omitempty"`
	// User name from configuration, same as info.name
	Name *string `json:"name,omitempty"`
	// The host name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// How long has the user been connected (in seconds)
	Uptime *int64 `json:"uptime,omitempty"`
	// Last time the user was connected (relevant if not currently connected)
	LastConnected *string `json:"lastConnected,omitempty"`
	// VPN client version string
	Version *string `json:"version,omitempty"`
	// VPN client version number
	VersionNumber *int64 `json:"versionNumber,omitempty"`
	// ID of the PoP that the Client is connected to
	PopID *int64 `json:"popID,omitempty"`
	// Name of the PoP that the VPN user is connected to
	PopName *string `json:"popName,omitempty"`
	// IP address of the Client
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the Client
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// IP address of the PoP that the Client is connected to
	InternalIP *string `json:"internalIP,omitempty"`
	// Operating system of the device the Client is running on
	OsType *string `json:"osType,omitempty"`
	// Version of the operating system for the device
	OsVersion *string `json:"osVersion,omitempty"`
	// Data related to the Client
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// In this state the client does not create its own connection, but reuses
	// the Office's socket connection
	ConnectedInOffice *bool `json:"connectedInOffice,omitempty"`
	// General information about the VPN user
	Info *UserInfo `json:"info,omitempty"`
	// Data related to the most recent completed VPN connections
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
}

type UsersGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UsersGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this UsersGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this UsersGroupRef) GetName() string { return this.Name }

type UsersGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type VendorPredicate struct {
	In    []VendorEnum `json:"in,omitempty"`
	NotIn []VendorEnum `json:"not_in,omitempty"`
}

type WanFirewallAddRuleDataInput struct {
	Enabled     bool   `json:"enabled"`
	Name        string `json:"name"`
	Description string `json:"description"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceInput `json:"source"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRefInput `json:"country"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationInput `json:"application"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule  *PolicyScheduleInput     `json:"schedule"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions"`
}

// Rule parameters and relevant position
type WanFirewallAddRuleInput struct {
	// Parameters for the rule you are adding
	Rule *WanFirewallAddRuleDataInput `json:"rule"`
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
}

// Application match criteria set
type WanFirewallApplication struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
}

// Application match criteria set
type WanFirewallApplicationInput struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
}

// Application match criteria set
type WanFirewallApplicationUpdateInput struct {
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
}

// Returns the settings for Destination of a Wan Firewall rule
type WanFirewallDestination struct {
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule
type WanFirewallDestinationInput struct {
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule
type WanFirewallDestinationUpdateInput struct {
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
}

type WanFirewallPolicy struct {
	Enabled  bool                      `json:"enabled"`
	Rules    []*WanFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload   `json:"sections"`
	Audit    *PolicyAudit              `json:"audit,omitempty"`
	Revision *PolicyRevision           `json:"revision,omitempty"`
}

func (WanFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this WanFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this WanFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this WanFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this WanFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this WanFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type WanFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Wan Firewall policy information provided in the API response
type WanFirewallPolicyMutationPayload struct {
	Policy *WanFirewallPolicy     `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
	Errors []*PolicyMutationError `json:"errors"`
}

func (WanFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this WanFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this WanFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Wan Firewall Policy information returned to the caller in the API response.
type WanFirewallPolicyMutations struct {
	// Add a new rule to the Wan Firewall policy.
	AddRule *WanFirewallRuleMutationPayload `json:"addRule"`
	// Update an existing rule of the Wan Firewall policy.
	UpdateRule *WanFirewallRuleMutationPayload `json:"updateRule"`
	// Remove an existing rule from the Wan Firewall policy.
	RemoveRule *WanFirewallRuleMutationPayload `json:"removeRule"`
	// Change the relative location of an existing rule within the Wan Firewall policy.
	MoveRule *WanFirewallRuleMutationPayload `json:"moveRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection *PolicySectionMutationPayload `json:"addSection"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	CreatePolicyRevision  *WanFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	PublishPolicyRevision *WanFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	DiscardPolicyRevision *WanFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *WanFirewallPolicyMutationPayload `json:"updatePolicy"`
}

type WanFirewallPolicyQueries struct {
	Policy    *WanFirewallPolicy      `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanFirewallRule struct {
	// Rule ID
	ID string `json:"id"`
	// Name of the rule
	Name string `json:"name"`
	// Description for the rule
	Description string `json:"description"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSource `json:"source"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestination `json:"destination"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplication `json:"application"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceType `json:"service"`
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule  *PolicySchedule          `json:"schedule"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleException `json:"exceptions"`
}

func (WanFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this WanFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this WanFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this WanFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this WanFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this WanFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this WanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleException struct {
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Source matching criteria for the exception.
	Source *WanFirewallSource `json:"source"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestination `json:"destination"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Application matching criteria for the exception.
	Application *WanFirewallApplication `json:"application"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceType `json:"service"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleExceptionInput struct {
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Source matching criteria for the exception.
	Source *WanFirewallSourceInput `json:"source"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Application matching criteria for the exception.
	Application *WanFirewallApplicationInput `json:"application"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
}

type WanFirewallRuleMutationPayload struct {
	Rule   *WanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
	Errors []*PolicyMutationError  `json:"errors"`
}

func (WanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this WanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this WanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Wan Firewall policy information for a specific revision
type WanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Rule       *WanFirewallRule              `json:"rule"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
}

func (WanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this WanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this WanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this WanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceType struct {
	Standard []*ServiceRef    `json:"standard"`
	Custom   []*CustomService `json:"custom"`
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceTypeInput struct {
	Standard []*ServiceRefInput    `json:"standard"`
	Custom   []*CustomServiceInput `json:"custom"`
}

// Add the Service Type to which this Internet Firewall rule applies
type WanFirewallServiceTypeUpdateInput struct {
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
}

// Returns the settings for Source of an Wan Firewall rule
type WanFirewallSource struct {
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
}

// Input of the settings for Source of an Wan Firewall rule
type WanFirewallSourceInput struct {
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
}

// Input of the settings for Source of an Wan Firewall rule
type WanFirewallSourceUpdateInput struct {
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
}

type WanFirewallUpdateRuleDataInput struct {
	Enabled     *bool   `json:"enabled,omitempty"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceUpdateInput `json:"source,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRefInput `json:"country,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationUpdateInput `json:"application,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// The action applied by the Internet Firewall if the rule is matched
	Action *WanFirewallActionEnum `json:"action,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule  *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	Direction *WanFirewallDirectionEnum  `json:"direction,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions,omitempty"`
}

type WanFirewallUpdateRuleInput struct {
	ID   string                          `json:"id"`
	Rule *WanFirewallUpdateRuleDataInput `json:"rule"`
}

type Xdr struct {
	// Define the paging, sort, and filter arguments to define the XDR stories that are returned in the query
	Stories *StoriesData `json:"stories,omitempty"`
	// Define either the story ID, or the incident ID and producer arguments, to query the specific XDR story
	Story *Story `json:"story,omitempty"`
}

// XDR Pro (extended detection and response) service license details
type XdrProLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// The number of knowledge users that the XDR Pro service refers to
	Total int64 `json:"total"`
}

func (XdrProLicense) IsLicense()                   {}
func (this XdrProLicense) GetDescription() *string { return this.Description }

// License plan type
func (this XdrProLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this XdrProLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this XdrProLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this XdrProLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this XdrProLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this XdrProLicense) GetLastUpdated() *string { return this.LastUpdated }

func (XdrProLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this XdrProLicense) GetTotal() int64 { return this.Total }

// ZTNA remote users license
type ZtnaUsersLicense struct {
	Description *string `json:"description,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Specify a license group that you are limiting the number of ZTNA users
	ZtnaUsersLicenseGroup ZtnaUsersLicenseGroup `json:"ztnaUsersLicenseGroup"`
	// The maximum amount of ZTNA users for the region.
	Total int64 `json:"total"`
}

func (ZtnaUsersLicense) IsLicense()                   {}
func (this ZtnaUsersLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ZtnaUsersLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ZtnaUsersLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ZtnaUsersLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ZtnaUsersLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ZtnaUsersLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ZtnaUsersLicense) GetLastUpdated() *string { return this.LastUpdated }

func (ZtnaUsersLicense) IsQuantifiableLicense() {}

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this ZtnaUsersLicense) GetTotal() int64 { return this.Total }

// Global ZTNA license usage and allocation across all accounts
type ZtnaUsersLicenseAllocations struct {
	// Total ZTNA licenses for users
	Total int64 `json:"total"`
	// Total users allocated a ZTNA license
	Allocated int64 `json:"allocated"`
	// Available users not yet allocated a license
	Available int64 `json:"available"`
}

type AccountType string

const (
	AccountTypeSystem   AccountType = "SYSTEM"
	AccountTypeRegular  AccountType = "REGULAR"
	AccountTypeReseller AccountType = "RESELLER"
	AccountTypeAll      AccountType = "ALL"
)

var AllAccountType = []AccountType{
	AccountTypeSystem,
	AccountTypeRegular,
	AccountTypeReseller,
	AccountTypeAll,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeSystem, AccountTypeRegular, AccountTypeReseller, AccountTypeAll:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggregationType string

const (
	AggregationTypeSum           AggregationType = "sum"
	AggregationTypeCount         AggregationType = "count"
	AggregationTypeCountDistinct AggregationType = "count_distinct"
	AggregationTypeDistinct      AggregationType = "distinct"
	AggregationTypeAvg           AggregationType = "avg"
	AggregationTypeMax           AggregationType = "max"
	AggregationTypeMin           AggregationType = "min"
	AggregationTypeAny           AggregationType = "any"
	AggregationTypeChanges       AggregationType = "changes"
	AggregationTypeUniqSet       AggregationType = "uniq_set"
)

var AllAggregationType = []AggregationType{
	AggregationTypeSum,
	AggregationTypeCount,
	AggregationTypeCountDistinct,
	AggregationTypeDistinct,
	AggregationTypeAvg,
	AggregationTypeMax,
	AggregationTypeMin,
	AggregationTypeAny,
	AggregationTypeChanges,
	AggregationTypeUniqSet,
}

func (e AggregationType) IsValid() bool {
	switch e {
	case AggregationTypeSum, AggregationTypeCount, AggregationTypeCountDistinct, AggregationTypeDistinct, AggregationTypeAvg, AggregationTypeMax, AggregationTypeMin, AggregationTypeAny, AggregationTypeChanges, AggregationTypeUniqSet:
		return true
	}
	return false
}

func (e AggregationType) String() string {
	return string(e)
}

func (e *AggregationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationType", str)
	}
	return nil
}

func (e AggregationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertClassificationEnum string

const (
	AlertClassificationEnumFalsePositive                 AlertClassificationEnum = "FALSE_POSITIVE"
	AlertClassificationEnumTruePositive                  AlertClassificationEnum = "TRUE_POSITIVE"
	AlertClassificationEnumInformationalExpectedActivity AlertClassificationEnum = "INFORMATIONAL_EXPECTED_ACTIVITY"
)

var AllAlertClassificationEnum = []AlertClassificationEnum{
	AlertClassificationEnumFalsePositive,
	AlertClassificationEnumTruePositive,
	AlertClassificationEnumInformationalExpectedActivity,
}

func (e AlertClassificationEnum) IsValid() bool {
	switch e {
	case AlertClassificationEnumFalsePositive, AlertClassificationEnumTruePositive, AlertClassificationEnumInformationalExpectedActivity:
		return true
	}
	return false
}

func (e AlertClassificationEnum) String() string {
	return string(e)
}

func (e *AlertClassificationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertClassificationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertClassificationEnum", str)
	}
	return nil
}

func (e AlertClassificationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertDeterminationEnum string

const (
	AlertDeterminationEnumApt                       AlertDeterminationEnum = "APT"
	AlertDeterminationEnumMalware                   AlertDeterminationEnum = "MALWARE"
	AlertDeterminationEnumSecurityPersonnel         AlertDeterminationEnum = "SECURITY_PERSONNEL"
	AlertDeterminationEnumSecurityTesting           AlertDeterminationEnum = "SECURITY_TESTING"
	AlertDeterminationEnumUnwantedSoftware          AlertDeterminationEnum = "UNWANTED_SOFTWARE"
	AlertDeterminationEnumMultiStagedAttack         AlertDeterminationEnum = "MULTI_STAGED_ATTACK"
	AlertDeterminationEnumCompromisedAccount        AlertDeterminationEnum = "COMPROMISED_ACCOUNT"
	AlertDeterminationEnumPhishing                  AlertDeterminationEnum = "PHISHING"
	AlertDeterminationEnumMaliciousUserActivity     AlertDeterminationEnum = "MALICIOUS_USER_ACTIVITY"
	AlertDeterminationEnumNotMalicious              AlertDeterminationEnum = "NOT_MALICIOUS"
	AlertDeterminationEnumNotEnoughDataToValidate   AlertDeterminationEnum = "NOT_ENOUGH_DATA_TO_VALIDATE"
	AlertDeterminationEnumConfirmedActivity         AlertDeterminationEnum = "CONFIRMED_ACTIVITY"
	AlertDeterminationEnumLineOfBusinessApplication AlertDeterminationEnum = "LINE_OF_BUSINESS_APPLICATION"
	AlertDeterminationEnumOther                     AlertDeterminationEnum = "OTHER"
)

var AllAlertDeterminationEnum = []AlertDeterminationEnum{
	AlertDeterminationEnumApt,
	AlertDeterminationEnumMalware,
	AlertDeterminationEnumSecurityPersonnel,
	AlertDeterminationEnumSecurityTesting,
	AlertDeterminationEnumUnwantedSoftware,
	AlertDeterminationEnumMultiStagedAttack,
	AlertDeterminationEnumCompromisedAccount,
	AlertDeterminationEnumPhishing,
	AlertDeterminationEnumMaliciousUserActivity,
	AlertDeterminationEnumNotMalicious,
	AlertDeterminationEnumNotEnoughDataToValidate,
	AlertDeterminationEnumConfirmedActivity,
	AlertDeterminationEnumLineOfBusinessApplication,
	AlertDeterminationEnumOther,
}

func (e AlertDeterminationEnum) IsValid() bool {
	switch e {
	case AlertDeterminationEnumApt, AlertDeterminationEnumMalware, AlertDeterminationEnumSecurityPersonnel, AlertDeterminationEnumSecurityTesting, AlertDeterminationEnumUnwantedSoftware, AlertDeterminationEnumMultiStagedAttack, AlertDeterminationEnumCompromisedAccount, AlertDeterminationEnumPhishing, AlertDeterminationEnumMaliciousUserActivity, AlertDeterminationEnumNotMalicious, AlertDeterminationEnumNotEnoughDataToValidate, AlertDeterminationEnumConfirmedActivity, AlertDeterminationEnumLineOfBusinessApplication, AlertDeterminationEnumOther:
		return true
	}
	return false
}

func (e AlertDeterminationEnum) String() string {
	return string(e)
}

func (e *AlertDeterminationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertDeterminationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertDeterminationEnum", str)
	}
	return nil
}

func (e AlertDeterminationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AnnotationType string

const (
	// The site connects to a different PoP
	AnnotationTypePopChange AnnotationType = "popChange"
	// Change for HA status role
	AnnotationTypeRoleChange AnnotationType = "roleChange"
	// The ISP IP address (remote IP) changed
	AnnotationTypeRemoteIPChange AnnotationType = "remoteIPChange"
	// Other events that are included in annotations
	AnnotationTypeGeneric AnnotationType = "generic"
)

var AllAnnotationType = []AnnotationType{
	AnnotationTypePopChange,
	AnnotationTypeRoleChange,
	AnnotationTypeRemoteIPChange,
	AnnotationTypeGeneric,
}

func (e AnnotationType) IsValid() bool {
	switch e {
	case AnnotationTypePopChange, AnnotationTypeRoleChange, AnnotationTypeRemoteIPChange, AnnotationTypeGeneric:
		return true
	}
	return false
}

func (e AnnotationType) String() string {
	return string(e)
}

func (e *AnnotationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnotationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnnotationType", str)
	}
	return nil
}

func (e AnnotationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApnMethod string

const (
	ApnMethodMethodUnknown ApnMethod = "METHOD_UNKNOWN"
	ApnMethodMethodAuto    ApnMethod = "METHOD_AUTO"
	ApnMethodMethodManual  ApnMethod = "METHOD_MANUAL"
)

var AllApnMethod = []ApnMethod{
	ApnMethodMethodUnknown,
	ApnMethodMethodAuto,
	ApnMethodMethodManual,
}

func (e ApnMethod) IsValid() bool {
	switch e {
	case ApnMethodMethodUnknown, ApnMethodMethodAuto, ApnMethodMethodManual:
		return true
	}
	return false
}

func (e ApnMethod) String() string {
	return string(e)
}

func (e *ApnMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApnMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApnMethod", str)
	}
	return nil
}

func (e ApnMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AppStatsFieldName string

const (
	// The application identifier
	AppStatsFieldNameApp AppStatsFieldName = "app"
	// The application name
	AppStatsFieldNameApplication AppStatsFieldName = "application"
	// new cloud application identifier
	AppStatsFieldNameNewApp        AppStatsFieldName = "new_app"
	AppStatsFieldNameDiscoveredApp AppStatsFieldName = "discovered_app"
	// the total sum of upstream and downstream data in bytes
	AppStatsFieldNameTraffic AppStatsFieldName = "traffic"
	// data uploaded to cloud applications
	AppStatsFieldNameUpstream AppStatsFieldName = "upstream"
	// data downloaded from cloud applications
	AppStatsFieldNameDownstream AppStatsFieldName = "downstream"
	// the application risk score assigned by Cato
	AppStatsFieldNameRiskScore AppStatsFieldName = "risk_score"
	AppStatsFieldNameRiskLevel AppStatsFieldName = "risk_level"
	// Is the application defined as sanctioned?
	AppStatsFieldNameSanctioned AppStatsFieldName = "sanctioned"
	// the country in which the registered application headquarteres is located
	AppStatsFieldNameHqLocation AppStatsFieldName = "hq_location"
	// indicates whether the application is considered cloud app/SaaS app
	AppStatsFieldNameIsCloudApp AppStatsFieldName = "is_cloud_app"
	// Cato system category of the application
	AppStatsFieldNameCategory AppStatsFieldName = "category"
	// Application description
	AppStatsFieldNameDescription AppStatsFieldName = "description"
	AppStatsFieldNameIP          AppStatsFieldName = "ip"
	// Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnet AppStatsFieldName = "subnet"
	AppStatsFieldNameDomain AppStatsFieldName = "domain"
	// IP for destination host or Cato Client
	AppStatsFieldNameDestIP AppStatsFieldName = "dest_ip"
	// User identifier
	AppStatsFieldNameUserID AppStatsFieldName = "user_id"
	// User name
	AppStatsFieldNameUserName AppStatsFieldName = "user_name"
	// Source site or remote user identifier
	AppStatsFieldNameSrcSiteID AppStatsFieldName = "src_site_id"
	// Source site or remote user name
	AppStatsFieldNameSrcSiteName AppStatsFieldName = "src_site_name"
	// Country in which the source host is located
	AppStatsFieldNameSiteCountry AppStatsFieldName = "site_country"
	// State in which the source host is located
	AppStatsFieldNameSiteState    AppStatsFieldName = "site_state"
	AppStatsFieldNameVpnUserID    AppStatsFieldName = "vpn_user_id"
	AppStatsFieldNameFlowsCreated AppStatsFieldName = "flows_created"
	// Destination site or remote user identifier
	AppStatsFieldNameDestSite AppStatsFieldName = "dest_site"
	// Destination is site or remote user
	AppStatsFieldNameDestIsSiteOrVpn AppStatsFieldName = "dest_is_site_or_vpn"
	// Destination Site or remote user identifier
	AppStatsFieldNameDestSiteID AppStatsFieldName = "dest_site_id"
	// Destination Site or remote user name
	AppStatsFieldNameDestSiteName AppStatsFieldName = "dest_site_name"
	// Traffic direction
	AppStatsFieldNameTrafficDirection AppStatsFieldName = "traffic_direction"
	// Name for device related to the traffic
	AppStatsFieldNameDeviceName AppStatsFieldName = "device_name"
	// Active Directory name
	AppStatsFieldNameAdName AppStatsFieldName = "ad_name"
	// IP for source host or Cato Client
	AppStatsFieldNameSrcIP AppStatsFieldName = "src_ip"
	// Name for Socket interface
	AppStatsFieldNameSocketInterface AppStatsFieldName = "socket_interface"
	// Source is site or remote user
	AppStatsFieldNameSrcIsSiteOrVpn AppStatsFieldName = "src_is_site_or_vpn"
)

var AllAppStatsFieldName = []AppStatsFieldName{
	AppStatsFieldNameApp,
	AppStatsFieldNameApplication,
	AppStatsFieldNameNewApp,
	AppStatsFieldNameDiscoveredApp,
	AppStatsFieldNameTraffic,
	AppStatsFieldNameUpstream,
	AppStatsFieldNameDownstream,
	AppStatsFieldNameRiskScore,
	AppStatsFieldNameRiskLevel,
	AppStatsFieldNameSanctioned,
	AppStatsFieldNameHqLocation,
	AppStatsFieldNameIsCloudApp,
	AppStatsFieldNameCategory,
	AppStatsFieldNameDescription,
	AppStatsFieldNameIP,
	AppStatsFieldNameSubnet,
	AppStatsFieldNameDomain,
	AppStatsFieldNameDestIP,
	AppStatsFieldNameUserID,
	AppStatsFieldNameUserName,
	AppStatsFieldNameSrcSiteID,
	AppStatsFieldNameSrcSiteName,
	AppStatsFieldNameSiteCountry,
	AppStatsFieldNameSiteState,
	AppStatsFieldNameVpnUserID,
	AppStatsFieldNameFlowsCreated,
	AppStatsFieldNameDestSite,
	AppStatsFieldNameDestIsSiteOrVpn,
	AppStatsFieldNameDestSiteID,
	AppStatsFieldNameDestSiteName,
	AppStatsFieldNameTrafficDirection,
	AppStatsFieldNameDeviceName,
	AppStatsFieldNameAdName,
	AppStatsFieldNameSrcIP,
	AppStatsFieldNameSocketInterface,
	AppStatsFieldNameSrcIsSiteOrVpn,
}

func (e AppStatsFieldName) IsValid() bool {
	switch e {
	case AppStatsFieldNameApp, AppStatsFieldNameApplication, AppStatsFieldNameNewApp, AppStatsFieldNameDiscoveredApp, AppStatsFieldNameTraffic, AppStatsFieldNameUpstream, AppStatsFieldNameDownstream, AppStatsFieldNameRiskScore, AppStatsFieldNameRiskLevel, AppStatsFieldNameSanctioned, AppStatsFieldNameHqLocation, AppStatsFieldNameIsCloudApp, AppStatsFieldNameCategory, AppStatsFieldNameDescription, AppStatsFieldNameIP, AppStatsFieldNameSubnet, AppStatsFieldNameDomain, AppStatsFieldNameDestIP, AppStatsFieldNameUserID, AppStatsFieldNameUserName, AppStatsFieldNameSrcSiteID, AppStatsFieldNameSrcSiteName, AppStatsFieldNameSiteCountry, AppStatsFieldNameSiteState, AppStatsFieldNameVpnUserID, AppStatsFieldNameFlowsCreated, AppStatsFieldNameDestSite, AppStatsFieldNameDestIsSiteOrVpn, AppStatsFieldNameDestSiteID, AppStatsFieldNameDestSiteName, AppStatsFieldNameTrafficDirection, AppStatsFieldNameDeviceName, AppStatsFieldNameAdName, AppStatsFieldNameSrcIP, AppStatsFieldNameSocketInterface, AppStatsFieldNameSrcIsSiteOrVpn:
		return true
	}
	return false
}

func (e AppStatsFieldName) String() string {
	return string(e)
}

func (e *AppStatsFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStatsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStatsFieldName", str)
	}
	return nil
}

func (e AppStatsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditFieldName string

const (
	// The admin whose action generated the record
	AuditFieldNameAdmin AuditFieldName = "admin"
	// The api key whose action generated the record
	AuditFieldNameAPIKey AuditFieldName = "apiKey"
	// The name of the object that was affected, e.g. 'My Site'
	AuditFieldNameModelName AuditFieldName = "model_name"
	// The ID of the admin whose action generated the record
	AuditFieldNameAdminID AuditFieldName = "admin_id"
	// Less granular than model_name, a general marker of the modified area: administration, configuration, security
	AuditFieldNameModule            AuditFieldName = "module"
	AuditFieldNameAuditCreationType AuditFieldName = "audit_creation_type"
	// Time the record was committed to storage
	AuditFieldNameInsertionDate AuditFieldName = "insertion_date"
	// the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`
	AuditFieldNameChangeType AuditFieldName = "change_type"
	// Time the record was created
	AuditFieldNameCreationDate AuditFieldName = "creation_date"
	// The type of object that was affected. e.g. Site, Socket, SocketInterface
	AuditFieldNameModelType AuditFieldName = "model_type"
	// The name of the account on which the record was created
	AuditFieldNameAccount AuditFieldName = "account"
	// The id of the account on which the record was created
	AuditFieldNameAccountID AuditFieldName = "account_id"
)

var AllAuditFieldName = []AuditFieldName{
	AuditFieldNameAdmin,
	AuditFieldNameAPIKey,
	AuditFieldNameModelName,
	AuditFieldNameAdminID,
	AuditFieldNameModule,
	AuditFieldNameAuditCreationType,
	AuditFieldNameInsertionDate,
	AuditFieldNameChangeType,
	AuditFieldNameCreationDate,
	AuditFieldNameModelType,
	AuditFieldNameAccount,
	AuditFieldNameAccountID,
}

func (e AuditFieldName) IsValid() bool {
	switch e {
	case AuditFieldNameAdmin, AuditFieldNameAPIKey, AuditFieldNameModelName, AuditFieldNameAdminID, AuditFieldNameModule, AuditFieldNameAuditCreationType, AuditFieldNameInsertionDate, AuditFieldNameChangeType, AuditFieldNameCreationDate, AuditFieldNameModelType, AuditFieldNameAccount, AuditFieldNameAccountID:
		return true
	}
	return false
}

func (e AuditFieldName) String() string {
	return string(e)
}

func (e *AuditFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditFieldName", str)
	}
	return nil
}

func (e AuditFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatoEndpointEngineType string

const (
	CatoEndpointEngineTypeBehavioral  CatoEndpointEngineType = "Behavioral"
	CatoEndpointEngineTypeAntiMalware CatoEndpointEngineType = "AntiMalware"
)

var AllCatoEndpointEngineType = []CatoEndpointEngineType{
	CatoEndpointEngineTypeBehavioral,
	CatoEndpointEngineTypeAntiMalware,
}

func (e CatoEndpointEngineType) IsValid() bool {
	switch e {
	case CatoEndpointEngineTypeBehavioral, CatoEndpointEngineTypeAntiMalware:
		return true
	}
	return false
}

func (e CatoEndpointEngineType) String() string {
	return string(e)
}

func (e *CatoEndpointEngineType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatoEndpointEngineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatoEndpointEngineType", str)
	}
	return nil
}

func (e CatoEndpointEngineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularDisconnectionReason string

const (
	CellularDisconnectionReasonReasonNone    CellularDisconnectionReason = "REASON_NONE"
	CellularDisconnectionReasonReasonTimeout CellularDisconnectionReason = "REASON_TIMEOUT"
)

var AllCellularDisconnectionReason = []CellularDisconnectionReason{
	CellularDisconnectionReasonReasonNone,
	CellularDisconnectionReasonReasonTimeout,
}

func (e CellularDisconnectionReason) IsValid() bool {
	switch e {
	case CellularDisconnectionReasonReasonNone, CellularDisconnectionReasonReasonTimeout:
		return true
	}
	return false
}

func (e CellularDisconnectionReason) String() string {
	return string(e)
}

func (e *CellularDisconnectionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularDisconnectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularDisconnectionReason", str)
	}
	return nil
}

func (e CellularDisconnectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularModemStatus string

const (
	CellularModemStatusStatusUnknown CellularModemStatus = "STATUS_UNKNOWN"
	CellularModemStatusStatusOk      CellularModemStatus = "STATUS_OK"
	CellularModemStatusStatusError   CellularModemStatus = "STATUS_ERROR"
)

var AllCellularModemStatus = []CellularModemStatus{
	CellularModemStatusStatusUnknown,
	CellularModemStatusStatusOk,
	CellularModemStatusStatusError,
}

func (e CellularModemStatus) IsValid() bool {
	switch e {
	case CellularModemStatusStatusUnknown, CellularModemStatusStatusOk, CellularModemStatusStatusError:
		return true
	}
	return false
}

func (e CellularModemStatus) String() string {
	return string(e)
}

func (e *CellularModemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularModemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularModemStatus", str)
	}
	return nil
}

func (e CellularModemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularNetworkType string

const (
	CellularNetworkTypeTypeUnknown CellularNetworkType = "TYPE_UNKNOWN"
	CellularNetworkTypeType2g      CellularNetworkType = "TYPE_2G"
	CellularNetworkTypeType3g      CellularNetworkType = "TYPE_3G"
	CellularNetworkTypeType4g      CellularNetworkType = "TYPE_4G"
)

var AllCellularNetworkType = []CellularNetworkType{
	CellularNetworkTypeTypeUnknown,
	CellularNetworkTypeType2g,
	CellularNetworkTypeType3g,
	CellularNetworkTypeType4g,
}

func (e CellularNetworkType) IsValid() bool {
	switch e {
	case CellularNetworkTypeTypeUnknown, CellularNetworkTypeType2g, CellularNetworkTypeType3g, CellularNetworkTypeType4g:
		return true
	}
	return false
}

func (e CellularNetworkType) String() string {
	return string(e)
}

func (e *CellularNetworkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularNetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularNetworkType", str)
	}
	return nil
}

func (e CellularNetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionMode string

const (
	ConnectionModeResponderOnly ConnectionMode = "RESPONDER_ONLY"
	ConnectionModeBidirectional ConnectionMode = "BIDIRECTIONAL"
)

var AllConnectionMode = []ConnectionMode{
	ConnectionModeResponderOnly,
	ConnectionModeBidirectional,
}

func (e ConnectionMode) IsValid() bool {
	switch e {
	case ConnectionModeResponderOnly, ConnectionModeBidirectional:
		return true
	}
	return false
}

func (e ConnectionMode) String() string {
	return string(e)
}

func (e *ConnectionMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionMode", str)
	}
	return nil
}

func (e ConnectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionOriginEnum string

const (
	ConnectionOriginEnumAny    ConnectionOriginEnum = "ANY"
	ConnectionOriginEnumRemote ConnectionOriginEnum = "REMOTE"
	ConnectionOriginEnumSite   ConnectionOriginEnum = "SITE"
)

var AllConnectionOriginEnum = []ConnectionOriginEnum{
	ConnectionOriginEnumAny,
	ConnectionOriginEnumRemote,
	ConnectionOriginEnumSite,
}

func (e ConnectionOriginEnum) IsValid() bool {
	switch e {
	case ConnectionOriginEnumAny, ConnectionOriginEnumRemote, ConnectionOriginEnumSite:
		return true
	}
	return false
}

func (e ConnectionOriginEnum) String() string {
	return string(e)
}

func (e *ConnectionOriginEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionOriginEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionOriginEnum", str)
	}
	return nil
}

func (e ConnectionOriginEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionTypeEnum string

const (
	ConnectionTypeEnumSite ConnectionTypeEnum = "Site"
	ConnectionTypeEnumHost ConnectionTypeEnum = "Host"
	ConnectionTypeEnumUser ConnectionTypeEnum = "User"
)

var AllConnectionTypeEnum = []ConnectionTypeEnum{
	ConnectionTypeEnumSite,
	ConnectionTypeEnumHost,
	ConnectionTypeEnumUser,
}

func (e ConnectionTypeEnum) IsValid() bool {
	switch e {
	case ConnectionTypeEnumSite, ConnectionTypeEnumHost, ConnectionTypeEnumUser:
		return true
	}
	return false
}

func (e ConnectionTypeEnum) String() string {
	return string(e)
}

func (e *ConnectionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionTypeEnum", str)
	}
	return nil
}

func (e ConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectivityStatus string

const (
	// Connected to the Cato Cloud
	ConnectivityStatusConnected ConnectivityStatus = "connected"
	// Disconnected from the Cato Cloud
	ConnectivityStatusDisconnected ConnectivityStatus = "disconnected"
)

var AllConnectivityStatus = []ConnectivityStatus{
	ConnectivityStatusConnected,
	ConnectivityStatusDisconnected,
}

func (e ConnectivityStatus) IsValid() bool {
	switch e {
	case ConnectivityStatusConnected, ConnectivityStatusDisconnected:
		return true
	}
	return false
}

func (e ConnectivityStatus) String() string {
	return string(e)
}

func (e *ConnectivityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectivityStatus", str)
	}
	return nil
}

func (e ConnectivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DayOfWeek string

const (
	DayOfWeekSunday    DayOfWeek = "SUNDAY"
	DayOfWeekMonday    DayOfWeek = "MONDAY"
	DayOfWeekTuesday   DayOfWeek = "TUESDAY"
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"
	DayOfWeekThursday  DayOfWeek = "THURSDAY"
	DayOfWeekFriday    DayOfWeek = "FRIDAY"
	DayOfWeekSaturday  DayOfWeek = "SATURDAY"
)

var AllDayOfWeek = []DayOfWeek{
	DayOfWeekSunday,
	DayOfWeekMonday,
	DayOfWeekTuesday,
	DayOfWeekWednesday,
	DayOfWeekThursday,
	DayOfWeekFriday,
	DayOfWeekSaturday,
}

func (e DayOfWeek) IsValid() bool {
	switch e {
	case DayOfWeekSunday, DayOfWeekMonday, DayOfWeekTuesday, DayOfWeekWednesday, DayOfWeekThursday, DayOfWeekFriday, DayOfWeekSaturday:
		return true
	}
	return false
}

func (e DayOfWeek) String() string {
	return string(e)
}

func (e *DayOfWeek) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DayOfWeek(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DayOfWeek", str)
	}
	return nil
}

func (e DayOfWeek) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DestinationType string

const (
	DestinationTypeIPv4 DestinationType = "IPv4"
	DestinationTypeFqdn DestinationType = "FQDN"
)

var AllDestinationType = []DestinationType{
	DestinationTypeIPv4,
	DestinationTypeFqdn,
}

func (e DestinationType) IsValid() bool {
	switch e {
	case DestinationTypeIPv4, DestinationTypeFqdn:
		return true
	}
	return false
}

func (e DestinationType) String() string {
	return string(e)
}

func (e *DestinationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DestinationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DestinationType", str)
	}
	return nil
}

func (e DestinationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionSourceEnum string

const (
	DetectionSourceEnumMicrosoftDefenderForEndpoint  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_ENDPOINT"
	DetectionSourceEnumAntivirus                     DetectionSourceEnum = "ANTIVIRUS"
	DetectionSourceEnumSmartScreen                   DetectionSourceEnum = "SMART_SCREEN"
	DetectionSourceEnumCustomTi                      DetectionSourceEnum = "CUSTOM_TI"
	DetectionSourceEnumMicrosoftDefenderForOffice365 DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_OFFICE365"
	DetectionSourceEnumAutomatedInvestigation        DetectionSourceEnum = "AUTOMATED_INVESTIGATION"
	DetectionSourceEnumMicrosoftThreatExperts        DetectionSourceEnum = "MICROSOFT_THREAT_EXPERTS"
	DetectionSourceEnumCustomDetection               DetectionSourceEnum = "CUSTOM_DETECTION"
	DetectionSourceEnumMicrosoftDefenderForIDEntity  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_IDENTITY"
	DetectionSourceEnumCloudAppSecurity              DetectionSourceEnum = "CLOUD_APP_SECURITY"
	DetectionSourceEnumMicrosoft365Defender          DetectionSourceEnum = "MICROSOFT365_DEFENDER"
	DetectionSourceEnumAzureAdIDEntityProtection     DetectionSourceEnum = "AZURE_AD_IDENTITY_PROTECTION"
	DetectionSourceEnumManual                        DetectionSourceEnum = "MANUAL"
	DetectionSourceEnumMicrosoftDataLossPrevention   DetectionSourceEnum = "MICROSOFT_DATA_LOSS_PREVENTION"
	DetectionSourceEnumAppGovernancePolicy           DetectionSourceEnum = "APP_GOVERNANCE_POLICY"
	DetectionSourceEnumAppGovernanceDetection        DetectionSourceEnum = "APP_GOVERNANCE_DETECTION"
)

var AllDetectionSourceEnum = []DetectionSourceEnum{
	DetectionSourceEnumMicrosoftDefenderForEndpoint,
	DetectionSourceEnumAntivirus,
	DetectionSourceEnumSmartScreen,
	DetectionSourceEnumCustomTi,
	DetectionSourceEnumMicrosoftDefenderForOffice365,
	DetectionSourceEnumAutomatedInvestigation,
	DetectionSourceEnumMicrosoftThreatExperts,
	DetectionSourceEnumCustomDetection,
	DetectionSourceEnumMicrosoftDefenderForIDEntity,
	DetectionSourceEnumCloudAppSecurity,
	DetectionSourceEnumMicrosoft365Defender,
	DetectionSourceEnumAzureAdIDEntityProtection,
	DetectionSourceEnumManual,
	DetectionSourceEnumMicrosoftDataLossPrevention,
	DetectionSourceEnumAppGovernancePolicy,
	DetectionSourceEnumAppGovernanceDetection,
}

func (e DetectionSourceEnum) IsValid() bool {
	switch e {
	case DetectionSourceEnumMicrosoftDefenderForEndpoint, DetectionSourceEnumAntivirus, DetectionSourceEnumSmartScreen, DetectionSourceEnumCustomTi, DetectionSourceEnumMicrosoftDefenderForOffice365, DetectionSourceEnumAutomatedInvestigation, DetectionSourceEnumMicrosoftThreatExperts, DetectionSourceEnumCustomDetection, DetectionSourceEnumMicrosoftDefenderForIDEntity, DetectionSourceEnumCloudAppSecurity, DetectionSourceEnumMicrosoft365Defender, DetectionSourceEnumAzureAdIDEntityProtection, DetectionSourceEnumManual, DetectionSourceEnumMicrosoftDataLossPrevention, DetectionSourceEnumAppGovernancePolicy, DetectionSourceEnumAppGovernanceDetection:
		return true
	}
	return false
}

func (e DetectionSourceEnum) String() string {
	return string(e)
}

func (e *DetectionSourceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionSourceEnum", str)
	}
	return nil
}

func (e DetectionSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionStatusEnum string

const (
	DetectionStatusEnumDetected  DetectionStatusEnum = "DETECTED"
	DetectionStatusEnumBlocked   DetectionStatusEnum = "BLOCKED"
	DetectionStatusEnumPrevented DetectionStatusEnum = "PREVENTED"
)

var AllDetectionStatusEnum = []DetectionStatusEnum{
	DetectionStatusEnumDetected,
	DetectionStatusEnumBlocked,
	DetectionStatusEnumPrevented,
}

func (e DetectionStatusEnum) IsValid() bool {
	switch e {
	case DetectionStatusEnumDetected, DetectionStatusEnumBlocked, DetectionStatusEnumPrevented:
		return true
	}
	return false
}

func (e DetectionStatusEnum) String() string {
	return string(e)
}

func (e *DetectionStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionStatusEnum", str)
	}
	return nil
}

func (e DetectionStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceAvStatusEnum string

const (
	DeviceAvStatusEnumNotReporting DeviceAvStatusEnum = "NOT_REPORTING"
	DeviceAvStatusEnumDisabled     DeviceAvStatusEnum = "DISABLED"
	DeviceAvStatusEnumNotUpdated   DeviceAvStatusEnum = "NOT_UPDATED"
	DeviceAvStatusEnumUpdated      DeviceAvStatusEnum = "UPDATED"
)

var AllDeviceAvStatusEnum = []DeviceAvStatusEnum{
	DeviceAvStatusEnumNotReporting,
	DeviceAvStatusEnumDisabled,
	DeviceAvStatusEnumNotUpdated,
	DeviceAvStatusEnumUpdated,
}

func (e DeviceAvStatusEnum) IsValid() bool {
	switch e {
	case DeviceAvStatusEnumNotReporting, DeviceAvStatusEnumDisabled, DeviceAvStatusEnumNotUpdated, DeviceAvStatusEnumUpdated:
		return true
	}
	return false
}

func (e DeviceAvStatusEnum) String() string {
	return string(e)
}

func (e *DeviceAvStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceAvStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceAvStatusEnum", str)
	}
	return nil
}

func (e DeviceAvStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceConfigHaRoleEnum string

const (
	DeviceConfigHaRoleEnumPrimary   DeviceConfigHaRoleEnum = "PRIMARY"
	DeviceConfigHaRoleEnumSecondary DeviceConfigHaRoleEnum = "SECONDARY"
)

var AllDeviceConfigHaRoleEnum = []DeviceConfigHaRoleEnum{
	DeviceConfigHaRoleEnumPrimary,
	DeviceConfigHaRoleEnumSecondary,
}

func (e DeviceConfigHaRoleEnum) IsValid() bool {
	switch e {
	case DeviceConfigHaRoleEnumPrimary, DeviceConfigHaRoleEnumSecondary:
		return true
	}
	return false
}

func (e DeviceConfigHaRoleEnum) String() string {
	return string(e)
}

func (e *DeviceConfigHaRoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfigHaRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfigHaRoleEnum", str)
	}
	return nil
}

func (e DeviceConfigHaRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHaRoleStateEnum string

const (
	DeviceHaRoleStateEnumMaster DeviceHaRoleStateEnum = "MASTER"
	DeviceHaRoleStateEnumBackup DeviceHaRoleStateEnum = "BACKUP"
)

var AllDeviceHaRoleStateEnum = []DeviceHaRoleStateEnum{
	DeviceHaRoleStateEnumMaster,
	DeviceHaRoleStateEnumBackup,
}

func (e DeviceHaRoleStateEnum) IsValid() bool {
	switch e {
	case DeviceHaRoleStateEnumMaster, DeviceHaRoleStateEnumBackup:
		return true
	}
	return false
}

func (e DeviceHaRoleStateEnum) String() string {
	return string(e)
}

func (e *DeviceHaRoleStateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHaRoleStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHaRoleStateEnum", str)
	}
	return nil
}

func (e DeviceHaRoleStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHealthStatusEnum string

const (
	DeviceHealthStatusEnumActive                            DeviceHealthStatusEnum = "ACTIVE"
	DeviceHealthStatusEnumInactive                          DeviceHealthStatusEnum = "INACTIVE"
	DeviceHealthStatusEnumImpairedCommunication             DeviceHealthStatusEnum = "IMPAIRED_COMMUNICATION"
	DeviceHealthStatusEnumNoSensorData                      DeviceHealthStatusEnum = "NO_SENSOR_DATA"
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication DeviceHealthStatusEnum = "NO_SENSOR_DATA_IMPAIRED_COMMUNICATION"
)

var AllDeviceHealthStatusEnum = []DeviceHealthStatusEnum{
	DeviceHealthStatusEnumActive,
	DeviceHealthStatusEnumInactive,
	DeviceHealthStatusEnumImpairedCommunication,
	DeviceHealthStatusEnumNoSensorData,
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication,
}

func (e DeviceHealthStatusEnum) IsValid() bool {
	switch e {
	case DeviceHealthStatusEnumActive, DeviceHealthStatusEnumInactive, DeviceHealthStatusEnumImpairedCommunication, DeviceHealthStatusEnumNoSensorData, DeviceHealthStatusEnumNoSensorDataImpairedCommunication:
		return true
	}
	return false
}

func (e DeviceHealthStatusEnum) String() string {
	return string(e)
}

func (e *DeviceHealthStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHealthStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHealthStatusEnum", str)
	}
	return nil
}

func (e DeviceHealthStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DhcpType string

const (
	DhcpTypeDhcpRelay      DhcpType = "DHCP_RELAY"
	DhcpTypeDhcpRange      DhcpType = "DHCP_RANGE"
	DhcpTypeAccountDefault DhcpType = "ACCOUNT_DEFAULT"
	DhcpTypeDhcpDisabled   DhcpType = "DHCP_DISABLED"
)

var AllDhcpType = []DhcpType{
	DhcpTypeDhcpRelay,
	DhcpTypeDhcpRange,
	DhcpTypeAccountDefault,
	DhcpTypeDhcpDisabled,
}

func (e DhcpType) IsValid() bool {
	switch e {
	case DhcpTypeDhcpRelay, DhcpTypeDhcpRange, DhcpTypeAccountDefault, DhcpTypeDhcpDisabled:
		return true
	}
	return false
}

func (e DhcpType) String() string {
	return string(e)
}

func (e *DhcpType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DhcpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DhcpType", str)
	}
	return nil
}

func (e DhcpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionEnum string

const (
	DirectionEnumAsc  DirectionEnum = "asc"
	DirectionEnumDesc DirectionEnum = "desc"
)

var AllDirectionEnum = []DirectionEnum{
	DirectionEnumAsc,
	DirectionEnumDesc,
}

func (e DirectionEnum) IsValid() bool {
	switch e {
	case DirectionEnumAsc, DirectionEnumDesc:
		return true
	}
	return false
}

func (e DirectionEnum) String() string {
	return string(e)
}

func (e *DirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionEnum", str)
	}
	return nil
}

func (e DirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionInput string

const (
	DirectionInputAsc  DirectionInput = "asc"
	DirectionInputDesc DirectionInput = "desc"
)

var AllDirectionInput = []DirectionInput{
	DirectionInputAsc,
	DirectionInputDesc,
}

func (e DirectionInput) IsValid() bool {
	switch e {
	case DirectionInputAsc, DirectionInputDesc:
		return true
	}
	return false
}

func (e DirectionInput) String() string {
	return string(e)
}

func (e *DirectionInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionInput", str)
	}
	return nil
}

func (e DirectionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The DPA agreement, based on your contract with Cato
type DpaVersion string

const (
	DpaVersionDpa2019_01 DpaVersion = "DPA_2019_01"
	DpaVersionDpa2021_01 DpaVersion = "DPA_2021_01"
	DpaVersionDpa2023_01 DpaVersion = "DPA_2023_01"
)

var AllDpaVersion = []DpaVersion{
	DpaVersionDpa2019_01,
	DpaVersionDpa2021_01,
	DpaVersionDpa2023_01,
}

func (e DpaVersion) IsValid() bool {
	switch e {
	case DpaVersionDpa2019_01, DpaVersionDpa2021_01, DpaVersionDpa2023_01:
		return true
	}
	return false
}

func (e DpaVersion) String() string {
	return string(e)
}

func (e *DpaVersion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DpaVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DpaVersion", str)
	}
	return nil
}

func (e DpaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on ElasticSearch. Between operators are applicable only to numeric fields
// Note that not operators are slower
type ElasticOperator string

const (
	ElasticOperatorIs         ElasticOperator = "is"
	ElasticOperatorIsNot      ElasticOperator = "is_not"
	ElasticOperatorIn         ElasticOperator = "in"
	ElasticOperatorNotIn      ElasticOperator = "not_in"
	ElasticOperatorExists     ElasticOperator = "exists"
	ElasticOperatorNotExists  ElasticOperator = "not_exists"
	ElasticOperatorBetween    ElasticOperator = "between"
	ElasticOperatorNotBetween ElasticOperator = "not_between"
)

var AllElasticOperator = []ElasticOperator{
	ElasticOperatorIs,
	ElasticOperatorIsNot,
	ElasticOperatorIn,
	ElasticOperatorNotIn,
	ElasticOperatorExists,
	ElasticOperatorNotExists,
	ElasticOperatorBetween,
	ElasticOperatorNotBetween,
}

func (e ElasticOperator) IsValid() bool {
	switch e {
	case ElasticOperatorIs, ElasticOperatorIsNot, ElasticOperatorIn, ElasticOperatorNotIn, ElasticOperatorExists, ElasticOperatorNotExists, ElasticOperatorBetween, ElasticOperatorNotBetween:
		return true
	}
	return false
}

func (e ElasticOperator) String() string {
	return string(e)
}

func (e *ElasticOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElasticOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElasticOperator", str)
	}
	return nil
}

func (e ElasticOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityType string

const (
	// A reference to a configured Site within Account
	EntityTypeSite EntityType = "site"
	// A reference to the configured VPN User within Account
	EntityTypeVpnUser EntityType = "vpnUser"
	// Geographical and political entity recognized internationally
	EntityTypeCountry EntityType = "country"
	// Represents a state or territory within a country. It is a sub-division of the country
	EntityTypeCountryState EntityType = "countryState"
	// Time zone, which is a geographical region where clocks are set to the same time
	EntityTypeTimezone EntityType = "timezone"
	// A reference to the configured Host within Site
	EntityTypeHost EntityType = "host"
	// Any entity (matches everything)
	EntityTypeAny EntityType = "any"
	// A reference to the configured Network Interface within Site
	EntityTypeNetworkInterface EntityType = "networkInterface"
	EntityTypeLocation         EntityType = "location"
	// An account administrator (user in Cato Console)
	EntityTypeAdmin EntityType = "admin"
	// A reference to Local Routing Rule within Site
	EntityTypeLocalRouting EntityType = "localRouting"
	// A reference to LAN Firewall Rule within Site
	EntityTypeLanFirewall EntityType = "lanFirewall"
	// An external IP address in a specific PoP reserved for the account
	EntityTypeAllocatedIP EntityType = "allocatedIP"
	// union of the globalRange and a Subnet
	EntityTypeSiteRange EntityType = "siteRange"
	// l4 services for LAN firewall rules
	EntityTypeSimpleService EntityType = "simpleService"
	// Site licenses available for use
	EntityTypeAvailableSiteUsage EntityType = "availableSiteUsage"
	// Pooled licenses available for use
	EntityTypeAvailablePooledUsage EntityType = "availablePooledUsage"
	// A reference to DHCP Relay Group within account
	EntityTypeDhcpRelayGroup EntityType = "dhcpRelayGroup"
	// Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number
	EntityTypePortProtocol EntityType = "portProtocol"
	// A settlement with over 1K population
	EntityTypeCity                    EntityType = "city"
	EntityTypeGroupSubscription       EntityType = "groupSubscription"
	EntityTypeMailingListSubscription EntityType = "mailingListSubscription"
	EntityTypeWebhookSubscription     EntityType = "webhookSubscription"
	// A reference to a configured Account under reseller
	EntityTypeAccount EntityType = "account"
)

var AllEntityType = []EntityType{
	EntityTypeSite,
	EntityTypeVpnUser,
	EntityTypeCountry,
	EntityTypeCountryState,
	EntityTypeTimezone,
	EntityTypeHost,
	EntityTypeAny,
	EntityTypeNetworkInterface,
	EntityTypeLocation,
	EntityTypeAdmin,
	EntityTypeLocalRouting,
	EntityTypeLanFirewall,
	EntityTypeAllocatedIP,
	EntityTypeSiteRange,
	EntityTypeSimpleService,
	EntityTypeAvailableSiteUsage,
	EntityTypeAvailablePooledUsage,
	EntityTypeDhcpRelayGroup,
	EntityTypePortProtocol,
	EntityTypeCity,
	EntityTypeGroupSubscription,
	EntityTypeMailingListSubscription,
	EntityTypeWebhookSubscription,
	EntityTypeAccount,
}

func (e EntityType) IsValid() bool {
	switch e {
	case EntityTypeSite, EntityTypeVpnUser, EntityTypeCountry, EntityTypeCountryState, EntityTypeTimezone, EntityTypeHost, EntityTypeAny, EntityTypeNetworkInterface, EntityTypeLocation, EntityTypeAdmin, EntityTypeLocalRouting, EntityTypeLanFirewall, EntityTypeAllocatedIP, EntityTypeSiteRange, EntityTypeSimpleService, EntityTypeAvailableSiteUsage, EntityTypeAvailablePooledUsage, EntityTypeDhcpRelayGroup, EntityTypePortProtocol, EntityTypeCity, EntityTypeGroupSubscription, EntityTypeMailingListSubscription, EntityTypeWebhookSubscription, EntityTypeAccount:
		return true
	}
	return false
}

func (e EntityType) String() string {
	return string(e)
}

func (e *EntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityType", str)
	}
	return nil
}

func (e EntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFeedFilterFieldName string

const (
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventSubType EventFeedFilterFieldName = "event_sub_type"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventType EventFeedFilterFieldName = "event_type"
)

var AllEventFeedFilterFieldName = []EventFeedFilterFieldName{
	EventFeedFilterFieldNameEventSubType,
	EventFeedFilterFieldNameEventType,
}

func (e EventFeedFilterFieldName) IsValid() bool {
	switch e {
	case EventFeedFilterFieldNameEventSubType, EventFeedFilterFieldNameEventType:
		return true
	}
	return false
}

func (e EventFeedFilterFieldName) String() string {
	return string(e)
}

func (e *EventFeedFilterFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterFieldName", str)
	}
	return nil
}

func (e EventFeedFilterFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on Event Feed
type EventFeedFilterOperator string

const (
	EventFeedFilterOperatorIs    EventFeedFilterOperator = "is"
	EventFeedFilterOperatorIsNot EventFeedFilterOperator = "is_not"
	EventFeedFilterOperatorIn    EventFeedFilterOperator = "in"
	EventFeedFilterOperatorNotIn EventFeedFilterOperator = "not_in"
)

var AllEventFeedFilterOperator = []EventFeedFilterOperator{
	EventFeedFilterOperatorIs,
	EventFeedFilterOperatorIsNot,
	EventFeedFilterOperatorIn,
	EventFeedFilterOperatorNotIn,
}

func (e EventFeedFilterOperator) IsValid() bool {
	switch e {
	case EventFeedFilterOperatorIs, EventFeedFilterOperatorIsNot, EventFeedFilterOperatorIn, EventFeedFilterOperatorNotIn:
		return true
	}
	return false
}

func (e EventFeedFilterOperator) String() string {
	return string(e)
}

func (e *EventFeedFilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterOperator", str)
	}
	return nil
}

func (e EventFeedFilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFieldName string

const (
	// Name of site or user initiating the connection
	EventFieldNameSrcSite EventFieldName = "src_site"
	// Unique internal Cato ID for the site or remote user
	EventFieldNameSrcSiteID EventFieldName = "src_site_id"
	// Static host
	EventFieldNameStaticHost EventFieldName = "static_host"
	// User ID
	EventFieldNameUserID EventFieldName = "user_id"
	// For WAN traffic, name of destination site or SDP user
	EventFieldNameDestSite EventFieldName = "dest_site"
	// Unique internal Cato ID for the destination site or remote user
	EventFieldNameDestSiteID EventFieldName = "dest_site_id"
	// Source or destination site or remote user ID.
	// This field can only be used in filter.
	EventFieldNameSrcOrDestSiteID EventFieldName = "src_or_dest_site_id"
	// Name of security rule related to the event
	EventFieldNameRule EventFieldName = "rule"
	// The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	EventFieldNameIspName EventFieldName = "ISP_name"
	// Name for Socket interface
	EventFieldNameSocketInterface EventFieldName = "socket_interface"
	// Name for the custom category defined in the Cato Management Application
	EventFieldNameCustomCategory EventFieldName = "custom_category"
	// Host name of Domain Controller that created LDAP event
	EventFieldNameDirectoryHostName EventFieldName = "directory_host_name"
	// For Internet traffic, destination host port
	EventFieldNameDestPort EventFieldName = "dest_port"
	// BGP ASN for remote peer
	EventFieldNameBgpPeerAsn EventFieldName = "bgp_peer_asn"
	// For Block/Prompt page, reference ID to report incorrect category
	EventFieldNameUserReferenceID EventFieldName = "user_reference_id"
	// Internal port number
	EventFieldNameSrcPort EventFieldName = "src_port"
	// Data that measures the packet loss for a specific link
	EventFieldNameLinkHealthPktLoss EventFieldName = "link_health_pkt_loss"
	// Name of PoP location
	EventFieldNamePopName EventFieldName = "pop_name"
	// IP address of host related to event
	EventFieldNameHostIP EventFieldName = "host_ip"
	// Cato's description of the event
	EventFieldNameEventMessage EventFieldName = "event_message"
	// Source site or remote user
	EventFieldNameSrcSiteName EventFieldName = "src_site_name"
	// Domain name based on the SSL SNI, HTTP host name, or DNS name
	EventFieldNameDomainName EventFieldName = "domain_name"
	// For Internet traffic, destination host IP address
	EventFieldNameDestIP EventFieldName = "dest_ip"
	// File hash
	EventFieldNameFileHash EventFieldName = "file_hash"
	// IP address provided by ISP to site or Client
	EventFieldNameSrcIspIP EventFieldName = "src_isp_ip"
	// Examples: MFA or password
	EventFieldNameAuthenticationType EventFieldName = "authentication_type"
	// Rule name
	EventFieldNameRuleName EventFieldName = "rule_name"
	// Result of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncResult EventFieldName = "directory_sync_result"
	// MAC address of host related to event
	EventFieldNameHostMac EventFieldName = "host_mac"
	// Type of malware event
	EventFieldNameThreatType EventFieldName = "threat_type"
	// Result of malware event (clean indicates a safe file)
	EventFieldNameThreatVerdict EventFieldName = "threat_verdict"
	// Name for device related to the event
	EventFieldNameDeviceName EventFieldName = "device_name"
	// Link type – Cato, Alt. WAN or LAG
	EventFieldNameLinkType EventFieldName = "link_type"
	// Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)
	EventFieldNameLoginType EventFieldName = "login_type"
	// For hosts configured with a static IP in the Cato Management Application, the host name
	EventFieldNameConfiguredHostName EventFieldName = "configured_host_name"
	// Cato Internal-use only
	EventFieldNameInternalID EventFieldName = "internalId"
	// Type of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncType EventFieldName = "directory_sync_type"
	// User’s email address
	EventFieldNameVpnUserEmail EventFieldName = "vpn_user_email"
	// Type of process generating this traffic
	EventFieldNameClientClass EventFieldName = "client_class"
	// For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)
	EventFieldNameIncidentAggregation EventFieldName = "incident_aggregation"
	// Type of Socket reset (Hardware/Software)
	EventFieldNameSocketReset EventFieldName = "socket_reset"
	// User that generated the event
	EventFieldNameUserName EventFieldName = "user_name"
	// Socket or SDP Client version
	EventFieldNameClientVersion EventFieldName = "client_version"
	// File size
	EventFieldNameFileSize EventFieldName = "file_size"
	// Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)
	EventFieldNameRegistrationCode EventFieldName = "registration_code"
	// BGP disconnect error code
	EventFieldNameBgpErrorCode EventFieldName = "bgp_error_code"
	// Description from Cato Management Application for BGP peer
	EventFieldNameBgpPeerDescription EventFieldName = "bgp_peer_description"
	// For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked
	EventFieldNameThreatName EventFieldName = "threat_name"
	// For QoS, the time that this QoS event started. The event is generated when the QoS event finishes
	EventFieldNameQosReportedTime EventFieldName = "qos_reported_time"
	// Network protocol for this event
	EventFieldNameIPProtocol EventFieldName = "ip_protocol"
	// BGP ASN for Cato peer
	EventFieldNameBgpCatoAsn EventFieldName = "bgp_cato_asn"
	// IP for host or Cato Client
	EventFieldNameSrcIP EventFieldName = "src_ip"
	// Link to external malware reference
	EventFieldNameThreatReference EventFieldName = "threat_reference"
	// Firewall, QoS or LAG action
	EventFieldNameAction EventFieldName = "action"
	// For LDAP sync events, name of the AD domain
	EventFieldNameWindowsDomainName EventFieldName = "windows_domain_name"
	// (IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low – ie. adware Medium – ie. network scans High – ie. spyware or worms
	EventFieldNameRiskLevel EventFieldName = "risk_level"
	// For Socket upgrade, previous version number
	EventFieldNameSocketOldVersion EventFieldName = "socket_old_version"
	// Data that measures the latency for a specific link
	EventFieldNameLinkHealthLatency EventFieldName = "link_health_latency"
	// Protocol for the tunnel
	EventFieldNameTunnelProtocol EventFieldName = "tunnel_protocol"
	// For Socket upgrades, new version number
	EventFieldNameSocketNewVersion EventFieldName = "socket_new_version"
	// Socket version number
	EventFieldNameSocketVersion EventFieldName = "socket_version"
	// Data that measures the jitter for a specific link
	EventFieldNameLinkHealthJitter EventFieldName = "link_health_jitter"
	// Socket upgrade start time (Linux epoch format)
	EventFieldNameUpgradeStartTime EventFieldName = "upgrade_start_time"
	// BGP IP for Cato peer
	EventFieldNameBgpCatoIP EventFieldName = "bgp_cato_ip"
	// Cato system category
	EventFieldNameCategories EventFieldName = "categories"
	// Unique Cato ID for the security rule related to the event
	EventFieldNameRuleID EventFieldName = "rule_id"
	// For Socket HA events, indicates if the Socket is primary or secondary
	EventFieldNameSocketRole EventFieldName = "socket_role"
	// Number of targets (servers) associated with this event
	EventFieldNameTargetsCardinality EventFieldName = "targets_cardinality"
	// Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)
	EventFieldNameUpgradeInitiatedBy EventFieldName = "upgrade_initiated_by"
	// For WAN traffic, destination is site or SDP user
	EventFieldNameDestIsSiteOrVpn EventFieldName = "dest_is_site_or_vpn"
	// BGP IP for remote peer
	EventFieldNameBgpPeerIP EventFieldName = "bgp_peer_ip"
	// Source type: site or remote user
	EventFieldNameSrcIsSiteOrVpn EventFieldName = "src_is_site_or_vpn"
	// Active Directory name
	EventFieldNameAdName EventFieldName = "ad_name"
	// Method used to get identity with User Awareness (such as Identity Agent)
	EventFieldNameUserAwarenessMethod EventFieldName = "user_awareness_method"
	// Data that measures the congestion for a specific link
	EventFieldNameLinkHealthIsCongested EventFieldName = "link_health_is_congested"
	// Name of subnet as defined in Cato Management Application
	EventFieldNameSubnetName EventFieldName = "subnet_name"
	// OS version for the device (such as 14.3.0)
	EventFieldNameOsVersion EventFieldName = "os_version"
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventSubType EventFieldName = "event_sub_type"
	// Host OS or tunnel device
	EventFieldNameOsType EventFieldName = "os_type"
	// Direction of network traffic for this event, values are inbound or outbound
	EventFieldNameTrafficDirection EventFieldName = "traffic_direction"
	// BGP disconnect error message
	EventFieldNameBgpSuberrorCode EventFieldName = "bgp_suberror_code"
	// CIDR for BGP route
	EventFieldNameBgpRouteCidr EventFieldName = "bgp_route_cidr"
	// Unique Cato ID that identifies this security incident
	EventFieldNameIncidentID EventFieldName = "incident_id"
	// For Internet firewall, app for this event
	EventFieldNameApplication EventFieldName = "application"
	// Application of the flow
	EventFieldNameApplicationName EventFieldName = "application_name"
	// Application ID of the flow
	EventFieldNameApplicationID EventFieldName = "application_id"
	// Socket upgrade end time (Linux epoch format):
	EventFieldNameUpgradeEndTime EventFieldName = "upgrade_end_time"
	// Socket interface ID
	EventFieldNameSocketInterfaceID EventFieldName = "socket_interface_id"
	// Unique Cato ID for the custom category
	EventFieldNameCustomCategories EventFieldName = "custom_categories"
	// Custom category ID
	EventFieldNameCustomCategoryID EventFieldName = "custom_category_id"
	// Custom category name
	EventFieldNameCustomCategoryName EventFieldName = "custom_category_name"
	// Country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountry EventFieldName = "src_country"
	// Country Code of country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountryCode EventFieldName = "src_country_code"
	// Count for events that are repeated multiple times during one minute
	EventFieldNameEventCount EventFieldName = "event_count"
	// File name
	EventFieldNameFileName EventFieldName = "file_name"
	// IP address of Domain Controller that created LDAP event
	EventFieldNameDirectoryIP EventFieldName = "directory_ip"
	// Time stamp of event (Linux epoch format)
	EventFieldNameTime EventFieldName = "time"
	// URL associated with the event
	EventFieldNameURL EventFieldName = "url"
	// For Internet traffic, country where the destination host is located
	EventFieldNameDestCountry EventFieldName = "dest_country"
	// For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)
	EventFieldNameDestCountryCode EventFieldName = "dest_country_code"
	// Amount of flows for a given incident
	EventFieldNameFlowsCardinality EventFieldName = "flows_cardinality"
	// For Internet traffic, destination host IP address
	EventFieldNameDestSiteName EventFieldName = "dest_site_name"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventType EventFieldName = "event_type"
	// Account ID
	EventFieldNameAccountID EventFieldName = "account_id"
	// For IPS and SAM, ID of the IPS signature
	EventFieldNameSignatureID EventFieldName = "signature_id"
	// Expiration date for Client certificate
	EventFieldNameClientCertExpires EventFieldName = "client_cert_expires"
	// Name of Client certificate
	EventFieldNameClientCertName EventFieldName = "client_cert_name"
	// Is the app for this event defined as a sanctioned app? (True/False)
	EventFieldNameIsSanctionedApp EventFieldName = "is_sanctioned_app"
	// Name of application activity
	EventFieldNameAppActivity EventFieldName = "app_activity"
	// Activity type
	EventFieldNameAppActivityType EventFieldName = "app_activity_type"
	// Device posture profiles
	EventFieldNameDevicePostureProfile EventFieldName = "device_posture_profile"
	// Device posture profiles
	EventFieldNameDevicePostureProfiles EventFieldName = "device_posture_profiles"
	// Full path URL application activity
	EventFieldNameFullPathURL EventFieldName = "full_path_url"
	// Application risk score
	EventFieldNameApplicationRisk EventFieldName = "application_risk"
	// Mitre attack techniques
	EventFieldNameMitreAttackTechniques EventFieldName = "mitre_attack_techniques"
	// Mitre attack subtechniques
	EventFieldNameMitreAttackSubtechniques EventFieldName = "mitre_attack_subtechniques"
	// Mitre attack tactics
	EventFieldNameMitreAttackTactics EventFieldName = "mitre_attack_tactics"
	// Indicator
	EventFieldNameIndicator EventFieldName = "indicator"
	// For SaaS Security API, SaaS app for the connector
	EventFieldNameConnectorType EventFieldName = "connector_type"
	// For SaaS Security API, name of the connector
	EventFieldNameConnectorName EventFieldName = "connector_name"
	// For SaaS Security API, status of the connector
	EventFieldNameConnectorStatus EventFieldName = "connector_status"
	// For SaaS Security API, parent Microsoft 365 connector
	EventFieldNameParentConnectorName EventFieldName = "parent_connector_name"
	// File type
	EventFieldNameFileType EventFieldName = "file_type"
	// DLP fail mode
	EventFieldNameDlpFailMode EventFieldName = "dlp_fail_mode"
	// DLP profiles related to the event
	EventFieldNameDlpProfiles EventFieldName = "dlp_profiles"
	// Matched DLP data types related to the event
	EventFieldNameMatchedDataTypes EventFieldName = "matched_data_types"
	// Severity defined for the rule
	EventFieldNameSeverity EventFieldName = "severity"
	// For SaaS Security API, email address of the file owner
	EventFieldNameOwner EventFieldName = "owner"
	// For SaaS Security API, email addresses of the users that received the file
	EventFieldNameCollaborators EventFieldName = "collaborators"
	// Email Subject
	EventFieldNameEmailSubject EventFieldName = "email_subject"
	// Sharing Options for the file (such as SharePoint)
	EventFieldNameSharingScope EventFieldName = "sharing_scope"
	// Cato’s DNS Protection type that matched the DNS request
	EventFieldNameDNSProtectionCategory EventFieldName = "dns_protection_category"
	EventFieldNameFinalObjectStatus     EventFieldName = "final_object_status"
	EventFieldNameObjectName            EventFieldName = "object_name"
	EventFieldNameObjectType            EventFieldName = "object_type"
	EventFieldNameObjectID              EventFieldName = "object_id"
	EventFieldNameAlertID               EventFieldName = "alert_id"
	EventFieldNameVendor                EventFieldName = "vendor"
	EventFieldNameVendorUserID          EventFieldName = "vendor_user_id"
	EventFieldNameStatus                EventFieldName = "status"
	EventFieldNameClassification        EventFieldName = "classification"
	EventFieldNameQuarantineFolderPath  EventFieldName = "quarantine_folder_path"
	EventFieldNameTitle                 EventFieldName = "title"
	EventFieldNameRecommendedActions    EventFieldName = "recommended_actions"
	EventFieldNamePid                   EventFieldName = "pid"
	EventFieldNameParentPid             EventFieldName = "parent_pid"
	EventFieldNameProcessPath           EventFieldName = "process_path"
	EventFieldNameFailureReason         EventFieldName = "failure_reason"
	EventFieldNameOutOfBandAccess       EventFieldName = "out_of_band_access"
	EventFieldNameLoggedInUser          EventFieldName = "logged_in_user"
	// HTTP request method (ie. Get, Post)
	EventFieldNameHTTPRequestMethod EventFieldName = "http_request_method"
	// XFF HTTP header indicates the original IP address for the connections
	EventFieldNameXff EventFieldName = "xff"
	// Domain queried in the DNS request
	EventFieldNameDNSQuery EventFieldName = "dns_query"
	// Name defined for the public API Key in the Cato Management Application
	EventFieldNameKeyName EventFieldName = "key_name"
	EventFieldNameAPIType EventFieldName = "api_type"
	EventFieldNameAPIName EventFieldName = "api_name"
	// Related Apps
	EventFieldNameAppStack EventFieldName = "app_stack"
	// TLS Inspection rule name
	EventFieldNameTLSRuleName EventFieldName = "tls_rule_name"
	// TLS Certificate Error
	EventFieldNameTLSCertificateError EventFieldName = "tls_certificate_error"
	// TLS Version
	EventFieldNameTLSVersion EventFieldName = "tls_version"
	// TLS Error Type
	EventFieldNameTLSErrorType EventFieldName = "tls_error_type"
	// TLS Error Description
	EventFieldNameTLSErrorDescription EventFieldName = "tls_error_description"
	// Cato App
	EventFieldNameCatoApp EventFieldName = "cato_app"
	// Prompt Page Selected Action
	EventFieldNamePromptAction EventFieldName = "prompt_action"
	// Unique Cato ID for devices
	EventFieldNameDeviceID EventFieldName = "device_id"
	// Unique Cato Visible ID for devices
	EventFieldNameVisibleDeviceID EventFieldName = "visible_device_id"
	// Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN
	EventFieldNameAuthMethod EventFieldName = "auth_method"
	// Always-On Bypass Method
	EventFieldNameBypassMethod EventFieldName = "bypass_method"
	// Always-On Bypass Duration In Seconds
	EventFieldNameBypassDurationSec EventFieldName = "bypass_duration_sec"
	// Always-On Bypass Reason
	EventFieldNameBypassReason EventFieldName = "bypass_reason"
	// Sign In Types
	EventFieldNameSignInEventTypes EventFieldName = "sign_in_event_types"
	// Tenant Id
	EventFieldNameTenantID EventFieldName = "tenant_id"
	// Tenant Name
	EventFieldNameTenantName EventFieldName = "tenant_name"
	// User Agent
	EventFieldNameUserAgent EventFieldName = "user_agent"
	// Vendor Event Id
	EventFieldNameVendorEventID EventFieldName = "vendor_event_id"
	// Vendor Device Id
	EventFieldNameVendorDeviceID EventFieldName = "vendor_device_id"
	// Vendor Device Name
	EventFieldNameVendorDeviceName EventFieldName = "vendor_device_name"
	// Is Compliant
	EventFieldNameIsCompliant EventFieldName = "is_compliant"
	// Is Managed
	EventFieldNameIsManaged EventFieldName = "is_managed"
	// Trust Type
	EventFieldNameTrustType EventFieldName = "trust_type"
	// Confidence Level
	EventFieldNameConfidenceLevel EventFieldName = "confidence_level"
	// Data Classifiers
	EventFieldNameDlpScanTypes EventFieldName = "dlp_scan_types"
	// Network Access
	EventFieldNameNetworkAccess EventFieldName = "network_access"
	// Analyst Verdict
	EventFieldNameAnalystVerdict EventFieldName = "analyst_verdict"
	// Criticality
	EventFieldNameCriticality EventFieldName = "criticality"
	// Indication
	EventFieldNameIndication EventFieldName = "indication"
	// Producer
	EventFieldNameProducer EventFieldName = "producer"
	// Story Id
	EventFieldNameStoryID EventFieldName = "story_id"
	// Raw Data
	EventFieldNameRawData EventFieldName = "raw_data"
	// Trigger
	EventFieldNameTrigger EventFieldName = "trigger"
	// Matched network rule
	EventFieldNameNetworkRule EventFieldName = "network_rule"
	// The algorithm that is used (CUBIC /NewReno / BBR)
	EventFieldNameCongestionAlgorithm EventFieldName = "congestion_algorithm"
	// Shows if traffic was TCP accelerated or not
	EventFieldNameTCPAcceleration EventFieldName = "tcp_acceleration"
	// Shows if traffic was TLS inspected or not
	EventFieldNameTLSInspection EventFieldName = "tls_inspection"
	// Used Public IP
	EventFieldNamePublicIP EventFieldName = "public_ip"
	// Egress Site Name for backhauling traffic
	EventFieldNameEgressSiteName EventFieldName = "egress_site_name"
	// Egress PoP Name
	EventFieldNameEgressPopName EventFieldName = "egress_pop_name"
	// QoS Priority value
	EventFieldNameQosPriority EventFieldName = "qos_priority"
	// Split Tunnel Configuration
	EventFieldNameSplitTunnelConfiguration EventFieldName = "split_tunnel_configuration"
	// Pac File Enabled/Disabled
	EventFieldNamePacFile EventFieldName = "pac_file"
	// Always-on Configuration
	EventFieldNameAlwaysOnConfiguration EventFieldName = "always_on_configuration"
	// Lan access Allowed / Blocked
	EventFieldNameVpnLanAccess EventFieldName = "vpn_lan_access"
	// Connect on boot Enabled/Disabled
	EventFieldNameConnectOnBoot EventFieldName = "connect_on_boot"
	// Trusted networks Enabled/Disabled
	EventFieldNameTrustedNetworks EventFieldName = "trusted_networks"
	// Office mode Enabled/Disabled
	EventFieldNameOfficeMode EventFieldName = "office_mode"
	// Device Certificate Validated/Not Validated
	EventFieldNameDeviceCertificate EventFieldName = "device_certificate"
	// Tunnel Protocol TCP/UDP
	EventFieldNameTunnelIPProtocol EventFieldName = "tunnel_ip_protocol"
	// For SaaS Security API, description of Apps Security Notification
	EventFieldNameNotificationDescription EventFieldName = "notification_description"
	// For SaaS Security API, API Error of Apps Security Notification
	EventFieldNameNotificationAPIError EventFieldName = "notification_api_error"
	// The URL that links directly to the object involved in the activity
	EventFieldNameReferenceURL EventFieldName = "reference_url"
	// SaaS user activities into categories.
	EventFieldNameAppActivityCategory EventFieldName = "app_activity_category"
	// Indicates whether an activity requires administrative permissions.
	EventFieldNameIsAdminActivity EventFieldName = "is_admin_activity"
	// Classifies users based on their permissions.
	EventFieldNameIsAdmin EventFieldName = "is_admin"
	// Shows the display name of the target user involved in an activity
	EventFieldNameCollaboratorName EventFieldName = "collaborator_name"
	// The unique identifier by the SaaS vendor for the target group in an activity.
	EventFieldNameDestGroupID EventFieldName = "dest_group_id"
	// Identifies the target group involved in an activity
	EventFieldNameDestGroupName EventFieldName = "dest_group_name"
	// Identifies system access software or device
	EventFieldNameAccessMethod EventFieldName = "access_method"
	// Shows the id of the target user involved in an activity
	EventFieldNameVendorCollaboratorID EventFieldName = "vendor_collaborator_id"
)

var AllEventFieldName = []EventFieldName{
	EventFieldNameSrcSite,
	EventFieldNameSrcSiteID,
	EventFieldNameStaticHost,
	EventFieldNameUserID,
	EventFieldNameDestSite,
	EventFieldNameDestSiteID,
	EventFieldNameSrcOrDestSiteID,
	EventFieldNameRule,
	EventFieldNameIspName,
	EventFieldNameSocketInterface,
	EventFieldNameCustomCategory,
	EventFieldNameDirectoryHostName,
	EventFieldNameDestPort,
	EventFieldNameBgpPeerAsn,
	EventFieldNameUserReferenceID,
	EventFieldNameSrcPort,
	EventFieldNameLinkHealthPktLoss,
	EventFieldNamePopName,
	EventFieldNameHostIP,
	EventFieldNameEventMessage,
	EventFieldNameSrcSiteName,
	EventFieldNameDomainName,
	EventFieldNameDestIP,
	EventFieldNameFileHash,
	EventFieldNameSrcIspIP,
	EventFieldNameAuthenticationType,
	EventFieldNameRuleName,
	EventFieldNameDirectorySyncResult,
	EventFieldNameHostMac,
	EventFieldNameThreatType,
	EventFieldNameThreatVerdict,
	EventFieldNameDeviceName,
	EventFieldNameLinkType,
	EventFieldNameLoginType,
	EventFieldNameConfiguredHostName,
	EventFieldNameInternalID,
	EventFieldNameDirectorySyncType,
	EventFieldNameVpnUserEmail,
	EventFieldNameClientClass,
	EventFieldNameIncidentAggregation,
	EventFieldNameSocketReset,
	EventFieldNameUserName,
	EventFieldNameClientVersion,
	EventFieldNameFileSize,
	EventFieldNameRegistrationCode,
	EventFieldNameBgpErrorCode,
	EventFieldNameBgpPeerDescription,
	EventFieldNameThreatName,
	EventFieldNameQosReportedTime,
	EventFieldNameIPProtocol,
	EventFieldNameBgpCatoAsn,
	EventFieldNameSrcIP,
	EventFieldNameThreatReference,
	EventFieldNameAction,
	EventFieldNameWindowsDomainName,
	EventFieldNameRiskLevel,
	EventFieldNameSocketOldVersion,
	EventFieldNameLinkHealthLatency,
	EventFieldNameTunnelProtocol,
	EventFieldNameSocketNewVersion,
	EventFieldNameSocketVersion,
	EventFieldNameLinkHealthJitter,
	EventFieldNameUpgradeStartTime,
	EventFieldNameBgpCatoIP,
	EventFieldNameCategories,
	EventFieldNameRuleID,
	EventFieldNameSocketRole,
	EventFieldNameTargetsCardinality,
	EventFieldNameUpgradeInitiatedBy,
	EventFieldNameDestIsSiteOrVpn,
	EventFieldNameBgpPeerIP,
	EventFieldNameSrcIsSiteOrVpn,
	EventFieldNameAdName,
	EventFieldNameUserAwarenessMethod,
	EventFieldNameLinkHealthIsCongested,
	EventFieldNameSubnetName,
	EventFieldNameOsVersion,
	EventFieldNameEventSubType,
	EventFieldNameOsType,
	EventFieldNameTrafficDirection,
	EventFieldNameBgpSuberrorCode,
	EventFieldNameBgpRouteCidr,
	EventFieldNameIncidentID,
	EventFieldNameApplication,
	EventFieldNameApplicationName,
	EventFieldNameApplicationID,
	EventFieldNameUpgradeEndTime,
	EventFieldNameSocketInterfaceID,
	EventFieldNameCustomCategories,
	EventFieldNameCustomCategoryID,
	EventFieldNameCustomCategoryName,
	EventFieldNameSrcCountry,
	EventFieldNameSrcCountryCode,
	EventFieldNameEventCount,
	EventFieldNameFileName,
	EventFieldNameDirectoryIP,
	EventFieldNameTime,
	EventFieldNameURL,
	EventFieldNameDestCountry,
	EventFieldNameDestCountryCode,
	EventFieldNameFlowsCardinality,
	EventFieldNameDestSiteName,
	EventFieldNameEventType,
	EventFieldNameAccountID,
	EventFieldNameSignatureID,
	EventFieldNameClientCertExpires,
	EventFieldNameClientCertName,
	EventFieldNameIsSanctionedApp,
	EventFieldNameAppActivity,
	EventFieldNameAppActivityType,
	EventFieldNameDevicePostureProfile,
	EventFieldNameDevicePostureProfiles,
	EventFieldNameFullPathURL,
	EventFieldNameApplicationRisk,
	EventFieldNameMitreAttackTechniques,
	EventFieldNameMitreAttackSubtechniques,
	EventFieldNameMitreAttackTactics,
	EventFieldNameIndicator,
	EventFieldNameConnectorType,
	EventFieldNameConnectorName,
	EventFieldNameConnectorStatus,
	EventFieldNameParentConnectorName,
	EventFieldNameFileType,
	EventFieldNameDlpFailMode,
	EventFieldNameDlpProfiles,
	EventFieldNameMatchedDataTypes,
	EventFieldNameSeverity,
	EventFieldNameOwner,
	EventFieldNameCollaborators,
	EventFieldNameEmailSubject,
	EventFieldNameSharingScope,
	EventFieldNameDNSProtectionCategory,
	EventFieldNameFinalObjectStatus,
	EventFieldNameObjectName,
	EventFieldNameObjectType,
	EventFieldNameObjectID,
	EventFieldNameAlertID,
	EventFieldNameVendor,
	EventFieldNameVendorUserID,
	EventFieldNameStatus,
	EventFieldNameClassification,
	EventFieldNameQuarantineFolderPath,
	EventFieldNameTitle,
	EventFieldNameRecommendedActions,
	EventFieldNamePid,
	EventFieldNameParentPid,
	EventFieldNameProcessPath,
	EventFieldNameFailureReason,
	EventFieldNameOutOfBandAccess,
	EventFieldNameLoggedInUser,
	EventFieldNameHTTPRequestMethod,
	EventFieldNameXff,
	EventFieldNameDNSQuery,
	EventFieldNameKeyName,
	EventFieldNameAPIType,
	EventFieldNameAPIName,
	EventFieldNameAppStack,
	EventFieldNameTLSRuleName,
	EventFieldNameTLSCertificateError,
	EventFieldNameTLSVersion,
	EventFieldNameTLSErrorType,
	EventFieldNameTLSErrorDescription,
	EventFieldNameCatoApp,
	EventFieldNamePromptAction,
	EventFieldNameDeviceID,
	EventFieldNameVisibleDeviceID,
	EventFieldNameAuthMethod,
	EventFieldNameBypassMethod,
	EventFieldNameBypassDurationSec,
	EventFieldNameBypassReason,
	EventFieldNameSignInEventTypes,
	EventFieldNameTenantID,
	EventFieldNameTenantName,
	EventFieldNameUserAgent,
	EventFieldNameVendorEventID,
	EventFieldNameVendorDeviceID,
	EventFieldNameVendorDeviceName,
	EventFieldNameIsCompliant,
	EventFieldNameIsManaged,
	EventFieldNameTrustType,
	EventFieldNameConfidenceLevel,
	EventFieldNameDlpScanTypes,
	EventFieldNameNetworkAccess,
	EventFieldNameAnalystVerdict,
	EventFieldNameCriticality,
	EventFieldNameIndication,
	EventFieldNameProducer,
	EventFieldNameStoryID,
	EventFieldNameRawData,
	EventFieldNameTrigger,
	EventFieldNameNetworkRule,
	EventFieldNameCongestionAlgorithm,
	EventFieldNameTCPAcceleration,
	EventFieldNameTLSInspection,
	EventFieldNamePublicIP,
	EventFieldNameEgressSiteName,
	EventFieldNameEgressPopName,
	EventFieldNameQosPriority,
	EventFieldNameSplitTunnelConfiguration,
	EventFieldNamePacFile,
	EventFieldNameAlwaysOnConfiguration,
	EventFieldNameVpnLanAccess,
	EventFieldNameConnectOnBoot,
	EventFieldNameTrustedNetworks,
	EventFieldNameOfficeMode,
	EventFieldNameDeviceCertificate,
	EventFieldNameTunnelIPProtocol,
	EventFieldNameNotificationDescription,
	EventFieldNameNotificationAPIError,
	EventFieldNameReferenceURL,
	EventFieldNameAppActivityCategory,
	EventFieldNameIsAdminActivity,
	EventFieldNameIsAdmin,
	EventFieldNameCollaboratorName,
	EventFieldNameDestGroupID,
	EventFieldNameDestGroupName,
	EventFieldNameAccessMethod,
	EventFieldNameVendorCollaboratorID,
}

func (e EventFieldName) IsValid() bool {
	switch e {
	case EventFieldNameSrcSite, EventFieldNameSrcSiteID, EventFieldNameStaticHost, EventFieldNameUserID, EventFieldNameDestSite, EventFieldNameDestSiteID, EventFieldNameSrcOrDestSiteID, EventFieldNameRule, EventFieldNameIspName, EventFieldNameSocketInterface, EventFieldNameCustomCategory, EventFieldNameDirectoryHostName, EventFieldNameDestPort, EventFieldNameBgpPeerAsn, EventFieldNameUserReferenceID, EventFieldNameSrcPort, EventFieldNameLinkHealthPktLoss, EventFieldNamePopName, EventFieldNameHostIP, EventFieldNameEventMessage, EventFieldNameSrcSiteName, EventFieldNameDomainName, EventFieldNameDestIP, EventFieldNameFileHash, EventFieldNameSrcIspIP, EventFieldNameAuthenticationType, EventFieldNameRuleName, EventFieldNameDirectorySyncResult, EventFieldNameHostMac, EventFieldNameThreatType, EventFieldNameThreatVerdict, EventFieldNameDeviceName, EventFieldNameLinkType, EventFieldNameLoginType, EventFieldNameConfiguredHostName, EventFieldNameInternalID, EventFieldNameDirectorySyncType, EventFieldNameVpnUserEmail, EventFieldNameClientClass, EventFieldNameIncidentAggregation, EventFieldNameSocketReset, EventFieldNameUserName, EventFieldNameClientVersion, EventFieldNameFileSize, EventFieldNameRegistrationCode, EventFieldNameBgpErrorCode, EventFieldNameBgpPeerDescription, EventFieldNameThreatName, EventFieldNameQosReportedTime, EventFieldNameIPProtocol, EventFieldNameBgpCatoAsn, EventFieldNameSrcIP, EventFieldNameThreatReference, EventFieldNameAction, EventFieldNameWindowsDomainName, EventFieldNameRiskLevel, EventFieldNameSocketOldVersion, EventFieldNameLinkHealthLatency, EventFieldNameTunnelProtocol, EventFieldNameSocketNewVersion, EventFieldNameSocketVersion, EventFieldNameLinkHealthJitter, EventFieldNameUpgradeStartTime, EventFieldNameBgpCatoIP, EventFieldNameCategories, EventFieldNameRuleID, EventFieldNameSocketRole, EventFieldNameTargetsCardinality, EventFieldNameUpgradeInitiatedBy, EventFieldNameDestIsSiteOrVpn, EventFieldNameBgpPeerIP, EventFieldNameSrcIsSiteOrVpn, EventFieldNameAdName, EventFieldNameUserAwarenessMethod, EventFieldNameLinkHealthIsCongested, EventFieldNameSubnetName, EventFieldNameOsVersion, EventFieldNameEventSubType, EventFieldNameOsType, EventFieldNameTrafficDirection, EventFieldNameBgpSuberrorCode, EventFieldNameBgpRouteCidr, EventFieldNameIncidentID, EventFieldNameApplication, EventFieldNameApplicationName, EventFieldNameApplicationID, EventFieldNameUpgradeEndTime, EventFieldNameSocketInterfaceID, EventFieldNameCustomCategories, EventFieldNameCustomCategoryID, EventFieldNameCustomCategoryName, EventFieldNameSrcCountry, EventFieldNameSrcCountryCode, EventFieldNameEventCount, EventFieldNameFileName, EventFieldNameDirectoryIP, EventFieldNameTime, EventFieldNameURL, EventFieldNameDestCountry, EventFieldNameDestCountryCode, EventFieldNameFlowsCardinality, EventFieldNameDestSiteName, EventFieldNameEventType, EventFieldNameAccountID, EventFieldNameSignatureID, EventFieldNameClientCertExpires, EventFieldNameClientCertName, EventFieldNameIsSanctionedApp, EventFieldNameAppActivity, EventFieldNameAppActivityType, EventFieldNameDevicePostureProfile, EventFieldNameDevicePostureProfiles, EventFieldNameFullPathURL, EventFieldNameApplicationRisk, EventFieldNameMitreAttackTechniques, EventFieldNameMitreAttackSubtechniques, EventFieldNameMitreAttackTactics, EventFieldNameIndicator, EventFieldNameConnectorType, EventFieldNameConnectorName, EventFieldNameConnectorStatus, EventFieldNameParentConnectorName, EventFieldNameFileType, EventFieldNameDlpFailMode, EventFieldNameDlpProfiles, EventFieldNameMatchedDataTypes, EventFieldNameSeverity, EventFieldNameOwner, EventFieldNameCollaborators, EventFieldNameEmailSubject, EventFieldNameSharingScope, EventFieldNameDNSProtectionCategory, EventFieldNameFinalObjectStatus, EventFieldNameObjectName, EventFieldNameObjectType, EventFieldNameObjectID, EventFieldNameAlertID, EventFieldNameVendor, EventFieldNameVendorUserID, EventFieldNameStatus, EventFieldNameClassification, EventFieldNameQuarantineFolderPath, EventFieldNameTitle, EventFieldNameRecommendedActions, EventFieldNamePid, EventFieldNameParentPid, EventFieldNameProcessPath, EventFieldNameFailureReason, EventFieldNameOutOfBandAccess, EventFieldNameLoggedInUser, EventFieldNameHTTPRequestMethod, EventFieldNameXff, EventFieldNameDNSQuery, EventFieldNameKeyName, EventFieldNameAPIType, EventFieldNameAPIName, EventFieldNameAppStack, EventFieldNameTLSRuleName, EventFieldNameTLSCertificateError, EventFieldNameTLSVersion, EventFieldNameTLSErrorType, EventFieldNameTLSErrorDescription, EventFieldNameCatoApp, EventFieldNamePromptAction, EventFieldNameDeviceID, EventFieldNameVisibleDeviceID, EventFieldNameAuthMethod, EventFieldNameBypassMethod, EventFieldNameBypassDurationSec, EventFieldNameBypassReason, EventFieldNameSignInEventTypes, EventFieldNameTenantID, EventFieldNameTenantName, EventFieldNameUserAgent, EventFieldNameVendorEventID, EventFieldNameVendorDeviceID, EventFieldNameVendorDeviceName, EventFieldNameIsCompliant, EventFieldNameIsManaged, EventFieldNameTrustType, EventFieldNameConfidenceLevel, EventFieldNameDlpScanTypes, EventFieldNameNetworkAccess, EventFieldNameAnalystVerdict, EventFieldNameCriticality, EventFieldNameIndication, EventFieldNameProducer, EventFieldNameStoryID, EventFieldNameRawData, EventFieldNameTrigger, EventFieldNameNetworkRule, EventFieldNameCongestionAlgorithm, EventFieldNameTCPAcceleration, EventFieldNameTLSInspection, EventFieldNamePublicIP, EventFieldNameEgressSiteName, EventFieldNameEgressPopName, EventFieldNameQosPriority, EventFieldNameSplitTunnelConfiguration, EventFieldNamePacFile, EventFieldNameAlwaysOnConfiguration, EventFieldNameVpnLanAccess, EventFieldNameConnectOnBoot, EventFieldNameTrustedNetworks, EventFieldNameOfficeMode, EventFieldNameDeviceCertificate, EventFieldNameTunnelIPProtocol, EventFieldNameNotificationDescription, EventFieldNameNotificationAPIError, EventFieldNameReferenceURL, EventFieldNameAppActivityCategory, EventFieldNameIsAdminActivity, EventFieldNameIsAdmin, EventFieldNameCollaboratorName, EventFieldNameDestGroupID, EventFieldNameDestGroupName, EventFieldNameAccessMethod, EventFieldNameVendorCollaboratorID:
		return true
	}
	return false
}

func (e EventFieldName) String() string {
	return string(e)
}

func (e *EventFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFieldName", str)
	}
	return nil
}

func (e EventFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterOperator string

const (
	FilterOperatorIs         FilterOperator = "is"
	FilterOperatorIsNot      FilterOperator = "is_not"
	FilterOperatorIn         FilterOperator = "in"
	FilterOperatorNotIn      FilterOperator = "not_in"
	FilterOperatorExists     FilterOperator = "exists"
	FilterOperatorNotExists  FilterOperator = "not_exists"
	FilterOperatorBetween    FilterOperator = "between"
	FilterOperatorNotBetween FilterOperator = "not_between"
	FilterOperatorGt         FilterOperator = "gt"
	FilterOperatorGte        FilterOperator = "gte"
	FilterOperatorLt         FilterOperator = "lt"
	FilterOperatorLte        FilterOperator = "lte"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorIs,
	FilterOperatorIsNot,
	FilterOperatorIn,
	FilterOperatorNotIn,
	FilterOperatorExists,
	FilterOperatorNotExists,
	FilterOperatorBetween,
	FilterOperatorNotBetween,
	FilterOperatorGt,
	FilterOperatorGte,
	FilterOperatorLt,
	FilterOperatorLte,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorIs, FilterOperatorIsNot, FilterOperatorIn, FilterOperatorNotIn, FilterOperatorExists, FilterOperatorNotExists, FilterOperatorBetween, FilterOperatorNotBetween, FilterOperatorGt, FilterOperatorGte, FilterOperatorLt, FilterOperatorLte:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaReadiness string

const (
	HaReadinessReady    HaReadiness = "ready"
	HaReadinessNotReady HaReadiness = "not_ready"
)

var AllHaReadiness = []HaReadiness{
	HaReadinessReady,
	HaReadinessNotReady,
}

func (e HaReadiness) IsValid() bool {
	switch e {
	case HaReadinessReady, HaReadinessNotReady:
		return true
	}
	return false
}

func (e HaReadiness) String() string {
	return string(e)
}

func (e *HaReadiness) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaReadiness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaReadiness", str)
	}
	return nil
}

func (e HaReadiness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaSubStatus string

const (
	HaSubStatusOk   HaSubStatus = "ok"
	HaSubStatusFail HaSubStatus = "fail"
)

var AllHaSubStatus = []HaSubStatus{
	HaSubStatusOk,
	HaSubStatusFail,
}

func (e HaSubStatus) IsValid() bool {
	switch e {
	case HaSubStatusOk, HaSubStatusFail:
		return true
	}
	return false
}

func (e HaSubStatus) String() string {
	return string(e)
}

func (e *HaSubStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaSubStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaSubStatus", str)
	}
	return nil
}

func (e HaSubStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecV2InterfaceID string

const (
	IPSecV2InterfaceIDPrimary1   IPSecV2InterfaceID = "PRIMARY1"
	IPSecV2InterfaceIDPrimary2   IPSecV2InterfaceID = "PRIMARY2"
	IPSecV2InterfaceIDPrimary3   IPSecV2InterfaceID = "PRIMARY3"
	IPSecV2InterfaceIDSecondary1 IPSecV2InterfaceID = "SECONDARY1"
	IPSecV2InterfaceIDSecondary2 IPSecV2InterfaceID = "SECONDARY2"
	IPSecV2InterfaceIDSecondary3 IPSecV2InterfaceID = "SECONDARY3"
)

var AllIPSecV2InterfaceID = []IPSecV2InterfaceID{
	IPSecV2InterfaceIDPrimary1,
	IPSecV2InterfaceIDPrimary2,
	IPSecV2InterfaceIDPrimary3,
	IPSecV2InterfaceIDSecondary1,
	IPSecV2InterfaceIDSecondary2,
	IPSecV2InterfaceIDSecondary3,
}

func (e IPSecV2InterfaceID) IsValid() bool {
	switch e {
	case IPSecV2InterfaceIDPrimary1, IPSecV2InterfaceIDPrimary2, IPSecV2InterfaceIDPrimary3, IPSecV2InterfaceIDSecondary1, IPSecV2InterfaceIDSecondary2, IPSecV2InterfaceIDSecondary3:
		return true
	}
	return false
}

func (e IPSecV2InterfaceID) String() string {
	return string(e)
}

func (e *IPSecV2InterfaceID) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2InterfaceID(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2InterfaceId", str)
	}
	return nil
}

func (e IPSecV2InterfaceID) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IdentificationType string

const (
	IdentificationTypeIPV4  IdentificationType = "IPV4"
	IdentificationTypeFqdn  IdentificationType = "FQDN"
	IdentificationTypeEmail IdentificationType = "EMAIL"
	IdentificationTypeKeyID IdentificationType = "KEY_ID"
)

var AllIdentificationType = []IdentificationType{
	IdentificationTypeIPV4,
	IdentificationTypeFqdn,
	IdentificationTypeEmail,
	IdentificationTypeKeyID,
}

func (e IdentificationType) IsValid() bool {
	switch e {
	case IdentificationTypeIPV4, IdentificationTypeFqdn, IdentificationTypeEmail, IdentificationTypeKeyID:
		return true
	}
	return false
}

func (e IdentificationType) String() string {
	return string(e)
}

func (e *IdentificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentificationType", str)
	}
	return nil
}

func (e IdentificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IlmmOnboardingStatus string

const (
	IlmmOnboardingStatusMissing  IlmmOnboardingStatus = "MISSING"
	IlmmOnboardingStatusPending  IlmmOnboardingStatus = "PENDING"
	IlmmOnboardingStatusFailed   IlmmOnboardingStatus = "FAILED"
	IlmmOnboardingStatusComplete IlmmOnboardingStatus = "COMPLETE"
)

var AllIlmmOnboardingStatus = []IlmmOnboardingStatus{
	IlmmOnboardingStatusMissing,
	IlmmOnboardingStatusPending,
	IlmmOnboardingStatusFailed,
	IlmmOnboardingStatusComplete,
}

func (e IlmmOnboardingStatus) IsValid() bool {
	switch e {
	case IlmmOnboardingStatusMissing, IlmmOnboardingStatusPending, IlmmOnboardingStatusFailed, IlmmOnboardingStatusComplete:
		return true
	}
	return false
}

func (e IlmmOnboardingStatus) String() string {
	return string(e)
}

func (e *IlmmOnboardingStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IlmmOnboardingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IlmmOnboardingStatus", str)
	}
	return nil
}

func (e IlmmOnboardingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The action applied by the Internet Firewall if the rule is matched
type InternetFirewallActionEnum string

const (
	// Deny the network traffic from passing through the firewall.
	InternetFirewallActionEnumBlock InternetFirewallActionEnum = "BLOCK"
	// Allow the network traffic to pass through the firewall.
	InternetFirewallActionEnumAllow InternetFirewallActionEnum = "ALLOW"
	// Requests user confirmation to allow or block network traffic.
	InternetFirewallActionEnumPrompt InternetFirewallActionEnum = "PROMPT"
	// Apply Remote Browser Isolation (RBI) to the network traffic
	InternetFirewallActionEnumRbi InternetFirewallActionEnum = "RBI"
)

var AllInternetFirewallActionEnum = []InternetFirewallActionEnum{
	InternetFirewallActionEnumBlock,
	InternetFirewallActionEnumAllow,
	InternetFirewallActionEnumPrompt,
	InternetFirewallActionEnumRbi,
}

func (e InternetFirewallActionEnum) IsValid() bool {
	switch e {
	case InternetFirewallActionEnumBlock, InternetFirewallActionEnumAllow, InternetFirewallActionEnumPrompt, InternetFirewallActionEnumRbi:
		return true
	}
	return false
}

func (e InternetFirewallActionEnum) String() string {
	return string(e)
}

func (e *InternetFirewallActionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternetFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternetFirewallActionEnum", str)
	}
	return nil
}

func (e InternetFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPProtocol string

const (
	IPProtocolAny IPProtocol = "ANY"
	IPProtocolTCP IPProtocol = "TCP"
	// TCP or UDP
	IPProtocolTCPUDP IPProtocol = "TCP_UDP"
	IPProtocolUDP    IPProtocol = "UDP"
	IPProtocolICMP   IPProtocol = "ICMP"
)

var AllIPProtocol = []IPProtocol{
	IPProtocolAny,
	IPProtocolTCP,
	IPProtocolTCPUDP,
	IPProtocolUDP,
	IPProtocolICMP,
}

func (e IPProtocol) IsValid() bool {
	switch e {
	case IPProtocolAny, IPProtocolTCP, IPProtocolTCPUDP, IPProtocolUDP, IPProtocolICMP:
		return true
	}
	return false
}

func (e IPProtocol) String() string {
	return string(e)
}

func (e *IPProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpProtocol", str)
	}
	return nil
}

func (e IPProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecCipher string

const (
	IPSecCipherNone      IPSecCipher = "NONE"
	IPSecCipherAutomatic IPSecCipher = "AUTOMATIC"
	IPSecCipherAesCbc128 IPSecCipher = "AES_CBC_128"
	IPSecCipherAesCbc256 IPSecCipher = "AES_CBC_256"
	IPSecCipherAesGcm128 IPSecCipher = "AES_GCM_128"
	IPSecCipherAesGcm256 IPSecCipher = "AES_GCM_256"
	IPSecCipherDes3Cbc   IPSecCipher = "DES3_CBC"
)

var AllIPSecCipher = []IPSecCipher{
	IPSecCipherNone,
	IPSecCipherAutomatic,
	IPSecCipherAesCbc128,
	IPSecCipherAesCbc256,
	IPSecCipherAesGcm128,
	IPSecCipherAesGcm256,
	IPSecCipherDes3Cbc,
}

func (e IPSecCipher) IsValid() bool {
	switch e {
	case IPSecCipherNone, IPSecCipherAutomatic, IPSecCipherAesCbc128, IPSecCipherAesCbc256, IPSecCipherAesGcm128, IPSecCipherAesGcm256, IPSecCipherDes3Cbc:
		return true
	}
	return false
}

func (e IPSecCipher) String() string {
	return string(e)
}

func (e *IPSecCipher) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecCipher(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecCipher", str)
	}
	return nil
}

func (e IPSecCipher) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecDHGroup string

const (
	IPSecDHGroupNone         IPSecDHGroup = "NONE"
	IPSecDHGroupAutomatic    IPSecDHGroup = "AUTOMATIC"
	IPSecDHGroupDh2Modp1024  IPSecDHGroup = "DH_2_MODP1024"
	IPSecDHGroupDh5Modp1536  IPSecDHGroup = "DH_5_MODP1536"
	IPSecDHGroupDh14Modp2048 IPSecDHGroup = "DH_14_MODP2048"
	IPSecDHGroupDh15Modp3072 IPSecDHGroup = "DH_15_MODP3072"
	IPSecDHGroupDh16Modp4096 IPSecDHGroup = "DH_16_MODP4096"
	IPSecDHGroupDh19Ecp256   IPSecDHGroup = "DH_19_ECP256"
	IPSecDHGroupDh20Ecp384   IPSecDHGroup = "DH_20_ECP384"
	IPSecDHGroupDh21Ecp521   IPSecDHGroup = "DH_21_ECP521"
)

var AllIPSecDHGroup = []IPSecDHGroup{
	IPSecDHGroupNone,
	IPSecDHGroupAutomatic,
	IPSecDHGroupDh2Modp1024,
	IPSecDHGroupDh5Modp1536,
	IPSecDHGroupDh14Modp2048,
	IPSecDHGroupDh15Modp3072,
	IPSecDHGroupDh16Modp4096,
	IPSecDHGroupDh19Ecp256,
	IPSecDHGroupDh20Ecp384,
	IPSecDHGroupDh21Ecp521,
}

func (e IPSecDHGroup) IsValid() bool {
	switch e {
	case IPSecDHGroupNone, IPSecDHGroupAutomatic, IPSecDHGroupDh2Modp1024, IPSecDHGroupDh5Modp1536, IPSecDHGroupDh14Modp2048, IPSecDHGroupDh15Modp3072, IPSecDHGroupDh16Modp4096, IPSecDHGroupDh19Ecp256, IPSecDHGroupDh20Ecp384, IPSecDHGroupDh21Ecp521:
		return true
	}
	return false
}

func (e IPSecDHGroup) String() string {
	return string(e)
}

func (e *IPSecDHGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecDHGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecDHGroup", str)
	}
	return nil
}

func (e IPSecDHGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecHash string

const (
	IPSecHashNone      IPSecHash = "NONE"
	IPSecHashAutomatic IPSecHash = "AUTOMATIC"
	IPSecHashMd5       IPSecHash = "MD5"
	IPSecHashSha1      IPSecHash = "SHA1"
	IPSecHashSha256    IPSecHash = "SHA256"
	IPSecHashSha384    IPSecHash = "SHA384"
	IPSecHashSha512    IPSecHash = "SHA512"
)

var AllIPSecHash = []IPSecHash{
	IPSecHashNone,
	IPSecHashAutomatic,
	IPSecHashMd5,
	IPSecHashSha1,
	IPSecHashSha256,
	IPSecHashSha384,
	IPSecHashSha512,
}

func (e IPSecHash) IsValid() bool {
	switch e {
	case IPSecHashNone, IPSecHashAutomatic, IPSecHashMd5, IPSecHashSha1, IPSecHashSha256, IPSecHashSha384, IPSecHashSha512:
		return true
	}
	return false
}

func (e IPSecHash) String() string {
	return string(e)
}

func (e *IPSecHash) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecHash(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecHash", str)
	}
	return nil
}

func (e IPSecHash) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for license plan type (site license, service license, etc...)
type LicensePlan string

const (
	LicensePlanCommercial LicensePlan = "COMMERCIAL"
	LicensePlanTrial      LicensePlan = "TRIAL"
)

var AllLicensePlan = []LicensePlan{
	LicensePlanCommercial,
	LicensePlanTrial,
}

func (e LicensePlan) IsValid() bool {
	switch e {
	case LicensePlanCommercial, LicensePlanTrial:
		return true
	}
	return false
}

func (e LicensePlan) String() string {
	return string(e)
}

func (e *LicensePlan) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicensePlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicensePlan", str)
	}
	return nil
}

func (e LicensePlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LicenseSku string

const (
	// Site bandwidth SASE SKU
	LicenseSkuCatoSite LicenseSku = "CATO_SITE"
	// Site bandwidth SSE SKU
	LicenseSkuCatoSseSite LicenseSku = "CATO_SSE_SITE"
	// Site pooled bandwidth SASE SKU
	LicenseSkuCatoPb LicenseSku = "CATO_PB"
	// Site pooled bandwidth SSE SKU
	LicenseSkuCatoPbSse LicenseSku = "CATO_PB_SSE"
	// ZTNA remote users SKUs
	LicenseSkuMobileUsers LicenseSku = "MOBILE_USERS"
	// ZTNA remote users SKUs
	LicenseSkuCatoZtnaUsers LicenseSku = "CATO_ZTNA_USERS"
	// Cato EPP service SKU
	LicenseSkuCatoEpp LicenseSku = "CATO_EPP"
	// Cato IPS (legacy) service SKU
	LicenseSkuCatoIPS LicenseSku = "CATO_IPS"
	// Cato Anti Malware (legacy) service SKU
	LicenseSkuCatoAntiMalware LicenseSku = "CATO_ANTI_MALWARE"
	// Cato Anti Malware Next Generation (legacy) service SKU
	LicenseSkuCatoAntiMalwareNg LicenseSku = "CATO_ANTI_MALWARE_NG"
	// Cato CASB service SKU
	LicenseSkuCatoCasb LicenseSku = "CATO_CASB"
	// Cato DLP service SKU
	LicenseSkuCatoDlp LicenseSku = "CATO_DLP"
	// Cato ILMM service SKU
	LicenseSkuCatoIlmm LicenseSku = "CATO_ILMM"
	// Cato MDR (XDR Pro) service SKU
	LicenseSkuCatoMdr LicenseSku = "CATO_MDR"
	// Cato NOCaaS service SKU
	LicenseSkuCatoNocaasHf LicenseSku = "CATO_NOCAAS_HF"
	// Cato Remote Browser Isolation (RBI) service SKU
	LicenseSkuCatoRbi LicenseSku = "CATO_RBI"
	// Cato SAAS Group SKU
	LicenseSkuCatoSaas LicenseSku = "CATO_SAAS"
	// Cato SAAS Security API with one application integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIOneApp LicenseSku = "CATO_SAAS_SECURITY_API_ONE_APP"
	// Cato SAAS Security API with two applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPITwoApps LicenseSku = "CATO_SAAS_SECURITY_API_TWO_APPS"
	// Cato SAAS Security API with more than two Applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIAllApps LicenseSku = "CATO_SAAS_SECURITY_API_ALL_APPS"
	LicenseSkuCatoSaasSecurityAPI        LicenseSku = "CATO_SAAS_SECURITY_API"
	// Cato XDR service SKUs
	LicenseSkuCatoXdrPro LicenseSku = "CATO_XDR_PRO"
	// Cato DEM Pro service SKU
	LicenseSkuCatoDemPro LicenseSku = "CATO_DEM_PRO"
	// Cato Threat Prevention (legacy) service SKU
	LicenseSkuCatoThreatPrevention LicenseSku = "CATO_THREAT_PREVENTION"
	// Public IPs SKU
	LicenseSkuCatoIPAdd LicenseSku = "CATO_IP_ADD"
	// Cato datalake Group SKU
	LicenseSkuCatoDatalake LicenseSku = "CATO_DATALAKE"
	// 3 months data retention SKU
	LicenseSkuCatoDatalake3m LicenseSku = "CATO_DATALAKE_3M"
	// 6 months data retention SKU
	LicenseSkuCatoDatalake6m LicenseSku = "CATO_DATALAKE_6M"
	// 12 months data retention SKU
	LicenseSkuCatoDatalake12m LicenseSku = "CATO_DATALAKE_12M"
)

var AllLicenseSku = []LicenseSku{
	LicenseSkuCatoSite,
	LicenseSkuCatoSseSite,
	LicenseSkuCatoPb,
	LicenseSkuCatoPbSse,
	LicenseSkuMobileUsers,
	LicenseSkuCatoZtnaUsers,
	LicenseSkuCatoEpp,
	LicenseSkuCatoIPS,
	LicenseSkuCatoAntiMalware,
	LicenseSkuCatoAntiMalwareNg,
	LicenseSkuCatoCasb,
	LicenseSkuCatoDlp,
	LicenseSkuCatoIlmm,
	LicenseSkuCatoMdr,
	LicenseSkuCatoNocaasHf,
	LicenseSkuCatoRbi,
	LicenseSkuCatoSaas,
	LicenseSkuCatoSaasSecurityAPIOneApp,
	LicenseSkuCatoSaasSecurityAPITwoApps,
	LicenseSkuCatoSaasSecurityAPIAllApps,
	LicenseSkuCatoSaasSecurityAPI,
	LicenseSkuCatoXdrPro,
	LicenseSkuCatoDemPro,
	LicenseSkuCatoThreatPrevention,
	LicenseSkuCatoIPAdd,
	LicenseSkuCatoDatalake,
	LicenseSkuCatoDatalake3m,
	LicenseSkuCatoDatalake6m,
	LicenseSkuCatoDatalake12m,
}

func (e LicenseSku) IsValid() bool {
	switch e {
	case LicenseSkuCatoSite, LicenseSkuCatoSseSite, LicenseSkuCatoPb, LicenseSkuCatoPbSse, LicenseSkuMobileUsers, LicenseSkuCatoZtnaUsers, LicenseSkuCatoEpp, LicenseSkuCatoIPS, LicenseSkuCatoAntiMalware, LicenseSkuCatoAntiMalwareNg, LicenseSkuCatoCasb, LicenseSkuCatoDlp, LicenseSkuCatoIlmm, LicenseSkuCatoMdr, LicenseSkuCatoNocaasHf, LicenseSkuCatoRbi, LicenseSkuCatoSaas, LicenseSkuCatoSaasSecurityAPIOneApp, LicenseSkuCatoSaasSecurityAPITwoApps, LicenseSkuCatoSaasSecurityAPIAllApps, LicenseSkuCatoSaasSecurityAPI, LicenseSkuCatoXdrPro, LicenseSkuCatoDemPro, LicenseSkuCatoThreatPrevention, LicenseSkuCatoIPAdd, LicenseSkuCatoDatalake, LicenseSkuCatoDatalake3m, LicenseSkuCatoDatalake6m, LicenseSkuCatoDatalake12m:
		return true
	}
	return false
}

func (e LicenseSku) String() string {
	return string(e)
}

func (e *LicenseSku) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseSku(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseSku", str)
	}
	return nil
}

func (e LicenseSku) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for account plan status – the current license status within the license lifecycle
type LicenseStatus string

const (
	// A license that is currently active
	LicenseStatusActive LicenseStatus = "ACTIVE"
	// An existing license with a future start date that is not currently active
	LicenseStatusScheduled LicenseStatus = "SCHEDULED"
	// A license that is active before its start date, for partners and customers to verify the relevant configurations
	LicenseStatusStaging LicenseStatus = "STAGING"
	// A license in a grace period
	LicenseStatusLocked LicenseStatus = "LOCKED"
	// An expired license is no longer active
	LicenseStatusDisabled LicenseStatus = "DISABLED"
)

var AllLicenseStatus = []LicenseStatus{
	LicenseStatusActive,
	LicenseStatusScheduled,
	LicenseStatusStaging,
	LicenseStatusLocked,
	LicenseStatusDisabled,
}

func (e LicenseStatus) IsValid() bool {
	switch e {
	case LicenseStatusActive, LicenseStatusScheduled, LicenseStatusStaging, LicenseStatusLocked, LicenseStatusDisabled:
		return true
	}
	return false
}

func (e LicenseStatus) String() string {
	return string(e)
}

func (e *LicenseStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseStatus", str)
	}
	return nil
}

func (e LicenseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkConfigPrecedenceEnum string

const (
	LinkConfigPrecedenceEnumActive     LinkConfigPrecedenceEnum = "ACTIVE"
	LinkConfigPrecedenceEnumPassive    LinkConfigPrecedenceEnum = "PASSIVE"
	LinkConfigPrecedenceEnumLastResort LinkConfigPrecedenceEnum = "LAST_RESORT"
)

var AllLinkConfigPrecedenceEnum = []LinkConfigPrecedenceEnum{
	LinkConfigPrecedenceEnumActive,
	LinkConfigPrecedenceEnumPassive,
	LinkConfigPrecedenceEnumLastResort,
}

func (e LinkConfigPrecedenceEnum) IsValid() bool {
	switch e {
	case LinkConfigPrecedenceEnumActive, LinkConfigPrecedenceEnumPassive, LinkConfigPrecedenceEnumLastResort:
		return true
	}
	return false
}

func (e LinkConfigPrecedenceEnum) String() string {
	return string(e)
}

func (e *LinkConfigPrecedenceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkConfigPrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkConfigPrecedenceEnum", str)
	}
	return nil
}

func (e LinkConfigPrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkQualityIssueTypeEnum string

const (
	LinkQualityIssueTypeEnumPacketLoss LinkQualityIssueTypeEnum = "PACKET_LOSS"
	LinkQualityIssueTypeEnumDistance   LinkQualityIssueTypeEnum = "DISTANCE"
	LinkQualityIssueTypeEnumJitter     LinkQualityIssueTypeEnum = "JITTER"
	LinkQualityIssueTypeEnumCongestion LinkQualityIssueTypeEnum = "CONGESTION"
)

var AllLinkQualityIssueTypeEnum = []LinkQualityIssueTypeEnum{
	LinkQualityIssueTypeEnumPacketLoss,
	LinkQualityIssueTypeEnumDistance,
	LinkQualityIssueTypeEnumJitter,
	LinkQualityIssueTypeEnumCongestion,
}

func (e LinkQualityIssueTypeEnum) IsValid() bool {
	switch e {
	case LinkQualityIssueTypeEnumPacketLoss, LinkQualityIssueTypeEnumDistance, LinkQualityIssueTypeEnumJitter, LinkQualityIssueTypeEnumCongestion:
		return true
	}
	return false
}

func (e LinkQualityIssueTypeEnum) String() string {
	return string(e)
}

func (e *LinkQualityIssueTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkQualityIssueTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkQualityIssueTypeEnum", str)
	}
	return nil
}

func (e LinkQualityIssueTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkStatusEnum string

const (
	LinkStatusEnumActive  LinkStatusEnum = "ACTIVE"
	LinkStatusEnumPassive LinkStatusEnum = "PASSIVE"
)

var AllLinkStatusEnum = []LinkStatusEnum{
	LinkStatusEnumActive,
	LinkStatusEnumPassive,
}

func (e LinkStatusEnum) IsValid() bool {
	switch e {
	case LinkStatusEnumActive, LinkStatusEnumPassive:
		return true
	}
	return false
}

func (e LinkStatusEnum) String() string {
	return string(e)
}

func (e *LinkStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkStatusEnum", str)
	}
	return nil
}

func (e LinkStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LookupFilterType string

const (
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
	// "SOCKET",
	// "IPSEC",
	// "vSOCKET",
	// "PHYSICAL_SOCKET"
	LookupFilterTypeFilterByConnectionTypeFamily LookupFilterType = "filterByConnectionTypeFamily"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
	// "SOCKET_X1500",
	// "SOCKET_X1600",
	// "SOCKET_X1700",
	// "VSOCKET_VGX_ESX",
	// "VSOCKET_VGX_AWS"
	// "VSOCKET_VGX_AZURE"
	// "SOCKET_X1600_LTE",
	LookupFilterTypeFilterByConnectionType LookupFilterType = "filterByConnectionType"
	// Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByAltWan LookupFilterType = "filterByAltWan"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByBackhaulingGw LookupFilterType = "filterByBackhaulingGW"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByOffCloudTransportEnabled LookupFilterType = "filterByOffCloudTransportEnabled"
	// Custom filter for country, used by city and state entityLookup
	LookupFilterTypeCountry LookupFilterType = "country"
	// Custom filter for state used by city entityLookup
	LookupFilterTypeState LookupFilterType = "state"
)

var AllLookupFilterType = []LookupFilterType{
	LookupFilterTypeFilterByConnectionTypeFamily,
	LookupFilterTypeFilterByConnectionType,
	LookupFilterTypeFilterByAltWan,
	LookupFilterTypeFilterByBackhaulingGw,
	LookupFilterTypeFilterByOffCloudTransportEnabled,
	LookupFilterTypeCountry,
	LookupFilterTypeState,
}

func (e LookupFilterType) IsValid() bool {
	switch e {
	case LookupFilterTypeFilterByConnectionTypeFamily, LookupFilterTypeFilterByConnectionType, LookupFilterTypeFilterByAltWan, LookupFilterTypeFilterByBackhaulingGw, LookupFilterTypeFilterByOffCloudTransportEnabled, LookupFilterTypeCountry, LookupFilterTypeState:
		return true
	}
	return false
}

func (e LookupFilterType) String() string {
	return string(e)
}

func (e *LookupFilterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LookupFilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LookupFilterType", str)
	}
	return nil
}

func (e LookupFilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsAlertStatus string

const (
	MsAlertStatusNew        MsAlertStatus = "NEW"
	MsAlertStatusInProgress MsAlertStatus = "IN_PROGRESS"
	MsAlertStatusResolved   MsAlertStatus = "RESOLVED"
)

var AllMsAlertStatus = []MsAlertStatus{
	MsAlertStatusNew,
	MsAlertStatusInProgress,
	MsAlertStatusResolved,
}

func (e MsAlertStatus) IsValid() bool {
	switch e {
	case MsAlertStatusNew, MsAlertStatusInProgress, MsAlertStatusResolved:
		return true
	}
	return false
}

func (e MsAlertStatus) String() string {
	return string(e)
}

func (e *MsAlertStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsAlertStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsAlertStatus", str)
	}
	return nil
}

func (e MsAlertStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsResourceVerdictEnum string

const (
	MsResourceVerdictEnumSuspicious    MsResourceVerdictEnum = "Suspicious"
	MsResourceVerdictEnumMalicious     MsResourceVerdictEnum = "Malicious"
	MsResourceVerdictEnumInformational MsResourceVerdictEnum = "Informational"
	MsResourceVerdictEnumBenign        MsResourceVerdictEnum = "Benign"
)

var AllMsResourceVerdictEnum = []MsResourceVerdictEnum{
	MsResourceVerdictEnumSuspicious,
	MsResourceVerdictEnumMalicious,
	MsResourceVerdictEnumInformational,
	MsResourceVerdictEnumBenign,
}

func (e MsResourceVerdictEnum) IsValid() bool {
	switch e {
	case MsResourceVerdictEnumSuspicious, MsResourceVerdictEnumMalicious, MsResourceVerdictEnumInformational, MsResourceVerdictEnumBenign:
		return true
	}
	return false
}

func (e MsResourceVerdictEnum) String() string {
	return string(e)
}

func (e *MsResourceVerdictEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsResourceVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsResourceVerdictEnum", str)
	}
	return nil
}

func (e MsResourceVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkEventSourceEnum string

const (
	NetworkEventSourceEnumSite       NetworkEventSourceEnum = "SITE"
	NetworkEventSourceEnumLink       NetworkEventSourceEnum = "LINK"
	NetworkEventSourceEnumDevice     NetworkEventSourceEnum = "DEVICE"
	NetworkEventSourceEnumIsp        NetworkEventSourceEnum = "ISP"
	NetworkEventSourceEnumPop        NetworkEventSourceEnum = "POP"
	NetworkEventSourceEnumHost       NetworkEventSourceEnum = "HOST"
	NetworkEventSourceEnumBgpSession NetworkEventSourceEnum = "BGP_SESSION"
)

var AllNetworkEventSourceEnum = []NetworkEventSourceEnum{
	NetworkEventSourceEnumSite,
	NetworkEventSourceEnumLink,
	NetworkEventSourceEnumDevice,
	NetworkEventSourceEnumIsp,
	NetworkEventSourceEnumPop,
	NetworkEventSourceEnumHost,
	NetworkEventSourceEnumBgpSession,
}

func (e NetworkEventSourceEnum) IsValid() bool {
	switch e {
	case NetworkEventSourceEnumSite, NetworkEventSourceEnumLink, NetworkEventSourceEnumDevice, NetworkEventSourceEnumIsp, NetworkEventSourceEnumPop, NetworkEventSourceEnumHost, NetworkEventSourceEnumBgpSession:
		return true
	}
	return false
}

func (e NetworkEventSourceEnum) String() string {
	return string(e)
}

func (e *NetworkEventSourceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkEventSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkEventSourceEnum", str)
	}
	return nil
}

func (e NetworkEventSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkXDREventTypeEnum string

const (
	NetworkXDREventTypeEnumInsight  NetworkXDREventTypeEnum = "INSIGHT"
	NetworkXDREventTypeEnumDegraded NetworkXDREventTypeEnum = "DEGRADED"
	NetworkXDREventTypeEnumResolved NetworkXDREventTypeEnum = "RESOLVED"
)

var AllNetworkXDREventTypeEnum = []NetworkXDREventTypeEnum{
	NetworkXDREventTypeEnumInsight,
	NetworkXDREventTypeEnumDegraded,
	NetworkXDREventTypeEnumResolved,
}

func (e NetworkXDREventTypeEnum) IsValid() bool {
	switch e {
	case NetworkXDREventTypeEnumInsight, NetworkXDREventTypeEnumDegraded, NetworkXDREventTypeEnumResolved:
		return true
	}
	return false
}

func (e NetworkXDREventTypeEnum) String() string {
	return string(e)
}

func (e *NetworkXDREventTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkXDREventTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkXDREventTypeEnum", str)
	}
	return nil
}

func (e NetworkXDREventTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObjectRefBy string

const (
	ObjectRefByID   ObjectRefBy = "ID"
	ObjectRefByName ObjectRefBy = "NAME"
)

var AllObjectRefBy = []ObjectRefBy{
	ObjectRefByID,
	ObjectRefByName,
}

func (e ObjectRefBy) IsValid() bool {
	switch e {
	case ObjectRefByID, ObjectRefByName:
		return true
	}
	return false
}

func (e ObjectRefBy) String() string {
	return string(e)
}

func (e *ObjectRefBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectRefBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectRefBy", str)
	}
	return nil
}

func (e ObjectRefBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OnboardingStatusEnum string

const (
	OnboardingStatusEnumInsufficientInfo OnboardingStatusEnum = "INSUFFICIENT_INFO"
	OnboardingStatusEnumOnboarded        OnboardingStatusEnum = "ONBOARDED"
	OnboardingStatusEnumCanBeOnboarded   OnboardingStatusEnum = "CAN_BE_ONBOARDED"
)

var AllOnboardingStatusEnum = []OnboardingStatusEnum{
	OnboardingStatusEnumInsufficientInfo,
	OnboardingStatusEnumOnboarded,
	OnboardingStatusEnumCanBeOnboarded,
}

func (e OnboardingStatusEnum) IsValid() bool {
	switch e {
	case OnboardingStatusEnumInsufficientInfo, OnboardingStatusEnumOnboarded, OnboardingStatusEnumCanBeOnboarded:
		return true
	}
	return false
}

func (e OnboardingStatusEnum) String() string {
	return string(e)
}

func (e *OnboardingStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingStatusEnum", str)
	}
	return nil
}

func (e OnboardingStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystem string

const (
	OperatingSystemWindows  OperatingSystem = "WINDOWS"
	OperatingSystemMacos    OperatingSystem = "MACOS"
	OperatingSystemIos      OperatingSystem = "IOS"
	OperatingSystemAndroid  OperatingSystem = "ANDROID"
	OperatingSystemLinux    OperatingSystem = "LINUX"
	OperatingSystemEmbedded OperatingSystem = "EMBEDDED"
)

var AllOperatingSystem = []OperatingSystem{
	OperatingSystemWindows,
	OperatingSystemMacos,
	OperatingSystemIos,
	OperatingSystemAndroid,
	OperatingSystemLinux,
	OperatingSystemEmbedded,
}

func (e OperatingSystem) IsValid() bool {
	switch e {
	case OperatingSystemWindows, OperatingSystemMacos, OperatingSystemIos, OperatingSystemAndroid, OperatingSystemLinux, OperatingSystemEmbedded:
		return true
	}
	return false
}

func (e OperatingSystem) String() string {
	return string(e)
}

func (e *OperatingSystem) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystem", str)
	}
	return nil
}

func (e OperatingSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationalStatus string

const (
	// Passing traffic
	OperationalStatusActive OperationalStatus = "active"
	// Disabled in the Cato Management Application
	OperationalStatusDisabled OperationalStatus = "disabled"
	// License has expired for this site and you can't configure it
	OperationalStatusLocked OperationalStatus = "locked"
	// After you create the site before it is connected to the Cato Cloud
	OperationalStatusNew OperationalStatus = "new"
	// For VPN users only
	OperationalStatusPendingUserConfiguration OperationalStatus = "pending_user_configuration"
	// For VPN users only
	OperationalStatusPendingMfaConfiguration OperationalStatus = "pending_mfa_configuration"
	// For VPN users only
	OperationalStatusPendingCodeGeneration OperationalStatus = "pending_code_generation"
)

var AllOperationalStatus = []OperationalStatus{
	OperationalStatusActive,
	OperationalStatusDisabled,
	OperationalStatusLocked,
	OperationalStatusNew,
	OperationalStatusPendingUserConfiguration,
	OperationalStatusPendingMfaConfiguration,
	OperationalStatusPendingCodeGeneration,
}

func (e OperationalStatus) IsValid() bool {
	switch e {
	case OperationalStatusActive, OperationalStatusDisabled, OperationalStatusLocked, OperationalStatusNew, OperationalStatusPendingUserConfiguration, OperationalStatusPendingMfaConfiguration, OperationalStatusPendingCodeGeneration:
		return true
	}
	return false
}

func (e OperationalStatus) String() string {
	return string(e)
}

func (e *OperationalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationalStatus", str)
	}
	return nil
}

func (e OperationalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PeriodType string

const (
	// packet loss connectivity issue
	PeriodTypePacketLoss PeriodType = "packetLoss"
	// missing data
	PeriodTypeMissingData PeriodType = "missingData"
	// interface in standby mode
	PeriodTypePassiveLink PeriodType = "passiveLink"
	// traffic was seen
	PeriodTypeActive PeriodType = "active"
	// some packets were queued
	PeriodTypeOverlowed PeriodType = "overlowed"
	// some packets were discarded after queue timeout
	PeriodTypeCongested PeriodType = "congested"
	// multiple last mile destinations measured packet loss
	PeriodTypeLastmilePacketLoss PeriodType = "lastmilePacketLoss"
	// multiple last mile destinations measured large latency (greater than 500ms)
	PeriodTypeLastmileLatency PeriodType = "lastmileLatency"
	// unspecified period type
	PeriodTypeGeneric PeriodType = "generic"
	// period connected to specific pop instance
	PeriodTypePop PeriodType = "pop"
)

var AllPeriodType = []PeriodType{
	PeriodTypePacketLoss,
	PeriodTypeMissingData,
	PeriodTypePassiveLink,
	PeriodTypeActive,
	PeriodTypeOverlowed,
	PeriodTypeCongested,
	PeriodTypeLastmilePacketLoss,
	PeriodTypeLastmileLatency,
	PeriodTypeGeneric,
	PeriodTypePop,
}

func (e PeriodType) IsValid() bool {
	switch e {
	case PeriodTypePacketLoss, PeriodTypeMissingData, PeriodTypePassiveLink, PeriodTypeActive, PeriodTypeOverlowed, PeriodTypeCongested, PeriodTypeLastmilePacketLoss, PeriodTypeLastmileLatency, PeriodTypeGeneric, PeriodTypePop:
		return true
	}
	return false
}

func (e PeriodType) String() string {
	return string(e)
}

func (e *PeriodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeriodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeriodType", str)
	}
	return nil
}

func (e PeriodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of time range a rule is active
type PolicyActiveOnEnum string

const (
	PolicyActiveOnEnumAlways          PolicyActiveOnEnum = "ALWAYS"
	PolicyActiveOnEnumWorkingHours    PolicyActiveOnEnum = "WORKING_HOURS"
	PolicyActiveOnEnumCustomTimeframe PolicyActiveOnEnum = "CUSTOM_TIMEFRAME"
	PolicyActiveOnEnumCustomRecurring PolicyActiveOnEnum = "CUSTOM_RECURRING"
)

var AllPolicyActiveOnEnum = []PolicyActiveOnEnum{
	PolicyActiveOnEnumAlways,
	PolicyActiveOnEnumWorkingHours,
	PolicyActiveOnEnumCustomTimeframe,
	PolicyActiveOnEnumCustomRecurring,
}

func (e PolicyActiveOnEnum) IsValid() bool {
	switch e {
	case PolicyActiveOnEnumAlways, PolicyActiveOnEnumWorkingHours, PolicyActiveOnEnumCustomTimeframe, PolicyActiveOnEnumCustomRecurring:
		return true
	}
	return false
}

func (e PolicyActiveOnEnum) String() string {
	return string(e)
}

func (e *PolicyActiveOnEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyActiveOnEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyActiveOnEnum", str)
	}
	return nil
}

func (e PolicyActiveOnEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Attributes describing the rule state or type
type PolicyElementPropertiesEnum string

const (
	// New (added) rule
	PolicyElementPropertiesEnumAdded PolicyElementPropertiesEnum = "ADDED"
	// Updated (modified) existing rule
	PolicyElementPropertiesEnumUpdated PolicyElementPropertiesEnum = "UPDATED"
	// Removed (deleted) rule
	PolicyElementPropertiesEnumRemoved PolicyElementPropertiesEnum = "REMOVED"
	// A rule moved to a different position
	PolicyElementPropertiesEnumMoved PolicyElementPropertiesEnum = "MOVED"
	// A rule locked for changes by other admins
	PolicyElementPropertiesEnumLocked PolicyElementPropertiesEnum = "LOCKED"
	// An object can not be moved, or referenced when moving other objects.
	// However its properties and content can be modified.
	PolicyElementPropertiesEnumAnchored PolicyElementPropertiesEnum = "ANCHORED"
	// A pre-defined (system) rule that cannot be modified or removed
	PolicyElementPropertiesEnumSystem PolicyElementPropertiesEnum = "SYSTEM"
)

var AllPolicyElementPropertiesEnum = []PolicyElementPropertiesEnum{
	PolicyElementPropertiesEnumAdded,
	PolicyElementPropertiesEnumUpdated,
	PolicyElementPropertiesEnumRemoved,
	PolicyElementPropertiesEnumMoved,
	PolicyElementPropertiesEnumLocked,
	PolicyElementPropertiesEnumAnchored,
	PolicyElementPropertiesEnumSystem,
}

func (e PolicyElementPropertiesEnum) IsValid() bool {
	switch e {
	case PolicyElementPropertiesEnumAdded, PolicyElementPropertiesEnumUpdated, PolicyElementPropertiesEnumRemoved, PolicyElementPropertiesEnumMoved, PolicyElementPropertiesEnumLocked, PolicyElementPropertiesEnumAnchored, PolicyElementPropertiesEnumSystem:
		return true
	}
	return false
}

func (e PolicyElementPropertiesEnum) String() string {
	return string(e)
}

func (e *PolicyElementPropertiesEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyElementPropertiesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyElementPropertiesEnum", str)
	}
	return nil
}

func (e PolicyElementPropertiesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the status of a policy mutation
type PolicyMutationStatus string

const (
	PolicyMutationStatusSuccess PolicyMutationStatus = "SUCCESS"
	PolicyMutationStatusFailure PolicyMutationStatus = "FAILURE"
)

var AllPolicyMutationStatus = []PolicyMutationStatus{
	PolicyMutationStatusSuccess,
	PolicyMutationStatusFailure,
}

func (e PolicyMutationStatus) IsValid() bool {
	switch e {
	case PolicyMutationStatusSuccess, PolicyMutationStatusFailure:
		return true
	}
	return false
}

func (e PolicyMutationStatus) String() string {
	return string(e)
}

func (e *PolicyMutationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyMutationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyMutationStatus", str)
	}
	return nil
}

func (e PolicyMutationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of a policy revision
type PolicyRevisionType string

const (
	PolicyRevisionTypePrivate PolicyRevisionType = "PRIVATE"
	PolicyRevisionTypePublic  PolicyRevisionType = "PUBLIC"
)

var AllPolicyRevisionType = []PolicyRevisionType{
	PolicyRevisionTypePrivate,
	PolicyRevisionTypePublic,
}

func (e PolicyRevisionType) IsValid() bool {
	switch e {
	case PolicyRevisionTypePrivate, PolicyRevisionTypePublic:
		return true
	}
	return false
}

func (e PolicyRevisionType) String() string {
	return string(e)
}

func (e *PolicyRevisionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRevisionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRevisionType", str)
	}
	return nil
}

func (e PolicyRevisionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the position of a rule within a policy
type PolicyRulePositionEnum string

const (
	// The rule position is after the pre-existing specified rule
	PolicyRulePositionEnumAfterRule PolicyRulePositionEnum = "AFTER_RULE"
	// The rule position is before the pre-existing specified rule
	PolicyRulePositionEnumBeforeRule PolicyRulePositionEnum = "BEFORE_RULE"
	// The rule position is first in the specified section
	PolicyRulePositionEnumFirstInSection PolicyRulePositionEnum = "FIRST_IN_SECTION"
	// The rule position is last in the specified section
	PolicyRulePositionEnumLastInSection PolicyRulePositionEnum = "LAST_IN_SECTION"
	// The rule position is immediately after the system rules (first non-system rule)
	PolicyRulePositionEnumFirstInPolicy PolicyRulePositionEnum = "FIRST_IN_POLICY"
	// The rule position is last in the policy
	PolicyRulePositionEnumLastInPolicy PolicyRulePositionEnum = "LAST_IN_POLICY"
)

var AllPolicyRulePositionEnum = []PolicyRulePositionEnum{
	PolicyRulePositionEnumAfterRule,
	PolicyRulePositionEnumBeforeRule,
	PolicyRulePositionEnumFirstInSection,
	PolicyRulePositionEnumLastInSection,
	PolicyRulePositionEnumFirstInPolicy,
	PolicyRulePositionEnumLastInPolicy,
}

func (e PolicyRulePositionEnum) IsValid() bool {
	switch e {
	case PolicyRulePositionEnumAfterRule, PolicyRulePositionEnumBeforeRule, PolicyRulePositionEnumFirstInSection, PolicyRulePositionEnumLastInSection, PolicyRulePositionEnumFirstInPolicy, PolicyRulePositionEnumLastInPolicy:
		return true
	}
	return false
}

func (e PolicyRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicyRulePositionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRulePositionEnum", str)
	}
	return nil
}

func (e PolicyRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the frequency of an alert event for a rule
type PolicyRuleTrackingFrequencyEnum string

const (
	PolicyRuleTrackingFrequencyEnumHourly    PolicyRuleTrackingFrequencyEnum = "HOURLY"
	PolicyRuleTrackingFrequencyEnumDaily     PolicyRuleTrackingFrequencyEnum = "DAILY"
	PolicyRuleTrackingFrequencyEnumWeekly    PolicyRuleTrackingFrequencyEnum = "WEEKLY"
	PolicyRuleTrackingFrequencyEnumImmediate PolicyRuleTrackingFrequencyEnum = "IMMEDIATE"
)

var AllPolicyRuleTrackingFrequencyEnum = []PolicyRuleTrackingFrequencyEnum{
	PolicyRuleTrackingFrequencyEnumHourly,
	PolicyRuleTrackingFrequencyEnumDaily,
	PolicyRuleTrackingFrequencyEnumWeekly,
	PolicyRuleTrackingFrequencyEnumImmediate,
}

func (e PolicyRuleTrackingFrequencyEnum) IsValid() bool {
	switch e {
	case PolicyRuleTrackingFrequencyEnumHourly, PolicyRuleTrackingFrequencyEnumDaily, PolicyRuleTrackingFrequencyEnumWeekly, PolicyRuleTrackingFrequencyEnumImmediate:
		return true
	}
	return false
}

func (e PolicyRuleTrackingFrequencyEnum) String() string {
	return string(e)
}

func (e *PolicyRuleTrackingFrequencyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRuleTrackingFrequencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRuleTrackingFrequencyEnum", str)
	}
	return nil
}

func (e PolicyRuleTrackingFrequencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicySectionPositionEnum string

const (
	PolicySectionPositionEnumAfterSection  PolicySectionPositionEnum = "AFTER_SECTION"
	PolicySectionPositionEnumBeforeSection PolicySectionPositionEnum = "BEFORE_SECTION"
	PolicySectionPositionEnumLastInPolicy  PolicySectionPositionEnum = "LAST_IN_POLICY"
)

var AllPolicySectionPositionEnum = []PolicySectionPositionEnum{
	PolicySectionPositionEnumAfterSection,
	PolicySectionPositionEnumBeforeSection,
	PolicySectionPositionEnumLastInPolicy,
}

func (e PolicySectionPositionEnum) IsValid() bool {
	switch e {
	case PolicySectionPositionEnumAfterSection, PolicySectionPositionEnumBeforeSection, PolicySectionPositionEnumLastInPolicy:
		return true
	}
	return false
}

func (e PolicySectionPositionEnum) String() string {
	return string(e)
}

func (e *PolicySectionPositionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySectionPositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySectionPositionEnum", str)
	}
	return nil
}

func (e PolicySectionPositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the state of a policy
type PolicyToggleState string

const (
	PolicyToggleStateEnabled  PolicyToggleState = "ENABLED"
	PolicyToggleStateDisabled PolicyToggleState = "DISABLED"
)

var AllPolicyToggleState = []PolicyToggleState{
	PolicyToggleStateEnabled,
	PolicyToggleStateDisabled,
}

func (e PolicyToggleState) IsValid() bool {
	switch e {
	case PolicyToggleStateEnabled, PolicyToggleStateDisabled:
		return true
	}
	return false
}

func (e PolicyToggleState) String() string {
	return string(e)
}

func (e *PolicyToggleState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyToggleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyToggleState", str)
	}
	return nil
}

func (e PolicyToggleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProtoType string

const (
	ProtoTypeSocketX1500     ProtoType = "SOCKET_X1500"
	ProtoTypeVsocketVgx      ProtoType = "VSOCKET_VGX"
	ProtoTypeIpsecHost       ProtoType = "IPSEC_HOST"
	ProtoTypeIpsecClient     ProtoType = "IPSEC_CLIENT"
	ProtoTypeIpsecV2         ProtoType = "IPSEC_V2"
	ProtoTypeSocketX1600     ProtoType = "SOCKET_X1600"
	ProtoTypeSocketX1700     ProtoType = "SOCKET_X1700"
	ProtoTypeSocketAws1500   ProtoType = "SOCKET_AWS1500"
	ProtoTypeSocketAz1500    ProtoType = "SOCKET_AZ1500"
	ProtoTypeSocketEsx1500   ProtoType = "SOCKET_ESX1500"
	ProtoTypeCrossConnect    ProtoType = "CROSS_CONNECT"
	ProtoTypeSocketX1600Lte  ProtoType = "SOCKET_X1600_LTE"
	ProtoTypeVsocketVgxEsx   ProtoType = "VSOCKET_VGX_ESX"
	ProtoTypeVsocketVgxAws   ProtoType = "VSOCKET_VGX_AWS"
	ProtoTypeVsocketVgxAzure ProtoType = "VSOCKET_VGX_AZURE"
)

var AllProtoType = []ProtoType{
	ProtoTypeSocketX1500,
	ProtoTypeVsocketVgx,
	ProtoTypeIpsecHost,
	ProtoTypeIpsecClient,
	ProtoTypeIpsecV2,
	ProtoTypeSocketX1600,
	ProtoTypeSocketX1700,
	ProtoTypeSocketAws1500,
	ProtoTypeSocketAz1500,
	ProtoTypeSocketEsx1500,
	ProtoTypeCrossConnect,
	ProtoTypeSocketX1600Lte,
	ProtoTypeVsocketVgxEsx,
	ProtoTypeVsocketVgxAws,
	ProtoTypeVsocketVgxAzure,
}

func (e ProtoType) IsValid() bool {
	switch e {
	case ProtoTypeSocketX1500, ProtoTypeVsocketVgx, ProtoTypeIpsecHost, ProtoTypeIpsecClient, ProtoTypeIpsecV2, ProtoTypeSocketX1600, ProtoTypeSocketX1700, ProtoTypeSocketAws1500, ProtoTypeSocketAz1500, ProtoTypeSocketEsx1500, ProtoTypeCrossConnect, ProtoTypeSocketX1600Lte, ProtoTypeVsocketVgxEsx, ProtoTypeVsocketVgxAws, ProtoTypeVsocketVgxAzure:
		return true
	}
	return false
}

func (e ProtoType) String() string {
	return string(e)
}

func (e *ProtoType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtoType", str)
	}
	return nil
}

func (e ProtoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
type Regionality string

const (
	// Site traffic within the region
	RegionalityRegional Regionality = "REGIONAL"
	// Global traffic going outside of the region
	RegionalityGlobal Regionality = "GLOBAL"
)

var AllRegionality = []Regionality{
	RegionalityRegional,
	RegionalityGlobal,
}

func (e Regionality) IsValid() bool {
	switch e {
	case RegionalityRegional, RegionalityGlobal:
		return true
	}
	return false
}

func (e Regionality) String() string {
	return string(e)
}

func (e *Regionality) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Regionality(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Regionality", str)
	}
	return nil
}

func (e Regionality) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RemediationStatusEnum string

const (
	RemediationStatusEnumRemediated        RemediationStatusEnum = "REMEDIATED"
	RemediationStatusEnumPrevented         RemediationStatusEnum = "PREVENTED"
	RemediationStatusEnumBlocked           RemediationStatusEnum = "BLOCKED"
	RemediationStatusEnumNotFound          RemediationStatusEnum = "NOT_FOUND"
	RemediationStatusEnumScanFailed        RemediationStatusEnum = "SCAN_FAILED"
	RemediationStatusEnumClean             RemediationStatusEnum = "CLEAN"
	RemediationStatusEnumDisinfected       RemediationStatusEnum = "DISINFECTED"
	RemediationStatusEnumInfected          RemediationStatusEnum = "INFECTED"
	RemediationStatusEnumSuspicious        RemediationStatusEnum = "SUSPICIOUS"
	RemediationStatusEnumDeleted           RemediationStatusEnum = "DELETED"
	RemediationStatusEnumMoved             RemediationStatusEnum = "MOVED"
	RemediationStatusEnumUnknown           RemediationStatusEnum = "UNKNOWN"
	RemediationStatusEnumDeletedReboot     RemediationStatusEnum = "DELETED_REBOOT"
	RemediationStatusEnumPasswordProtected RemediationStatusEnum = "PASSWORD_PROTECTED"
	RemediationStatusEnumMovedReboot       RemediationStatusEnum = "MOVED_REBOOT"
	RemediationStatusEnumNotStarted        RemediationStatusEnum = "NOT_STARTED"
	RemediationStatusEnumSuccess           RemediationStatusEnum = "SUCCESS"
	RemediationStatusEnumRebootRequired    RemediationStatusEnum = "REBOOT_REQUIRED"
	RemediationStatusEnumDisabled          RemediationStatusEnum = "DISABLED"
	RemediationStatusEnumDisinfectFailed   RemediationStatusEnum = "DISINFECT_FAILED"
)

var AllRemediationStatusEnum = []RemediationStatusEnum{
	RemediationStatusEnumRemediated,
	RemediationStatusEnumPrevented,
	RemediationStatusEnumBlocked,
	RemediationStatusEnumNotFound,
	RemediationStatusEnumScanFailed,
	RemediationStatusEnumClean,
	RemediationStatusEnumDisinfected,
	RemediationStatusEnumInfected,
	RemediationStatusEnumSuspicious,
	RemediationStatusEnumDeleted,
	RemediationStatusEnumMoved,
	RemediationStatusEnumUnknown,
	RemediationStatusEnumDeletedReboot,
	RemediationStatusEnumPasswordProtected,
	RemediationStatusEnumMovedReboot,
	RemediationStatusEnumNotStarted,
	RemediationStatusEnumSuccess,
	RemediationStatusEnumRebootRequired,
	RemediationStatusEnumDisabled,
	RemediationStatusEnumDisinfectFailed,
}

func (e RemediationStatusEnum) IsValid() bool {
	switch e {
	case RemediationStatusEnumRemediated, RemediationStatusEnumPrevented, RemediationStatusEnumBlocked, RemediationStatusEnumNotFound, RemediationStatusEnumScanFailed, RemediationStatusEnumClean, RemediationStatusEnumDisinfected, RemediationStatusEnumInfected, RemediationStatusEnumSuspicious, RemediationStatusEnumDeleted, RemediationStatusEnumMoved, RemediationStatusEnumUnknown, RemediationStatusEnumDeletedReboot, RemediationStatusEnumPasswordProtected, RemediationStatusEnumMovedReboot, RemediationStatusEnumNotStarted, RemediationStatusEnumSuccess, RemediationStatusEnumRebootRequired, RemediationStatusEnumDisabled, RemediationStatusEnumDisinfectFailed:
		return true
	}
	return false
}

func (e RemediationStatusEnum) String() string {
	return string(e)
}

func (e *RemediationStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationStatusEnum", str)
	}
	return nil
}

func (e RemediationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResourceRoleEnum string

const (
	ResourceRoleEnumContextual        ResourceRoleEnum = "CONTEXTUAL"
	ResourceRoleEnumScanned           ResourceRoleEnum = "SCANNED"
	ResourceRoleEnumSource            ResourceRoleEnum = "SOURCE"
	ResourceRoleEnumDestination       ResourceRoleEnum = "DESTINATION"
	ResourceRoleEnumCreated           ResourceRoleEnum = "CREATED"
	ResourceRoleEnumAdded             ResourceRoleEnum = "ADDED"
	ResourceRoleEnumCompromised       ResourceRoleEnum = "COMPROMISED"
	ResourceRoleEnumEdited            ResourceRoleEnum = "EDITED"
	ResourceRoleEnumAttacked          ResourceRoleEnum = "ATTACKED"
	ResourceRoleEnumAttacker          ResourceRoleEnum = "ATTACKER"
	ResourceRoleEnumCommandAndControl ResourceRoleEnum = "COMMAND_AND_CONTROL"
	ResourceRoleEnumLoaded            ResourceRoleEnum = "LOADED"
	ResourceRoleEnumSuspicious        ResourceRoleEnum = "SUSPICIOUS"
	ResourceRoleEnumPolicyViolator    ResourceRoleEnum = "POLICY_VIOLATOR"
)

var AllResourceRoleEnum = []ResourceRoleEnum{
	ResourceRoleEnumContextual,
	ResourceRoleEnumScanned,
	ResourceRoleEnumSource,
	ResourceRoleEnumDestination,
	ResourceRoleEnumCreated,
	ResourceRoleEnumAdded,
	ResourceRoleEnumCompromised,
	ResourceRoleEnumEdited,
	ResourceRoleEnumAttacked,
	ResourceRoleEnumAttacker,
	ResourceRoleEnumCommandAndControl,
	ResourceRoleEnumLoaded,
	ResourceRoleEnumSuspicious,
	ResourceRoleEnumPolicyViolator,
}

func (e ResourceRoleEnum) IsValid() bool {
	switch e {
	case ResourceRoleEnumContextual, ResourceRoleEnumScanned, ResourceRoleEnumSource, ResourceRoleEnumDestination, ResourceRoleEnumCreated, ResourceRoleEnumAdded, ResourceRoleEnumCompromised, ResourceRoleEnumEdited, ResourceRoleEnumAttacked, ResourceRoleEnumAttacker, ResourceRoleEnumCommandAndControl, ResourceRoleEnumLoaded, ResourceRoleEnumSuspicious, ResourceRoleEnumPolicyViolator:
		return true
	}
	return false
}

func (e ResourceRoleEnum) String() string {
	return string(e)
}

func (e *ResourceRoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRoleEnum", str)
	}
	return nil
}

func (e ResourceRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RiskLevelEnum string

const (
	RiskLevelEnumMalicious    RiskLevelEnum = "Malicious"
	RiskLevelEnumInconclusive RiskLevelEnum = "Inconclusive"
	RiskLevelEnumBenign       RiskLevelEnum = "Benign"
	RiskLevelEnumHigh         RiskLevelEnum = "High"
	RiskLevelEnumMedium       RiskLevelEnum = "Medium"
	RiskLevelEnumLow          RiskLevelEnum = "Low"
	RiskLevelEnumNan          RiskLevelEnum = "nan"
)

var AllRiskLevelEnum = []RiskLevelEnum{
	RiskLevelEnumMalicious,
	RiskLevelEnumInconclusive,
	RiskLevelEnumBenign,
	RiskLevelEnumHigh,
	RiskLevelEnumMedium,
	RiskLevelEnumLow,
	RiskLevelEnumNan,
}

func (e RiskLevelEnum) IsValid() bool {
	switch e {
	case RiskLevelEnumMalicious, RiskLevelEnumInconclusive, RiskLevelEnumBenign, RiskLevelEnumHigh, RiskLevelEnumMedium, RiskLevelEnumLow, RiskLevelEnumNan:
		return true
	}
	return false
}

func (e RiskLevelEnum) String() string {
	return string(e)
}

func (e *RiskLevelEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskLevelEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskLevelEnum", str)
	}
	return nil
}

func (e RiskLevelEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScanResult string

const (
	ScanResultVirusFound          ScanResult = "VIRUS_FOUND"
	ScanResultEncrypted           ScanResult = "ENCRYPTED"
	ScanResultBypassByContentRule ScanResult = "BYPASS_BY_CONTENT_RULE"
	ScanResultClean               ScanResult = "CLEAN"
	ScanResultCancelled           ScanResult = "CANCELLED"
	ScanResultBypassByOther       ScanResult = "BYPASS_BY_OTHER"
	ScanResultBypassByType        ScanResult = "BYPASS_BY_TYPE"
)

var AllScanResult = []ScanResult{
	ScanResultVirusFound,
	ScanResultEncrypted,
	ScanResultBypassByContentRule,
	ScanResultClean,
	ScanResultCancelled,
	ScanResultBypassByOther,
	ScanResultBypassByType,
}

func (e ScanResult) IsValid() bool {
	switch e {
	case ScanResultVirusFound, ScanResultEncrypted, ScanResultBypassByContentRule, ScanResultClean, ScanResultCancelled, ScanResultBypassByOther, ScanResultBypassByType:
		return true
	}
	return false
}

func (e ScanResult) String() string {
	return string(e)
}

func (e *ScanResult) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanResult", str)
	}
	return nil
}

func (e ScanResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SeverityEnum string

const (
	SeverityEnumHigh   SeverityEnum = "High"
	SeverityEnumMedium SeverityEnum = "Medium"
	SeverityEnumLow    SeverityEnum = "Low"
)

var AllSeverityEnum = []SeverityEnum{
	SeverityEnumHigh,
	SeverityEnumMedium,
	SeverityEnumLow,
}

func (e SeverityEnum) IsValid() bool {
	switch e {
	case SeverityEnumHigh, SeverityEnumMedium, SeverityEnumLow:
		return true
	}
	return false
}

func (e SeverityEnum) String() string {
	return string(e)
}

func (e *SeverityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SeverityEnum", str)
	}
	return nil
}

func (e SeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteConnectionTypeEnum string

const (
	SiteConnectionTypeEnumSocketX1500    SiteConnectionTypeEnum = "SOCKET_X1500"
	SiteConnectionTypeEnumSocketX1600    SiteConnectionTypeEnum = "SOCKET_X1600"
	SiteConnectionTypeEnumSocketX1700    SiteConnectionTypeEnum = "SOCKET_X1700"
	SiteConnectionTypeEnumSocketEsx1500  SiteConnectionTypeEnum = "SOCKET_ESX1500"
	SiteConnectionTypeEnumSocketAws1500  SiteConnectionTypeEnum = "SOCKET_AWS1500"
	SiteConnectionTypeEnumSocketAz1500   SiteConnectionTypeEnum = "SOCKET_AZ1500"
	SiteConnectionTypeEnumSocketX1600Lte SiteConnectionTypeEnum = "SOCKET_X1600_LTE"
)

var AllSiteConnectionTypeEnum = []SiteConnectionTypeEnum{
	SiteConnectionTypeEnumSocketX1500,
	SiteConnectionTypeEnumSocketX1600,
	SiteConnectionTypeEnumSocketX1700,
	SiteConnectionTypeEnumSocketEsx1500,
	SiteConnectionTypeEnumSocketAws1500,
	SiteConnectionTypeEnumSocketAz1500,
	SiteConnectionTypeEnumSocketX1600Lte,
}

func (e SiteConnectionTypeEnum) IsValid() bool {
	switch e {
	case SiteConnectionTypeEnumSocketX1500, SiteConnectionTypeEnumSocketX1600, SiteConnectionTypeEnumSocketX1700, SiteConnectionTypeEnumSocketEsx1500, SiteConnectionTypeEnumSocketAws1500, SiteConnectionTypeEnumSocketAz1500, SiteConnectionTypeEnumSocketX1600Lte:
		return true
	}
	return false
}

func (e SiteConnectionTypeEnum) String() string {
	return string(e)
}

func (e *SiteConnectionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteConnectionTypeEnum", str)
	}
	return nil
}

func (e SiteConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseGroup string

const (
	SiteLicenseGroupGroup1 SiteLicenseGroup = "GROUP_1"
	SiteLicenseGroupGroup2 SiteLicenseGroup = "GROUP_2"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupMorocco SiteLicenseGroup = "MOROCCO"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupChina SiteLicenseGroup = "CHINA"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupVietnam SiteLicenseGroup = "VIETNAM"
	// legacy license group
	SiteLicenseGroupAnz SiteLicenseGroup = "ANZ"
	// legacy license group
	SiteLicenseGroupApj SiteLicenseGroup = "APJ"
	// legacy license group
	SiteLicenseGroupAfrica SiteLicenseGroup = "AFRICA"
	// legacy license group
	SiteLicenseGroupDubai SiteLicenseGroup = "DUBAI"
	// legacy license group
	SiteLicenseGroupEurope SiteLicenseGroup = "EUROPE"
	// legacy license group
	SiteLicenseGroupMiddleEast SiteLicenseGroup = "MIDDLE_EAST"
	// legacy license group
	SiteLicenseGroupNam SiteLicenseGroup = "NAM"
	// legacy license group
	SiteLicenseGroupLatam SiteLicenseGroup = "LATAM"
)

var AllSiteLicenseGroup = []SiteLicenseGroup{
	SiteLicenseGroupGroup1,
	SiteLicenseGroupGroup2,
	SiteLicenseGroupMorocco,
	SiteLicenseGroupChina,
	SiteLicenseGroupVietnam,
	SiteLicenseGroupAnz,
	SiteLicenseGroupApj,
	SiteLicenseGroupAfrica,
	SiteLicenseGroupDubai,
	SiteLicenseGroupEurope,
	SiteLicenseGroupMiddleEast,
	SiteLicenseGroupNam,
	SiteLicenseGroupLatam,
}

func (e SiteLicenseGroup) IsValid() bool {
	switch e {
	case SiteLicenseGroupGroup1, SiteLicenseGroupGroup2, SiteLicenseGroupMorocco, SiteLicenseGroupChina, SiteLicenseGroupVietnam, SiteLicenseGroupAnz, SiteLicenseGroupApj, SiteLicenseGroupAfrica, SiteLicenseGroupDubai, SiteLicenseGroupEurope, SiteLicenseGroupMiddleEast, SiteLicenseGroupNam, SiteLicenseGroupLatam:
		return true
	}
	return false
}

func (e SiteLicenseGroup) String() string {
	return string(e)
}

func (e *SiteLicenseGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseGroup", str)
	}
	return nil
}

func (e SiteLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseType string

const (
	SiteLicenseTypeSse  SiteLicenseType = "SSE"
	SiteLicenseTypeSase SiteLicenseType = "SASE"
)

var AllSiteLicenseType = []SiteLicenseType{
	SiteLicenseTypeSse,
	SiteLicenseTypeSase,
}

func (e SiteLicenseType) IsValid() bool {
	switch e {
	case SiteLicenseTypeSse, SiteLicenseTypeSase:
		return true
	}
	return false
}

func (e SiteLicenseType) String() string {
	return string(e)
}

func (e *SiteLicenseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseType", str)
	}
	return nil
}

func (e SiteLicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteType string

const (
	SiteTypeBranch       SiteType = "BRANCH"
	SiteTypeHeadquarters SiteType = "HEADQUARTERS"
	SiteTypeCloudDc      SiteType = "CLOUD_DC"
	SiteTypeDatacenter   SiteType = "DATACENTER"
)

var AllSiteType = []SiteType{
	SiteTypeBranch,
	SiteTypeHeadquarters,
	SiteTypeCloudDc,
	SiteTypeDatacenter,
}

func (e SiteType) IsValid() bool {
	switch e {
	case SiteTypeBranch, SiteTypeHeadquarters, SiteTypeCloudDc, SiteTypeDatacenter:
		return true
	}
	return false
}

func (e SiteType) String() string {
	return string(e)
}

func (e *SiteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteType", str)
	}
	return nil
}

func (e SiteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceDestType string

const (
	SocketInterfaceDestTypeCato                SocketInterfaceDestType = "CATO"
	SocketInterfaceDestTypeLan                 SocketInterfaceDestType = "LAN"
	SocketInterfaceDestTypeVrrpAndLan          SocketInterfaceDestType = "VRRP_AND_LAN"
	SocketInterfaceDestTypeInterfaceDisabled   SocketInterfaceDestType = "INTERFACE_DISABLED"
	SocketInterfaceDestTypeAlternative         SocketInterfaceDestType = "ALTERNATIVE"
	SocketInterfaceDestTypeLayer2Wan           SocketInterfaceDestType = "LAYER_2_WAN"
	SocketInterfaceDestTypeVrrp                SocketInterfaceDestType = "VRRP"
	SocketInterfaceDestTypeLanLagMasterAndVrrp SocketInterfaceDestType = "LAN_LAG_MASTER_AND_VRRP"
	SocketInterfaceDestTypeLanLagMaster        SocketInterfaceDestType = "LAN_LAG_MASTER"
	SocketInterfaceDestTypeLanLagMember        SocketInterfaceDestType = "LAN_LAG_MEMBER"
	SocketInterfaceDestTypeLanAndHa            SocketInterfaceDestType = "LAN_AND_HA"
)

var AllSocketInterfaceDestType = []SocketInterfaceDestType{
	SocketInterfaceDestTypeCato,
	SocketInterfaceDestTypeLan,
	SocketInterfaceDestTypeVrrpAndLan,
	SocketInterfaceDestTypeInterfaceDisabled,
	SocketInterfaceDestTypeAlternative,
	SocketInterfaceDestTypeLayer2Wan,
	SocketInterfaceDestTypeVrrp,
	SocketInterfaceDestTypeLanLagMasterAndVrrp,
	SocketInterfaceDestTypeLanLagMaster,
	SocketInterfaceDestTypeLanLagMember,
	SocketInterfaceDestTypeLanAndHa,
}

func (e SocketInterfaceDestType) IsValid() bool {
	switch e {
	case SocketInterfaceDestTypeCato, SocketInterfaceDestTypeLan, SocketInterfaceDestTypeVrrpAndLan, SocketInterfaceDestTypeInterfaceDisabled, SocketInterfaceDestTypeAlternative, SocketInterfaceDestTypeLayer2Wan, SocketInterfaceDestTypeVrrp, SocketInterfaceDestTypeLanLagMasterAndVrrp, SocketInterfaceDestTypeLanLagMaster, SocketInterfaceDestTypeLanLagMember, SocketInterfaceDestTypeLanAndHa:
		return true
	}
	return false
}

func (e SocketInterfaceDestType) String() string {
	return string(e)
}

func (e *SocketInterfaceDestType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceDestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceDestType", str)
	}
	return nil
}

func (e SocketInterfaceDestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids
type SocketInterfaceIDEnum string

const (
	SocketInterfaceIDEnumLan1  SocketInterfaceIDEnum = "LAN1"
	SocketInterfaceIDEnumLan2  SocketInterfaceIDEnum = "LAN2"
	SocketInterfaceIDEnumWan1  SocketInterfaceIDEnum = "WAN1"
	SocketInterfaceIDEnumWan2  SocketInterfaceIDEnum = "WAN2"
	SocketInterfaceIDEnumUsb1  SocketInterfaceIDEnum = "USB1"
	SocketInterfaceIDEnumUsb2  SocketInterfaceIDEnum = "USB2"
	SocketInterfaceIDEnumInt1  SocketInterfaceIDEnum = "INT_1"
	SocketInterfaceIDEnumInt2  SocketInterfaceIDEnum = "INT_2"
	SocketInterfaceIDEnumInt3  SocketInterfaceIDEnum = "INT_3"
	SocketInterfaceIDEnumInt4  SocketInterfaceIDEnum = "INT_4"
	SocketInterfaceIDEnumInt5  SocketInterfaceIDEnum = "INT_5"
	SocketInterfaceIDEnumInt6  SocketInterfaceIDEnum = "INT_6"
	SocketInterfaceIDEnumInt7  SocketInterfaceIDEnum = "INT_7"
	SocketInterfaceIDEnumInt8  SocketInterfaceIDEnum = "INT_8"
	SocketInterfaceIDEnumInt9  SocketInterfaceIDEnum = "INT_9"
	SocketInterfaceIDEnumInt10 SocketInterfaceIDEnum = "INT_10"
	SocketInterfaceIDEnumInt11 SocketInterfaceIDEnum = "INT_11"
	SocketInterfaceIDEnumInt12 SocketInterfaceIDEnum = "INT_12"
	SocketInterfaceIDEnumWlan  SocketInterfaceIDEnum = "WLAN"
	SocketInterfaceIDEnumLte   SocketInterfaceIDEnum = "LTE"
)

var AllSocketInterfaceIDEnum = []SocketInterfaceIDEnum{
	SocketInterfaceIDEnumLan1,
	SocketInterfaceIDEnumLan2,
	SocketInterfaceIDEnumWan1,
	SocketInterfaceIDEnumWan2,
	SocketInterfaceIDEnumUsb1,
	SocketInterfaceIDEnumUsb2,
	SocketInterfaceIDEnumInt1,
	SocketInterfaceIDEnumInt2,
	SocketInterfaceIDEnumInt3,
	SocketInterfaceIDEnumInt4,
	SocketInterfaceIDEnumInt5,
	SocketInterfaceIDEnumInt6,
	SocketInterfaceIDEnumInt7,
	SocketInterfaceIDEnumInt8,
	SocketInterfaceIDEnumInt9,
	SocketInterfaceIDEnumInt10,
	SocketInterfaceIDEnumInt11,
	SocketInterfaceIDEnumInt12,
	SocketInterfaceIDEnumWlan,
	SocketInterfaceIDEnumLte,
}

func (e SocketInterfaceIDEnum) IsValid() bool {
	switch e {
	case SocketInterfaceIDEnumLan1, SocketInterfaceIDEnumLan2, SocketInterfaceIDEnumWan1, SocketInterfaceIDEnumWan2, SocketInterfaceIDEnumUsb1, SocketInterfaceIDEnumUsb2, SocketInterfaceIDEnumInt1, SocketInterfaceIDEnumInt2, SocketInterfaceIDEnumInt3, SocketInterfaceIDEnumInt4, SocketInterfaceIDEnumInt5, SocketInterfaceIDEnumInt6, SocketInterfaceIDEnumInt7, SocketInterfaceIDEnumInt8, SocketInterfaceIDEnumInt9, SocketInterfaceIDEnumInt10, SocketInterfaceIDEnumInt11, SocketInterfaceIDEnumInt12, SocketInterfaceIDEnumWlan, SocketInterfaceIDEnumLte:
		return true
	}
	return false
}

func (e SocketInterfaceIDEnum) String() string {
	return string(e)
}

func (e *SocketInterfaceIDEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceIDEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceIDEnum", str)
	}
	return nil
}

func (e SocketInterfaceIDEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfacePrecedenceEnum string

const (
	SocketInterfacePrecedenceEnumActive     SocketInterfacePrecedenceEnum = "ACTIVE"
	SocketInterfacePrecedenceEnumPassive    SocketInterfacePrecedenceEnum = "PASSIVE"
	SocketInterfacePrecedenceEnumLastResort SocketInterfacePrecedenceEnum = "LAST_RESORT"
)

var AllSocketInterfacePrecedenceEnum = []SocketInterfacePrecedenceEnum{
	SocketInterfacePrecedenceEnumActive,
	SocketInterfacePrecedenceEnumPassive,
	SocketInterfacePrecedenceEnumLastResort,
}

func (e SocketInterfacePrecedenceEnum) IsValid() bool {
	switch e {
	case SocketInterfacePrecedenceEnumActive, SocketInterfacePrecedenceEnumPassive, SocketInterfacePrecedenceEnumLastResort:
		return true
	}
	return false
}

func (e SocketInterfacePrecedenceEnum) String() string {
	return string(e)
}

func (e *SocketInterfacePrecedenceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfacePrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfacePrecedenceEnum", str)
	}
	return nil
}

func (e SocketInterfacePrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceRole string

const (
	SocketInterfaceRoleWan1 SocketInterfaceRole = "wan_1"
	SocketInterfaceRoleWan2 SocketInterfaceRole = "wan_2"
	SocketInterfaceRoleWan3 SocketInterfaceRole = "wan_3"
	SocketInterfaceRoleWan4 SocketInterfaceRole = "wan_4"
)

var AllSocketInterfaceRole = []SocketInterfaceRole{
	SocketInterfaceRoleWan1,
	SocketInterfaceRoleWan2,
	SocketInterfaceRoleWan3,
	SocketInterfaceRoleWan4,
}

func (e SocketInterfaceRole) IsValid() bool {
	switch e {
	case SocketInterfaceRoleWan1, SocketInterfaceRoleWan2, SocketInterfaceRoleWan3, SocketInterfaceRoleWan4:
		return true
	}
	return false
}

func (e SocketInterfaceRole) String() string {
	return string(e)
}

func (e *SocketInterfaceRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceRole", str)
	}
	return nil
}

func (e SocketInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInventoryItemStatus string

const (
	SocketInventoryItemStatusOrdered   SocketInventoryItemStatus = "ORDERED"
	SocketInventoryItemStatusShipped   SocketInventoryItemStatus = "SHIPPED"
	SocketInventoryItemStatusDelivered SocketInventoryItemStatus = "DELIVERED"
	SocketInventoryItemStatusInstalled SocketInventoryItemStatus = "INSTALLED"
	SocketInventoryItemStatusConnected SocketInventoryItemStatus = "CONNECTED"
)

var AllSocketInventoryItemStatus = []SocketInventoryItemStatus{
	SocketInventoryItemStatusOrdered,
	SocketInventoryItemStatusShipped,
	SocketInventoryItemStatusDelivered,
	SocketInventoryItemStatusInstalled,
	SocketInventoryItemStatusConnected,
}

func (e SocketInventoryItemStatus) IsValid() bool {
	switch e {
	case SocketInventoryItemStatusOrdered, SocketInventoryItemStatusShipped, SocketInventoryItemStatusDelivered, SocketInventoryItemStatusInstalled, SocketInventoryItemStatusConnected:
		return true
	}
	return false
}

func (e SocketInventoryItemStatus) String() string {
	return string(e)
}

func (e *SocketInventoryItemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInventoryItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInventoryItemStatus", str)
	}
	return nil
}

func (e SocketInventoryItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketPlatform string

const (
	SocketPlatformX1500     SocketPlatform = "X1500"
	SocketPlatformX1500Br2  SocketPlatform = "X1500_BR2"
	SocketPlatformX1500bBr2 SocketPlatform = "X1500B_BR2"
	SocketPlatformX1600     SocketPlatform = "X1600"
	SocketPlatformX1700     SocketPlatform = "X1700"
	SocketPlatformX1700b    SocketPlatform = "X1700B"
	SocketPlatformAws1500   SocketPlatform = "AWS1500"
	SocketPlatformAz1500    SocketPlatform = "AZ1500"
	SocketPlatformEsx1500   SocketPlatform = "ESX1500"
	SocketPlatformX1600Lte  SocketPlatform = "X1600_LTE"
)

var AllSocketPlatform = []SocketPlatform{
	SocketPlatformX1500,
	SocketPlatformX1500Br2,
	SocketPlatformX1500bBr2,
	SocketPlatformX1600,
	SocketPlatformX1700,
	SocketPlatformX1700b,
	SocketPlatformAws1500,
	SocketPlatformAz1500,
	SocketPlatformEsx1500,
	SocketPlatformX1600Lte,
}

func (e SocketPlatform) IsValid() bool {
	switch e {
	case SocketPlatformX1500, SocketPlatformX1500Br2, SocketPlatformX1500bBr2, SocketPlatformX1600, SocketPlatformX1700, SocketPlatformX1700b, SocketPlatformAws1500, SocketPlatformAz1500, SocketPlatformEsx1500, SocketPlatformX1600Lte:
		return true
	}
	return false
}

func (e SocketPlatform) String() string {
	return string(e)
}

func (e *SocketPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPlatform", str)
	}
	return nil
}

func (e SocketPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketRegistrationStatus string

const (
	SocketRegistrationStatusNew                         SocketRegistrationStatus = "NEW"
	SocketRegistrationStatusPending                     SocketRegistrationStatus = "PENDING"
	SocketRegistrationStatusAssignedSite                SocketRegistrationStatus = "ASSIGNED_SITE"
	SocketRegistrationStatusRegistered                  SocketRegistrationStatus = "REGISTERED"
	SocketRegistrationStatusRejected                    SocketRegistrationStatus = "REJECTED"
	SocketRegistrationStatusUnassigning                 SocketRegistrationStatus = "UNASSIGNING"
	SocketRegistrationStatusAssignedSitePendingRegister SocketRegistrationStatus = "ASSIGNED_SITE_PENDING_REGISTER"
)

var AllSocketRegistrationStatus = []SocketRegistrationStatus{
	SocketRegistrationStatusNew,
	SocketRegistrationStatusPending,
	SocketRegistrationStatusAssignedSite,
	SocketRegistrationStatusRegistered,
	SocketRegistrationStatusRejected,
	SocketRegistrationStatusUnassigning,
	SocketRegistrationStatusAssignedSitePendingRegister,
}

func (e SocketRegistrationStatus) IsValid() bool {
	switch e {
	case SocketRegistrationStatusNew, SocketRegistrationStatusPending, SocketRegistrationStatusAssignedSite, SocketRegistrationStatusRegistered, SocketRegistrationStatusRejected, SocketRegistrationStatusUnassigning, SocketRegistrationStatusAssignedSitePendingRegister:
		return true
	}
	return false
}

func (e SocketRegistrationStatus) String() string {
	return string(e)
}

func (e *SocketRegistrationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketRegistrationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketRegistrationStatus", str)
	}
	return nil
}

func (e SocketRegistrationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketUpgradeStatus string

const (
	SocketUpgradeStatusPending       SocketUpgradeStatus = "PENDING"
	SocketUpgradeStatusPendingReboot SocketUpgradeStatus = "PENDING_REBOOT"
	SocketUpgradeStatusStarting      SocketUpgradeStatus = "STARTING"
	SocketUpgradeStatusStarted       SocketUpgradeStatus = "STARTED"
	SocketUpgradeStatusSuccess       SocketUpgradeStatus = "SUCCESS"
	SocketUpgradeStatusFail          SocketUpgradeStatus = "FAIL"
	SocketUpgradeStatusSkip          SocketUpgradeStatus = "SKIP"
	SocketUpgradeStatusCancel        SocketUpgradeStatus = "CANCEL"
	SocketUpgradeStatusFatal         SocketUpgradeStatus = "FATAL"
	SocketUpgradeStatusRetry         SocketUpgradeStatus = "RETRY"
)

var AllSocketUpgradeStatus = []SocketUpgradeStatus{
	SocketUpgradeStatusPending,
	SocketUpgradeStatusPendingReboot,
	SocketUpgradeStatusStarting,
	SocketUpgradeStatusStarted,
	SocketUpgradeStatusSuccess,
	SocketUpgradeStatusFail,
	SocketUpgradeStatusSkip,
	SocketUpgradeStatusCancel,
	SocketUpgradeStatusFatal,
	SocketUpgradeStatusRetry,
}

func (e SocketUpgradeStatus) IsValid() bool {
	switch e {
	case SocketUpgradeStatusPending, SocketUpgradeStatusPendingReboot, SocketUpgradeStatusStarting, SocketUpgradeStatusStarted, SocketUpgradeStatusSuccess, SocketUpgradeStatusFail, SocketUpgradeStatusSkip, SocketUpgradeStatusCancel, SocketUpgradeStatusFatal, SocketUpgradeStatusRetry:
		return true
	}
	return false
}

func (e SocketUpgradeStatus) String() string {
	return string(e)
}

func (e *SocketUpgradeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketUpgradeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketUpgradeStatus", str)
	}
	return nil
}

func (e SocketUpgradeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "asc"
	SortDirectionEnumDesc SortDirectionEnum = "desc"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryEngineTypeEnum string

const (
	StoryEngineTypeEnumAnomaly  StoryEngineTypeEnum = "ANOMALY"
	StoryEngineTypeEnumThreat   StoryEngineTypeEnum = "THREAT"
	StoryEngineTypeEnumEndpoint StoryEngineTypeEnum = "ENDPOINT"
	StoryEngineTypeEnumNetwork  StoryEngineTypeEnum = "NETWORK"
	StoryEngineTypeEnumIdentity StoryEngineTypeEnum = "IDENTITY"
)

var AllStoryEngineTypeEnum = []StoryEngineTypeEnum{
	StoryEngineTypeEnumAnomaly,
	StoryEngineTypeEnumThreat,
	StoryEngineTypeEnumEndpoint,
	StoryEngineTypeEnumNetwork,
	StoryEngineTypeEnumIdentity,
}

func (e StoryEngineTypeEnum) IsValid() bool {
	switch e {
	case StoryEngineTypeEnumAnomaly, StoryEngineTypeEnumThreat, StoryEngineTypeEnumEndpoint, StoryEngineTypeEnumNetwork, StoryEngineTypeEnumIdentity:
		return true
	}
	return false
}

func (e StoryEngineTypeEnum) String() string {
	return string(e)
}

func (e *StoryEngineTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryEngineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryEngineTypeEnum", str)
	}
	return nil
}

func (e StoryEngineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryProducerEnum string

const (
	StoryProducerEnumAnomalyStats              StoryProducerEnum = "AnomalyStats"
	StoryProducerEnumAnomalyEvents             StoryProducerEnum = "AnomalyEvents"
	StoryProducerEnumThreatHunt                StoryProducerEnum = "ThreatHunt"
	StoryProducerEnumThreatPrevention          StoryProducerEnum = "ThreatPrevention"
	StoryProducerEnumNetworkMonitor            StoryProducerEnum = "NetworkMonitor"
	StoryProducerEnumNetworkXdr                StoryProducerEnum = "NetworkXDR"
	StoryProducerEnumMicrosoftEndpointDefender StoryProducerEnum = "MicrosoftEndpointDefender"
	StoryProducerEnumCatoEndpointAlert         StoryProducerEnum = "CatoEndpointAlert"
	StoryProducerEnumEntraIDAlert              StoryProducerEnum = "EntraIdAlert"
)

var AllStoryProducerEnum = []StoryProducerEnum{
	StoryProducerEnumAnomalyStats,
	StoryProducerEnumAnomalyEvents,
	StoryProducerEnumThreatHunt,
	StoryProducerEnumThreatPrevention,
	StoryProducerEnumNetworkMonitor,
	StoryProducerEnumNetworkXdr,
	StoryProducerEnumMicrosoftEndpointDefender,
	StoryProducerEnumCatoEndpointAlert,
	StoryProducerEnumEntraIDAlert,
}

func (e StoryProducerEnum) IsValid() bool {
	switch e {
	case StoryProducerEnumAnomalyStats, StoryProducerEnumAnomalyEvents, StoryProducerEnumThreatHunt, StoryProducerEnumThreatPrevention, StoryProducerEnumNetworkMonitor, StoryProducerEnumNetworkXdr, StoryProducerEnumMicrosoftEndpointDefender, StoryProducerEnumCatoEndpointAlert, StoryProducerEnumEntraIDAlert:
		return true
	}
	return false
}

func (e StoryProducerEnum) String() string {
	return string(e)
}

func (e *StoryProducerEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryProducerEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryProducerEnum", str)
	}
	return nil
}

func (e StoryProducerEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StorySortFieldName string

const (
	StorySortFieldNameFirstSignal StorySortFieldName = "firstSignal"
	StorySortFieldNameUpdatedAt   StorySortFieldName = "updatedAt"
	StorySortFieldNameCreatedAt   StorySortFieldName = "createdAt"
	StorySortFieldNameAccountName StorySortFieldName = "accountName"
	StorySortFieldNameSeverity    StorySortFieldName = "severity"
	StorySortFieldNameRiskScore   StorySortFieldName = "riskScore"
	StorySortFieldNameCriticality StorySortFieldName = "criticality"
	StorySortFieldNameSource      StorySortFieldName = "source"
	StorySortFieldNameStatus      StorySortFieldName = "status"
	StorySortFieldNameProducer    StorySortFieldName = "producer"
	StorySortFieldNameQueryName   StorySortFieldName = "queryName"
	StorySortFieldNameSourceIP    StorySortFieldName = "sourceIp"
	StorySortFieldNameEngineType  StorySortFieldName = "engineType"
)

var AllStorySortFieldName = []StorySortFieldName{
	StorySortFieldNameFirstSignal,
	StorySortFieldNameUpdatedAt,
	StorySortFieldNameCreatedAt,
	StorySortFieldNameAccountName,
	StorySortFieldNameSeverity,
	StorySortFieldNameRiskScore,
	StorySortFieldNameCriticality,
	StorySortFieldNameSource,
	StorySortFieldNameStatus,
	StorySortFieldNameProducer,
	StorySortFieldNameQueryName,
	StorySortFieldNameSourceIP,
	StorySortFieldNameEngineType,
}

func (e StorySortFieldName) IsValid() bool {
	switch e {
	case StorySortFieldNameFirstSignal, StorySortFieldNameUpdatedAt, StorySortFieldNameCreatedAt, StorySortFieldNameAccountName, StorySortFieldNameSeverity, StorySortFieldNameRiskScore, StorySortFieldNameCriticality, StorySortFieldNameSource, StorySortFieldNameStatus, StorySortFieldNameProducer, StorySortFieldNameQueryName, StorySortFieldNameSourceIP, StorySortFieldNameEngineType:
		return true
	}
	return false
}

func (e StorySortFieldName) String() string {
	return string(e)
}

func (e *StorySortFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorySortFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorySortFieldName", str)
	}
	return nil
}

func (e StorySortFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryStatusEnum string

const (
	StoryStatusEnumOpen            StoryStatusEnum = "Open"
	StoryStatusEnumClosed          StoryStatusEnum = "Closed"
	StoryStatusEnumPendingMoreInfo StoryStatusEnum = "PendingMoreInfo"
	StoryStatusEnumPendingAnalysis StoryStatusEnum = "PendingAnalysis"
	StoryStatusEnumMonitoring      StoryStatusEnum = "Monitoring"
	StoryStatusEnumReopen          StoryStatusEnum = "Reopen"
)

var AllStoryStatusEnum = []StoryStatusEnum{
	StoryStatusEnumOpen,
	StoryStatusEnumClosed,
	StoryStatusEnumPendingMoreInfo,
	StoryStatusEnumPendingAnalysis,
	StoryStatusEnumMonitoring,
	StoryStatusEnumReopen,
}

func (e StoryStatusEnum) IsValid() bool {
	switch e {
	case StoryStatusEnumOpen, StoryStatusEnumClosed, StoryStatusEnumPendingMoreInfo, StoryStatusEnumPendingAnalysis, StoryStatusEnumMonitoring, StoryStatusEnumReopen:
		return true
	}
	return false
}

func (e StoryStatusEnum) String() string {
	return string(e)
}

func (e *StoryStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryStatusEnum", str)
	}
	return nil
}

func (e StoryStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryVerdictEnum string

const (
	StoryVerdictEnumSuspicious    StoryVerdictEnum = "Suspicious"
	StoryVerdictEnumMalicious     StoryVerdictEnum = "Malicious"
	StoryVerdictEnumInformational StoryVerdictEnum = "Informational"
	StoryVerdictEnumBenign        StoryVerdictEnum = "Benign"
)

var AllStoryVerdictEnum = []StoryVerdictEnum{
	StoryVerdictEnumSuspicious,
	StoryVerdictEnumMalicious,
	StoryVerdictEnumInformational,
	StoryVerdictEnumBenign,
}

func (e StoryVerdictEnum) IsValid() bool {
	switch e {
	case StoryVerdictEnumSuspicious, StoryVerdictEnumMalicious, StoryVerdictEnumInformational, StoryVerdictEnumBenign:
		return true
	}
	return false
}

func (e StoryVerdictEnum) String() string {
	return string(e)
}

func (e *StoryVerdictEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryVerdictEnum", str)
	}
	return nil
}

func (e StoryVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubnetType string

const (
	SubnetTypeRouted          SubnetType = "Routed"
	SubnetTypeDirect          SubnetType = "Direct"
	SubnetTypeVlan            SubnetType = "VLAN"
	SubnetTypeNative          SubnetType = "Native"
	SubnetTypeSecondaryNative SubnetType = "SecondaryNative"
)

var AllSubnetType = []SubnetType{
	SubnetTypeRouted,
	SubnetTypeDirect,
	SubnetTypeVlan,
	SubnetTypeNative,
	SubnetTypeSecondaryNative,
}

func (e SubnetType) IsValid() bool {
	switch e {
	case SubnetTypeRouted, SubnetTypeDirect, SubnetTypeVlan, SubnetTypeNative, SubnetTypeSecondaryNative:
		return true
	}
	return false
}

func (e SubnetType) String() string {
	return string(e)
}

func (e *SubnetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubnetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubnetType", str)
	}
	return nil
}

func (e SubnetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetType string

const (
	TargetTypeIP     TargetType = "ip"
	TargetTypeURL    TargetType = "url"
	TargetTypeDomain TargetType = "domain"
	TargetTypeFqdn   TargetType = "fqdn"
)

var AllTargetType = []TargetType{
	TargetTypeIP,
	TargetTypeURL,
	TargetTypeDomain,
	TargetTypeFqdn,
}

func (e TargetType) IsValid() bool {
	switch e {
	case TargetTypeIP, TargetTypeURL, TargetTypeDomain, TargetTypeFqdn:
		return true
	}
	return false
}

func (e TargetType) String() string {
	return string(e)
}

func (e *TargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetType", str)
	}
	return nil
}

func (e TargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeFrameModifier string

const (
	TimeFrameModifierStoryUpdate   TimeFrameModifier = "StoryUpdate"
	TimeFrameModifierStoryCreate   TimeFrameModifier = "StoryCreate"
	TimeFrameModifierAnalystUpdate TimeFrameModifier = "AnalystUpdate"
)

var AllTimeFrameModifier = []TimeFrameModifier{
	TimeFrameModifierStoryUpdate,
	TimeFrameModifierStoryCreate,
	TimeFrameModifierAnalystUpdate,
}

func (e TimeFrameModifier) IsValid() bool {
	switch e {
	case TimeFrameModifierStoryUpdate, TimeFrameModifierStoryCreate, TimeFrameModifierAnalystUpdate:
		return true
	}
	return false
}

func (e TimeFrameModifier) String() string {
	return string(e)
}

func (e *TimeFrameModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeFrameModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeFrameModifier", str)
	}
	return nil
}

func (e TimeFrameModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineItemCategoryEnum string

const (
	TimelineItemCategoryEnumInformation TimelineItemCategoryEnum = "Information"
	TimelineItemCategoryEnumWarning     TimelineItemCategoryEnum = "Warning"
	TimelineItemCategoryEnumError       TimelineItemCategoryEnum = "Error"
)

var AllTimelineItemCategoryEnum = []TimelineItemCategoryEnum{
	TimelineItemCategoryEnumInformation,
	TimelineItemCategoryEnumWarning,
	TimelineItemCategoryEnumError,
}

func (e TimelineItemCategoryEnum) IsValid() bool {
	switch e {
	case TimelineItemCategoryEnumInformation, TimelineItemCategoryEnumWarning, TimelineItemCategoryEnumError:
		return true
	}
	return false
}

func (e TimelineItemCategoryEnum) String() string {
	return string(e)
}

func (e *TimelineItemCategoryEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineItemCategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineItemCategoryEnum", str)
	}
	return nil
}

func (e TimelineItemCategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineTypeEnum string

const (
	TimelineTypeEnumDiff    TimelineTypeEnum = "Diff"
	TimelineTypeEnumAction  TimelineTypeEnum = "Action"
	TimelineTypeEnumComment TimelineTypeEnum = "Comment"
)

var AllTimelineTypeEnum = []TimelineTypeEnum{
	TimelineTypeEnumDiff,
	TimelineTypeEnumAction,
	TimelineTypeEnumComment,
}

func (e TimelineTypeEnum) IsValid() bool {
	switch e {
	case TimelineTypeEnumDiff, TimelineTypeEnumAction, TimelineTypeEnumComment:
		return true
	}
	return false
}

func (e TimelineTypeEnum) String() string {
	return string(e)
}

func (e *TimelineTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineTypeEnum", str)
	}
	return nil
}

func (e TimelineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeseriesMetricType string

const (
	// Total avg upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstream TimeseriesMetricType = "bytesUpstream"
	// Total avg downstream traffic (from the Cato Cloud to the site)
	TimeseriesMetricTypeBytesDownstream TimeseriesMetricType = "bytesDownstream"
	// Total max upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstreamMax TimeseriesMetricType = "bytesUpstreamMax"
	// Total max downstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesDownstreamMax TimeseriesMetricType = "bytesDownstreamMax"
	// Total upstream packets
	TimeseriesMetricTypePacketsUpstream TimeseriesMetricType = "packetsUpstream"
	// Total downstream packets
	TimeseriesMetricTypePacketsDownstream TimeseriesMetricType = "packetsDownstream"
	// Number of packets lost for upstream traffic
	TimeseriesMetricTypeLostUpstream TimeseriesMetricType = "lostUpstream"
	// Number of packets lost for downstream traffic
	TimeseriesMetricTypeLostDownstream TimeseriesMetricType = "lostDownstream"
	// Percent of packet loss for upstream traffic
	TimeseriesMetricTypeLostUpstreamPcnt TimeseriesMetricType = "lostUpstreamPcnt"
	// Percent of packet loss for downstream traffic
	TimeseriesMetricTypeLostDownstreamPcnt TimeseriesMetricType = "lostDownstreamPcnt"
	// Total packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstream TimeseriesMetricType = "packetsDiscardedDownstream"
	// Total packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstream TimeseriesMetricType = "packetsDiscardedUpstream"
	// Percent packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt TimeseriesMetricType = "packetsDiscardedUpstreamPcnt"
	// Percent packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt TimeseriesMetricType = "packetsDiscardedDownstreamPcnt"
	// Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterUpstream TimeseriesMetricType = "jitterUpstream"
	// Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterDownstream TimeseriesMetricType = "jitterDownstream"
	// Total number of bytes of upstream and downstream traffic
	TimeseriesMetricTypeBytesTotal TimeseriesMetricType = "bytesTotal"
	// Round-trip time from the Socket to the Cato Cloud
	TimeseriesMetricTypeRtt TimeseriesMetricType = "rtt"
	// Health analytics for the site
	TimeseriesMetricTypeHealth TimeseriesMetricType = "health"
	// The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)
	TimeseriesMetricTypeTunnelAge TimeseriesMetricType = "tunnelAge"
	// Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMilePacketLoss TimeseriesMetricType = "lastMilePacketLoss"
	// Latency from socket directly to a well known global service, not through Cato. This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMileLatency TimeseriesMetricType = "lastMileLatency"
)

var AllTimeseriesMetricType = []TimeseriesMetricType{
	TimeseriesMetricTypeBytesUpstream,
	TimeseriesMetricTypeBytesDownstream,
	TimeseriesMetricTypeBytesUpstreamMax,
	TimeseriesMetricTypeBytesDownstreamMax,
	TimeseriesMetricTypePacketsUpstream,
	TimeseriesMetricTypePacketsDownstream,
	TimeseriesMetricTypeLostUpstream,
	TimeseriesMetricTypeLostDownstream,
	TimeseriesMetricTypeLostUpstreamPcnt,
	TimeseriesMetricTypeLostDownstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedDownstream,
	TimeseriesMetricTypePacketsDiscardedUpstream,
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt,
	TimeseriesMetricTypeJitterUpstream,
	TimeseriesMetricTypeJitterDownstream,
	TimeseriesMetricTypeBytesTotal,
	TimeseriesMetricTypeRtt,
	TimeseriesMetricTypeHealth,
	TimeseriesMetricTypeTunnelAge,
	TimeseriesMetricTypeLastMilePacketLoss,
	TimeseriesMetricTypeLastMileLatency,
}

func (e TimeseriesMetricType) IsValid() bool {
	switch e {
	case TimeseriesMetricTypeBytesUpstream, TimeseriesMetricTypeBytesDownstream, TimeseriesMetricTypeBytesUpstreamMax, TimeseriesMetricTypeBytesDownstreamMax, TimeseriesMetricTypePacketsUpstream, TimeseriesMetricTypePacketsDownstream, TimeseriesMetricTypeLostUpstream, TimeseriesMetricTypeLostDownstream, TimeseriesMetricTypeLostUpstreamPcnt, TimeseriesMetricTypeLostDownstreamPcnt, TimeseriesMetricTypePacketsDiscardedDownstream, TimeseriesMetricTypePacketsDiscardedUpstream, TimeseriesMetricTypePacketsDiscardedUpstreamPcnt, TimeseriesMetricTypePacketsDiscardedDownstreamPcnt, TimeseriesMetricTypeJitterUpstream, TimeseriesMetricTypeJitterDownstream, TimeseriesMetricTypeBytesTotal, TimeseriesMetricTypeRtt, TimeseriesMetricTypeHealth, TimeseriesMetricTypeTunnelAge, TimeseriesMetricTypeLastMilePacketLoss, TimeseriesMetricTypeLastMileLatency:
		return true
	}
	return false
}

func (e TimeseriesMetricType) String() string {
	return string(e)
}

func (e *TimeseriesMetricType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeseriesMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeseriesMetricType", str)
	}
	return nil
}

func (e TimeseriesMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TrafficDirectionEnum string

const (
	TrafficDirectionEnumUpstream   TrafficDirectionEnum = "UPSTREAM"
	TrafficDirectionEnumDownstream TrafficDirectionEnum = "DOWNSTREAM"
)

var AllTrafficDirectionEnum = []TrafficDirectionEnum{
	TrafficDirectionEnumUpstream,
	TrafficDirectionEnumDownstream,
}

func (e TrafficDirectionEnum) IsValid() bool {
	switch e {
	case TrafficDirectionEnumUpstream, TrafficDirectionEnumDownstream:
		return true
	}
	return false
}

func (e TrafficDirectionEnum) String() string {
	return string(e)
}

func (e *TrafficDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficDirectionEnum", str)
	}
	return nil
}

func (e TrafficDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UnitType string

const (
	UnitTypeBytes   UnitType = "bytes"
	UnitTypePackets UnitType = "packets"
	UnitTypeBits    UnitType = "bits"
	UnitTypeMs      UnitType = "ms"
	UnitTypePercent UnitType = "percent"
	// health analytics for the site
	UnitTypeScore UnitType = "score"
	// The number of occurrences for this unit
	UnitTypeCount UnitType = "count"
	// For metrics that are measured in seconds, such as tunnelAge, the number of seconds
	UnitTypeSeconds UnitType = "seconds"
	// Bits per second
	UnitTypeBps UnitType = "bps"
	// Bytes per second
	UnitTypeBytesPerSec UnitType = "bytesPerSec"
	UnitTypeNone        UnitType = "none"
)

var AllUnitType = []UnitType{
	UnitTypeBytes,
	UnitTypePackets,
	UnitTypeBits,
	UnitTypeMs,
	UnitTypePercent,
	UnitTypeScore,
	UnitTypeCount,
	UnitTypeSeconds,
	UnitTypeBps,
	UnitTypeBytesPerSec,
	UnitTypeNone,
}

func (e UnitType) IsValid() bool {
	switch e {
	case UnitTypeBytes, UnitTypePackets, UnitTypeBits, UnitTypeMs, UnitTypePercent, UnitTypeScore, UnitTypeCount, UnitTypeSeconds, UnitTypeBps, UnitTypeBytesPerSec, UnitTypeNone:
		return true
	}
	return false
}

func (e UnitType) String() string {
	return string(e)
}

func (e *UnitType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitType", str)
	}
	return nil
}

func (e UnitType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleOwner        UserRole = "OWNER"
	UserRoleViewer       UserRole = "VIEWER"
	UserRolePublicViewer UserRole = "PUBLIC_VIEWER"
	UserRolePublicEditor UserRole = "PUBLIC_EDITOR"
	UserRoleEditor       UserRole = "EDITOR"
	UserRoleSuperUser    UserRole = "SUPER_USER"
	UserRoleSitesViewer  UserRole = "SITES_VIEWER"
)

var AllUserRole = []UserRole{
	UserRoleOwner,
	UserRoleViewer,
	UserRolePublicViewer,
	UserRolePublicEditor,
	UserRoleEditor,
	UserRoleSuperUser,
	UserRoleSitesViewer,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleOwner, UserRoleViewer, UserRolePublicViewer, UserRolePublicEditor, UserRoleEditor, UserRoleSuperUser, UserRoleSitesViewer:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VendorEnum string

const (
	VendorEnumCato      VendorEnum = "CATO"
	VendorEnumMicrosoft VendorEnum = "MICROSOFT"
)

var AllVendorEnum = []VendorEnum{
	VendorEnumCato,
	VendorEnumMicrosoft,
}

func (e VendorEnum) IsValid() bool {
	switch e {
	case VendorEnumCato, VendorEnumMicrosoft:
		return true
	}
	return false
}

func (e VendorEnum) String() string {
	return string(e)
}

func (e *VendorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorEnum", str)
	}
	return nil
}

func (e VendorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VrrpType string

const (
	VrrpTypeViaSwitch  VrrpType = "VIA_SWITCH"
	VrrpTypeDirectLink VrrpType = "DIRECT_LINK"
)

var AllVrrpType = []VrrpType{
	VrrpTypeViaSwitch,
	VrrpTypeDirectLink,
}

func (e VrrpType) IsValid() bool {
	switch e {
	case VrrpTypeViaSwitch, VrrpTypeDirectLink:
		return true
	}
	return false
}

func (e VrrpType) String() string {
	return string(e)
}

func (e *VrrpType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VrrpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VrrpType", str)
	}
	return nil
}

func (e VrrpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallActionEnum string

const (
	// Deny the network traffic from passing through the firewall.
	WanFirewallActionEnumBlock WanFirewallActionEnum = "BLOCK"
	// Allow the network traffic to pass through the firewall.
	WanFirewallActionEnumAllow WanFirewallActionEnum = "ALLOW"
	// Requests user confirmation to allow or block network traffic.
	WanFirewallActionEnumPrompt WanFirewallActionEnum = "PROMPT"
)

var AllWanFirewallActionEnum = []WanFirewallActionEnum{
	WanFirewallActionEnumBlock,
	WanFirewallActionEnumAllow,
	WanFirewallActionEnumPrompt,
}

func (e WanFirewallActionEnum) IsValid() bool {
	switch e {
	case WanFirewallActionEnumBlock, WanFirewallActionEnumAllow, WanFirewallActionEnumPrompt:
		return true
	}
	return false
}

func (e WanFirewallActionEnum) String() string {
	return string(e)
}

func (e *WanFirewallActionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallActionEnum", str)
	}
	return nil
}

func (e WanFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallDirectionEnum string

const (
	WanFirewallDirectionEnumTo   WanFirewallDirectionEnum = "TO"
	WanFirewallDirectionEnumBoth WanFirewallDirectionEnum = "BOTH"
)

var AllWanFirewallDirectionEnum = []WanFirewallDirectionEnum{
	WanFirewallDirectionEnumTo,
	WanFirewallDirectionEnumBoth,
}

func (e WanFirewallDirectionEnum) IsValid() bool {
	switch e {
	case WanFirewallDirectionEnumTo, WanFirewallDirectionEnumBoth:
		return true
	}
	return false
}

func (e WanFirewallDirectionEnum) String() string {
	return string(e)
}

func (e *WanFirewallDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallDirectionEnum", str)
	}
	return nil
}

func (e WanFirewallDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Geographical regions that can be associated with a remote user license
type ZtnaUsersLicenseGroup string

const (
	ZtnaUsersLicenseGroupGeneral ZtnaUsersLicenseGroup = "GENERAL"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupMorocco ZtnaUsersLicenseGroup = "MOROCCO"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupVietnam ZtnaUsersLicenseGroup = "VIETNAM"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupChina ZtnaUsersLicenseGroup = "CHINA"
	// Legacy group
	ZtnaUsersLicenseGroupDubai ZtnaUsersLicenseGroup = "DUBAI"
	// Legacy group
	ZtnaUsersLicenseGroupLatam ZtnaUsersLicenseGroup = "LATAM"
)

var AllZtnaUsersLicenseGroup = []ZtnaUsersLicenseGroup{
	ZtnaUsersLicenseGroupGeneral,
	ZtnaUsersLicenseGroupMorocco,
	ZtnaUsersLicenseGroupVietnam,
	ZtnaUsersLicenseGroupChina,
	ZtnaUsersLicenseGroupDubai,
	ZtnaUsersLicenseGroupLatam,
}

func (e ZtnaUsersLicenseGroup) IsValid() bool {
	switch e {
	case ZtnaUsersLicenseGroupGeneral, ZtnaUsersLicenseGroupMorocco, ZtnaUsersLicenseGroupVietnam, ZtnaUsersLicenseGroupChina, ZtnaUsersLicenseGroupDubai, ZtnaUsersLicenseGroupLatam:
		return true
	}
	return false
}

func (e ZtnaUsersLicenseGroup) String() string {
	return string(e)
}

func (e *ZtnaUsersLicenseGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaUsersLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaUsersLicenseGroup", str)
	}
	return nil
}

func (e ZtnaUsersLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
